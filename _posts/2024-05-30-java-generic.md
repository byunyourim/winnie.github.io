---
layout: post
title: Generic
categories: Java
---

## Generic
<span style="background-color: #D0E4FC">**데이터 타입을 일반화하여 클래스, 인터페이스, 메서드를 정의할 때 사용하는 기능**</span>  

클래스나 메서드를 선언할 때 타입을 명시적으로 지정하지 않고 사용하는 시점에서 실제 타입을 지정할 수 있습니다.    

제네릭을 이용하여 특정 타입에 의존하지 않고 데이터 구조나 알고리즘을 정의할 수 있으며 코드의 재사용성과 타입 안정성을 향상 시킬 수 있습니다.  
  
컴파일 타임에 타입을 체크할 수 있어 런타임에 발생할 수 있는 오류를 예방할 수 있으며 형 변환의 번거로움을 줄일 수 있습니다.


T(Type), E(Element), K(Key), V(Value)

  
동작방식은 우선 클래스나 메서드 선언시 타입 매개변수를 선언합니다.   
선언된 제네릭 클래스를 사용할 때는 타입 인자를 지정하여 구체적인 타입을 명시해줍니다.
  
그 후 컴파일러가 타입 안정성을 보장하기 위해 타입 체크를 수행하여 잘못된 타입에 대한 경고나 오류를 찾을 수 있습니다.
  
제네릭을 사용하면 타입 변환을 자동으로 처리할 수 있어 코드가 간결해지고 가독성이 높아집니다. 또한 잘못된 타입 변화로 인한 런타임 오류를 줄일 수 있습니다.


동일한 코드를 참조 타입에 대해 재사용할 수 있는 장점이 있다. 또한 타입 캐스팅을 줄여 코드 가독성과 유지보수성을 높일 수 있다. 원시타입에 대해서는 사용할 수 없다.

하지만 다소 복잡할 수 있으며 컴파일 후 타입 소거로 인해 런타임에는 제네릭 타입 정보가 소실된다. (실행시점에는 Object 타입으로 다뤄짐)

<br>


## 제네릭에서 와일드카드를 사용하는 경우에는 어떤 상황에서 어떻게 사용하나요? 
와일드 카드는 특정 타입을 지정하지 않고 더 범용적인 타입을 처리할 수 있도록 도와주는 문법으로 제네릭 타입의 유연성과 타입 안정성을 유지하면서 코드의 재사용성을 높여줍니다. 메서드에서 특정 제네릭 타입을 받아들이지만 실제 타입에 대해 정확히 알 필요가 없는 경우에 사용하거나 클래스의 일부 멤버 변수가 제네릭 타입일 때 다양한 타입의 객체를 다룰수 있도록 하기 위해 사용됩니다.

와일드 카드는 모든 타입을 나타내며 구체적인 타입을 알 필요가 없는 경우에 사용합니다. List 의경우 어떤 종류의 리스트도 받을 수 있습니다.


<br>


## 와일드카드의 종류
### 1. 무제한 와일드카드: <?>
 - 모든 타입을 나타내며 구체적인 타입을 알 필요가 없는 경우 사용합니다.
 - List<?> 의 경우 어떤 종류의 리스트도 받을 수 있습니다.

### 2. **상한 제한 와일드카드**: **`<? extends T>`**
 - T타입과 그 하위 타입들을 나타낼 수 있습니다.
- `List<? extends Number>`는 `Number` 타입과 그 하위 타입들을 모두 받을 수 있습니다.

### 3. **하한 제한 와일드카드**: **`<? super T>`**
- T 타입과 그 상위 타입들을 나타냅니다.
- List<? super Integer>은 Integer타입과 그 상위타입들을 받을 수 있습니다.


**하한 제한 와일드카드**는 특정 타입 T 와 그 타입의 상위 클래스만 허용하는 제네릭 타입입니다.

주로 메서드의 매개변수 타입으로 사용되어 메서드가 여러 관련 타입을 처리할 수 있도록 유연성을 제공합니다.

**상한 제한 와일드카드**는 특정 타입의 하위 타입만 허용하는 경우에 사용됩니다. 주로 컬렉션에서 요소를 읽을 때 유용합니다.

와일드 카드는 매개변수로만 사용될 수 있으며 제네릭 클래스나 제네릭 메서드의 반환 타입으로는 사용할 수 없습니다.

와일드 카드를 사용하면 컬렉션의 요소를 읽는 것은 가능하지만 쓰는것은 불가능합니다. List<?> 에는 null 만 추가할 수 있습니다.



### 사용상황

메서드에서 특정 제네릭 타입을 받아들이지만 실제 타입에 대해 정확히 알 필요가 없는 경우 사용합니다.

클래스의 일부 멤버 변수가 제네릭 타입일 때 다양한 타입의 객체를 다룰 수 있도록 하기 위해 사용됩니다.



|특징|<? super T>|<? extends T>|
------|-------|-------|-------|
|허용타입|T와 T의 상위 타입|T와 T의 하위 타입|
|쓰기가능|T와 T의 하위 타입 추가 가능|추가 불가능|
|읽기가능|Object 타입으로 읽기|T 타입으로 읽기|



<br>


## 와일드카드를 사용할 때 주의해야 할 점은 무엇인가요? 
와일드카드 타입은 읽기 전용으로 요소를 추가하려면 null 만 추가할 수 있습니다. 따라서 컬렉션에 요소를 추가하는 용도로는 사용할 수 없습니다.

또한 와일드 카드를 사용하면 타입 안정성은 보장되지만 실제로 그 범위는 정확히 알 수 없습니다. 따라서 와일드 카드를 사용할 때는 타입 체크를 하기 어렵거나 혼란스러울 수 있습니다.

또한 일부 메서드의 호출이 제한될 수 있습니다.


<br>


## 와일드카드를 사용하지 않고 어떻게 대체할 수 있을까요?

대체하는 방법에는 타입 매개변수를 사용하는 것입니다. 이 방법을 통해 정확한 타입 지정과 메서드 호출이 가능하며 코드의 가독성과 유지보수성을 높일 수 있습니다.

컴파일러가 타입을 추론할 수 있고 실제로 해당 타입과 관련된 메서드를 호출할 수 있습니다.

또한 나 의 경우 상위 타입을 명시적으로 지정할 수 있습니다. 와일드 카드의 범위가 너무 넓은 경우 상위 타입을 지정하여 구체화할 수 있습니다


<br>


## 와일드카드를 사용함으로써 발생할 수 있는 제한 사항은 어떤 것들이 있을까요? 
와일드 카드로 선언된 컬렉션에는 요소를 추가할 수 없습니다. null 은 추가할 수 있지만 실제 요소는 추가할 수 없습니다.

또한 일부 메서드의 호출이 제한됩니다.

그리고 특정타입을 정확히 알 수 없기 때문에 런타임 시 타입 안정성이 보장되지 않을 수 있습니다.


<br>


## 와일드카드와 타입 매개변수를 사용하는 것 간에 어떤 차이가 있을까요?
와일드카드와 타입 매개변수의 차이에는 타입 매개변수를 사용한 제네릭 메서드는 해당 타입에 대해 정확한 메서드 호출이 가능합니다.

또한 타입 매개변수를 사용하는 경우 메서드 호출 시 컴파일러가 타입을 추론할 수 있습니다. 와일드 카드는 추론이 어려울 수 있습니다.

또한 타입 매개변수는 구체적인 타입을 지정할 수 있어 컴파일러가 타입 체크를 수행하고 필요한 경우 캐스팅 없이 안전하게 요소를 사용할 수 있습니다. 반면 와일드 카드는 런타임에 타입이 정확히 무엇인지 알 수 없으며 이로 인해 타입 안정성이 보장되지 않을 수 있습니다.


