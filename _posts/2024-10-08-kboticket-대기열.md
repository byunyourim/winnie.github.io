---
layout: post
title: 티켓팅 시스템 - 대기열 구현
categories: [kboticket]
---


이 시스템은 트래픽이 몰리는 경우를 가정하며, 실시간으로 순번이 조회가 가능해야 한다.
  

SQS, RabbitMQ, Kafka와 같은 큐 서비스의 장단점 확인 후 적합성 판단.

<br>

### SQS
#### 장점
- AWS에서 관리되는 서비스로 운영 부담이 적다.
- 높은 가용성과 내구성을 보장하며, AWS 생태계와 통합이 용이하다.
#### 단점
- 메시지 큐잉에 최적화되어 있어 실시간 데이터 스트리밍에 부적합하다.
- 초당 수백만 개의 메시지 처리에느 한계가 있을 수 있다.  

#### 적합성
- SQS는 간단한 메시지 큐잉에 적합하지만, 대규모 트래픽을 처리하기에는 한계가 있다.  



<br>

### RabbitMQ
#### 장점
- 다양한 라우팅 옵션과 기능을 제공한다.(우선순위, TTL)
- 클러스터링을 통한 고가용성 지원
#### 단점
- 매우 큰 규모의 메시징 시스템에서 성능이 떨어질 수 있다.  
- 설정 및 운영이 복잡할 수 있다.  


#### 정합성
- 초당 수백만 개의 요청 처리에는 제한이 있다.  


<br>

### Kafka
#### 장점
- 초당 수백만 개의 메시지를 처리할 수 있는 높은 처리량. 
- 내구성을 보장하고 장애 발생 시 데이터 손실 최소화한다.
- 클러스터 확장이 용이하여 트래픽 급증에 유연하게 대응이 가능하다.

#### 단점
- 설정이 다소 복잡할 수 있으며, 관리가 필요하다.


<br>

대량의 트래픽 처리에 최적화되어 있고, 장애 발생 시에도 데이터 손실을 최소화할 수 있어, KF 수천 명이 동시에 몰리는 티켓 예매 시스템에 적합하다고 판단.


<br><br><br>






## 로직
1. 수 천 명의 유저가 경기 좌석 선택 페이지(/ticket-paage)에 진입한다.
2. 수 천 명의 유저가 대기열에 쌓인다.
3. 실시간으로 자신의 순번을 확인할 수 있다.
4. 새로고침 등으로 화면 이탈시 대기열을 빠져나간다.
5. 다시 좌석 선택 페이지에 접근하면 대기열의 맨 뒤로 이동한다.
6. 일정시간마다 대기열의 일정사용자들이 페이지에 진입한다. 
7. 내 순번이 앞당겨진다. 
8. 내 차례가 되어 화면에 진입한다.



<br><br><br>

### 1. Kafka 대기열 분산 처리
- 하루에 최대 다섯 개의 경기가 열린다.
- 각 경기별로 토픽을 나누어 각 경기에 대한 대기열을 관리한다.
- 유저가 대기열에 들어오면 produce하여 유저의 정보를 전송한다.
- 자신의 순번이 될 때, consume하여 유자가 입장할 수 있도록 한다.


### 2. 대기열 관리
- Redis ZSet을 이용하여 유저를 대기열에 추가하고 우선순위를 결정한다.  
- 유저가 대기열에 진입할 때, userId와 함께 타임스탬프, 우선순위를 설정하여 대기열의 끝에 추가한다.



### 3. 실시간 순번 업데이트
- SSE를 통해 실시간으로 자신의 순번을 확인한다. 
- 대기열 상태가 변경되면, 서버가 SSE로 각 유저에게 업데이트를 보낸다.  
- 대기열에서 순번이 앞당겨지면 즉시 클라이언트로 해당 정보가 전송된다.

#### SSE를 선택한 이유?
서버 -> 클라이언트 단방향 클라이언트로 이벤트를 스트리밍할 수 있다.


### 4. 페이지 이탈 시 
- 유저가 대기열에서 나가거나 새로고침 하는 경우 ZSet에서 제거한다.
- 다시 접속하면 대기열의 맨 뒤에 새로 추가한다.



### 5. 일정 시간마다 사용자 진입
- 일정 시간 마다 Scheduler을 통해 대기열에서 좌석 선택 페이지로 입장시킨다.
- 입장 가능한 사용자에게 SSE를 통해 알림을 보낸다.
- 이 작업은 고정된 간격으로 진행된다.
- 예로 1초에 100명씩 입장.






 