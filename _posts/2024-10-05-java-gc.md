---
layout: post
title: GC(Garbage Collection)란?
categories: [Java]
---

프로그래밍 언어에서 자동으로 메모리를 관리하는 기능이다.  

객체를 더 이상 사용하지 않을 때 그 객체를 메모리에서 자동으로 해제하여 메모리 누수를 방지한다.  

개발자가 메모리를 직접 관리할 필요가 없어, 메모리 할당과 해제를 자동으로 처리하여 오류를 줄인다.
메모리 누수와 이중 해제 등 메모리 관련 버그를 줄여 프로그램의 안정성을 높이며, 메모리 공간을 효율적으로 사용할 수 있도록 한다.  
  
  
**GC는 크게 두 가지 메모리 영역에서 동작한다.**
- Young Generation (Young 영역)
- Old Generation (Old 영역)  



<br><br><br>

### JVM 메모리 구조
- Eden Space: 새롭게 생성된 객체가 우선 저장되는 공간.
- Survivor Space: Eden 영역에서 살아남은 객체가 이동하는 공간.
- Old Generation: Young Generation을 여러 번 거친 객체들이 이동하여 오래 살아남은 객체들이 모이는 공간.




<br><br><br>

## GC 동작 과정
1. 객체 생성: 
   - 새로운 객체는 Young Generation의 Eden 영역에 저장된다.
2. Minor GC 실행: 
   - Eden 영역이 꽉 차면 Minor GC가 실행되어, 사용 중인 객체는 Survivor 영역으로 이동되고, 나머지 객체는 삭제됩니다.
3. Old Generation 이동: 
   - 여러 번의 Minor GC를 거친 객체는 Old Generation으로 이동한다.
4. Major GC 실행:
   - Old Generation이 가득 차거나, 메모리가 부족할 때, Major GC가 실행된다. 
   - Old Generation 내에서 사용되지 않는 객체를 제거한다.
5. Full GC 실행:  
   전체 메모리가 부족하거나 Old Generation과 Young Generation 모두를 대상으로 메모리를 정리할 때 Full GC가 발생한다.

#### 장점:
- 개발자가 메모리 해제에 신경 쓸 필요가 없어, 프로그램 개발 속도가 빠르다.
- 불필요한 메모리 사용을 방지하고, 프로그램이 안정적으로 동작한다.

#### 단점:
- GC가 실행되는 동안 애플리케이션이 일시적으로 중단될 수 있다. 특히 Full GC는 성능에 치명적인 영향을 줄 수 있다.
- GC가 언제 발생할지 예측하기 어려워, 특정 시점에 성능 저하를 야기할 수 있다.



<br><br><br>

## 개발자가 GC에 신경을 덜 쓸 수 있는 편리함과 단점
- 자동으로 메모리 관리가 이루어지기 때문에 개발자는 비즈니스 로직에 집중할 수 있으며,
GC가 자주 실행되기 때문에 메모리 누수나 해제 오류에 대해 걱정할 필요가 줄어든다. 
  
하지만 GC가 실행될 때, 일시적으로 애플리케이션 성능이 저하될 수 있으며,   
특히, Full GC는 애플리케이션을 중단시키는 경우가 많아 응답성이 떨어질 수 있다.  

그리고 실행 시점을 예측할 수 없어, 특정 작업이 필요할 때 GC가 발생하면 성능에 영향을 미칠 수 있다.  
GC가 비효율적으로 작동하는 경우 필요한 메모리보다 더 많은 메모리를 소비한다.  





<br><br><br>

## 개발자가 GC 튜닝을 하는 궁극적인 목표
- 성능 최적화 :   
  GC의 성능을 조정하여 애플리케이션의 응답을 향상시키고, 불필요한 지연을 최소화한다.
- 메모리 사용량 관리 :   
  메모리 소비를 최적화하여 애플리케이션이 사용 가능한 메모리 자원을 효율적으로 사용할 수 있도록 한다.
- 리소스 균형 :   
  CPU, 메모리 등의 시스템 자원을 효율적으로 관리하여 전반적인 시스템 성능을 최적화한다.





<br><br><br>

## 4. G1GC는 어떻게 만들어졌고, 개발자가 튜닝을 덜 해도 되는 이유
G1GC는 자바7에서 도입된 GC 알고리즘으로, 대용량 힙을 효과적으로 관리하도록 설계되어있다.  
- 리전 기반의 메모리 관리 : 
  - G1GC 는 메모리를 작은 리전으로 나누어 관리한다.
  - 각 리전은 서로 독립적이기 때문에 메모리를 동적으로 할당하고 해제할 수 있습니다.   
  - 따라서 더 유연한 메모리 관리 기능이 가능합니다.
- 예측 가능한 지연
  - G1GC는 최대 GC 지연 시간을 설정할 수 있어, 개발자가 원하는 지연 시간을 유지하며 GC를 실행할 수 있다.
- 가비지 우선 수집
  - G1GC는 가바지 객체가 많은 리전을 우선적으로 수집하는 방식이다.  
  - 메모리 회수 효율을 높이고 애플리케이션 성능을 안정적으로 유지할 수 있다. 





<br><br><br>

## 5. 리전으로 구성된 구조가 왜 튜닝의 수고를 덜어주는지
- 유연성
   - 리진 기반의 구조는 메모리 사용 패턴에 따라 동적으로 리전을 할당 및 해제할 수 있다.
   - 개발자는 특정 영역에서 메모리를 조정할 필요없이, GC가 자동으로 조정한다. 
- 최적화된 가비지 수집
   - 가비지 객체가 많은 리전을 우선으로 수집하여, 불필요한 메모리 회수를 줄인다. 
   - 따라서 개발자는 소스 코드에 메모리 최적화 로직을 추가할 필요가 없다.
- 예측 가능한 성능
   - G1GC는 GC 간격을 예측할 수 있게 하여, 성능을 예측 가능하게 만든다.
   - 따라서 개발자는 성능을 개선하기 위해 다양한 GC 파라미터를 실험할 필요가 줄어든다.
  
  
결과적으로, G1GC는 메모리 관리의 복잡성을 줄이고 성능을 안정적으로 유지하는 데 중점을 두고 설계되었습니다. 개발자는 GC의 세부 조정보다는 비즈니스 로직에 집중할 수 있게 됩니다.
