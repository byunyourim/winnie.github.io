[
  
  {
    "title": "티켓팅 시스템 - 대기열 구현",
    "url": "/posts/kboticket-%EB%8C%80%EA%B8%B0%EC%97%B4/",
    "categories": "kboticket",
    "tags": "",
    "date": "2024-10-08 00:00:00 +0800",
    





    
    "snippet": "이 시스템은 트래픽이 몰리는 경우를 가정한다.구현  (수천 명의 동시 요청) 대용량 트래픽이 몰리는 경우  순번 조회 가능SQS, RabbitMQ, Kafka와 같은 큐 서비스의 장단점 확인 후 적합성 판단.SQS장점  AWS에서 관리되는 서비스로 운영 부담이 적다.  높은 가용성과 내구성을 보장하며, AWS 생태계와 통합이 용이하다.    단점   ...",
    "content": "이 시스템은 트래픽이 몰리는 경우를 가정한다.구현  (수천 명의 동시 요청) 대용량 트래픽이 몰리는 경우  순번 조회 가능SQS, RabbitMQ, Kafka와 같은 큐 서비스의 장단점 확인 후 적합성 판단.SQS장점  AWS에서 관리되는 서비스로 운영 부담이 적다.  높은 가용성과 내구성을 보장하며, AWS 생태계와 통합이 용이하다.    단점    메시지 큐잉에 최적화되어 있어 실시간 데이터 스트리밍에 부적합하다.  초당 수백만 개의 메시지 처리에느 한계가 있을 수 있다.적합성  SQS는 간단한 메시지 큐잉에 적합하지만, 대규모 트래픽을 처리하기에는 한계가 있다.RabbitMQ장점  다양한 라우팅 옵션과 기능을 제공한다.(우선순위, TTL)  클러스터링을 통한 고가용성 지원    단점    매우 큰 규모의 메시징 시스템에서 성능이 떨어질 수 있다.  설정 및 운영이 복잡할 수 있다.정합성  초당 수백만 개의 요청 처리에는 제한이 있다.Kafka장점  초당 수백만 개의 메시지를 처리할 수 있는 높은 처리량.  내구성을 보장하고 장애 발생 시 데이터 손실 최소화한다.  클러스터 확장이 용이하여 트래픽 급증에 유연하게 대응이 가능하다.단점  설정이 다소 복잡할 수 있으며, 관리가 필요하다.대량의 트래픽 처리에 최적화되어 있고, 장애 발생 시에도 데이터 손실을 최소화할 수 있어, 수천 명이 동시에 몰리는 티켓 예매 시스템에 적합하다고 판단."
  },
  
  {
    "title": "CreatedDate, LastModifiedDate 이슈",
    "url": "/posts/31cm-date/",
    "categories": "shop31cm",
    "tags": "",
    "date": "2024-10-08 00:00:00 +0800",
    





    
    "snippet": "문제사용자 회원가입시 createdDate, ModifiedDate 값이 제대로 들어가지 않는 이슈가 있었다.원인@CreatedDate와 @LastModifiedDate를 사용하였는데,위의 어노테이션을 사용할 때는@EnableJpaAuditing, @EntityListeners 이 두 어노테이션을 이용해 기능을 활성화 해야 하는데이 부분을 빠트렸다.해...",
    "content": "문제사용자 회원가입시 createdDate, ModifiedDate 값이 제대로 들어가지 않는 이슈가 있었다.원인@CreatedDate와 @LastModifiedDate를 사용하였는데,위의 어노테이션을 사용할 때는@EnableJpaAuditing, @EntityListeners 이 두 어노테이션을 이용해 기능을 활성화 해야 하는데이 부분을 빠트렸다.해결Application 실행 부분에 @EnableJpaAuditing을 추가하여 Auditing 기능을 활성화 한다.@EnableJpaAuditing@SpringBootApplicationpublic class Shop31cmApplication {\tpublic static void main(String[] args) {\t\tSpringApplication.run(Shop31cmApplication.class, args);\t}}그리고 Entity에@EntityListeners를 사용해 엔티티의 변화를 감지하여 생성 날짜, 수정 날짜를 자동으로 입력하도록 한다.@Getter@MappedSuperclass@EntityListeners(AuditingEntityListener.class)public abstract class BaseTimeEntity {    @CreatedDate    @Column(name = \"created_at\")    private LocalDateTime createdAt;    @LastModifiedDate    @Column(name = \"modified_at\")    private LocalDateTime modifiedAt;}추가로 이번 프로젝트에서는 날짜 관련한 BaseTimeEntity를 별도로 추상 클래스로 정의하였다.  이 클래스는 날짜 관련한 필드를 포함하며, @CreatedDate와 @LastModifiedDate 어노테이션을 사용하여 생성일과 수정일을 자동으로 관리한다.@MappedSuperclass 을 지정하여, 이 클래스를 상속 받는 엔티티들은createdAt과 modifiedAt 필드를 자동으로 포함하게 된다.따라서 날짜 관련 필드가 필요한 엔티티들은 이 BaseTimeEntity를 확장하여 사용할 수 있다.ExampleEntity.java@Entitypublic class ExampleEntity extends BaseTimeEntity {    // 다른 필드들...}이렇게 하면 ExampleEntity는 BaseTimeEntity의 createdAt과 modifiedAt 필드를 갖게 된다."
  },
  
  {
    "title": "티켓팅 시스템 - 좌석 선점",
    "url": "/posts/kboticket-%EC%A2%8C%EC%84%9D%EC%84%A0%EC%A0%90/",
    "categories": "kboticket",
    "tags": "",
    "date": "2024-10-07 00:00:00 +0800",
    





    
    "snippet": "기존의 이커머스 시스템은 결제 요청 직전에 재고 확인 후 락을 걸고 결제를 진행하다고 알고 있다.최대한 락을 짧게 잡는다.(아닌 경우 알려주세묩..!)하자만 티켓 예매의 경우 좌석을 잡고 있는 시간이 존재한다.7분 가량 좌석을 잡고 있을 수 있으며, 그 시간 이내에 결제를 완료해야 한다.두 시스템의 차이는 핵심 비즈니스 로직과 트랜잭션 처리에 대한 우...",
    "content": "기존의 이커머스 시스템은 결제 요청 직전에 재고 확인 후 락을 걸고 결제를 진행하다고 알고 있다.최대한 락을 짧게 잡는다.(아닌 경우 알려주세묩..!)하자만 티켓 예매의 경우 좌석을 잡고 있는 시간이 존재한다.7분 가량 좌석을 잡고 있을 수 있으며, 그 시간 이내에 결제를 완료해야 한다.두 시스템의 차이는 핵심 비즈니스 로직과 트랜잭션 처리에 대한 우선순위가 달라서 라고 생각한다.티켓팅 시스템과 이커머스 시스템티켓팅 시스템좌석은 고유한 자원으로, 하나의 좌석에 대해 한 명의 유저만 선택할 수 있어야 한다.만약 하나의 자원에 대해 여러 사람이 동시에 선택이 가능하게 되면 중복 예매가 되거나 계속되는 결제 실패로 유저의 불편함이 증가할 것이다.따라서 좌석은 한 번 선점되면 다른 사용자가 선택할 수 없도록 막아야 하기 때문에 긴 락이 필요하다.선점을 함으로써 사용자 간의 경쟁을 방지하고, 선택된 좌석이 다른 사용자에게 노출되지 않도록 해야 한다.이커머스 시스템이커머스 시스템의 경우, 다수의 사용자가 동일한 상품을 구매할 수 있다.이커머스 시스템에서는 재고 수량의 관리가 중요하다.  따라서, 결제 직전 재고 수량 확인 후 결제를 진행하고, 결제가 성공적으로 마칠 경우 재고를 하나 차감하는 방식이다.따라서 재고가 있는 경우 락을 걸여 결제를 진행한다.티켓 시스템과 같이 상품에 대해 락을 걸고 결제를 진행하는 과정으로 진행한다면, 다수의 사용자의 구매에 대한 대기시간이 길어질 것이고, 만족도 저하로 이어질 것이다.따라서 결제 직전에 재고 확인 후 락을 짧게 걸어 병목 현상을 줄일 수 있다.락을 짧게 걸어 여러 사용자가 동시에 구매를 진행하더라도 빠른 처리 속도를 유지하는 것이 시스템의 핵심이다.티켓팅은 하나의 좌석을 선점하는 것이 중요하고, 이커머스는 재고 수량 관리가 중요하다.두 시스템의 목적이 달라서 로직에 차이가 있는 것 같다.구현Redisson다수의 사용자가 동시에 동일한 좌석을 선택하려는 상황에서 데이터 일관성과 경쟁 상태를 방지해야 한다.여러 서버나 클라이언트가 동시에 좌석에 접근하는 것을 방지하기 위해 분산락을 사용하영ㅆ다.이를 통해 중복 선택이 되지않도록 보장한다.Redis는 메모리 기반 데이터 저장소로 데이터에 접근 속도가 빠르다. 또한 분산락과 TTL 기능을 활용해 기간 설정 충돌을 관리할 수 잇따.Redis의 클라이언트 중 Redisson을 사용하였다.lettuce는 사용자가 직접 스핀락을 구현해야 하며, 락 점유 시도를 실패한 경우 계속해서 락 점유를 시도하게 된다.이로 인해 레디스에 부하를 줄 수 있다.또한, 만료시간을 제공하지 않기 때문에 락을 점유한 프로세스가 비정상적으로 종료되면 락이 해제되지 않아 문제를 일으킬 수 있다.Redisson은 TTL을 설정할 수 있어 지정된 시간 동안만 락을 점유하도록 할 수 있다.이 기능을 통해 락을 점유한 후 장애가 발생해도 일정 시간 후 자동으로 해제되어 다른 프로세스가 락을 점유할 수 있다.이러한 이유로 Redisson을 사용하였다.좌석 선점 로직  유저가 기존에 선점한 좌석이 있는지 확인한다.  선택한 좌석의 수가 1개 이상 4개 이하인지 확인한다.  선택한 좌석을 돌며 락을 건다.          다른 유저가 이미 선점한(락이 걸린) 좌석이라면 모든 락이 실패한다.      모든 좌석을 선점해야 성공한다.      어노테이션 기반의 AOP를 이용해 분산락을 관리하는 로직을 별도의 컴포넌트를 구성했다.@DistributedLock 어노테이션메소드에 분산락을 걸기위한 설정을 제공하는 @DistributedLock 어노테이션으로, 메소드에 적용가능하며, 실행 시점까지 유지가 가능하다.트랜잭션 내에서 메소드를 실행하기 위해 AopForTransaction 클래스특정 메소드가 실행될 때, 새로운 트랜잭션을 시작하고, 해당 트랜잭션 내에서 메소드를 실행한 후, 결과를 반환한다.ProceedingJoinPoint는 메소드 호출의 세부 정보를 제공하고, proceed() 메소드를 호출하여 실제 타겟 메소드를 실행한다.Lock의 이름을 Spring Expression Language로 파싱하기 위한 클래스메인 로직을 위한 AOPProceedingJoinPoint은 현재 실행 중인 메서드 호출에 대한 정보를 제공하, 그 메서드를 실행할 수 있는 인터페이스이다.aopForTransaction.proceed(joinPoint) : DistributedLock 어노테이션이 선언된 메서드를 별도의 트랜잭션으로 실행한다.문제위와 같이 구성 후 테스트를 진행하는데 AOP가 동작하지 않았다.이유를 찾아보니 스프링의 AOP는 프록시 객체를 통해 동작을 하는데, 같은 클래스 내에서 메서드를 호출 하는 경우 프록시가 적용되지 않아서 발생하는 문제였다.이 문제를 해결하기 위해 내부 호출을 다른 클래스에(ReserveInternalService)서 호출하도록 분리하였다.기존 [내부 호출]ReservationService.selectSeats() 메서드 -&gt;  ReservationService.lockSeat() 메서드 호출.변경 후 [클래스 분리]ReservationService.selectSeat() 메서드 ReserveInternalService.lockSeat() 메서드 호출.ReservationServiceReserveInternalService테스트 코드참고 : https://helloworld.kurly.com/blog/distributed-redisson-lock/"
  },
  
  {
    "title": "GC(Garbage Collection)란?",
    "url": "/posts/java-gc/",
    "categories": "Java",
    "tags": "",
    "date": "2024-10-05 00:00:00 +0800",
    





    
    "snippet": "자바에서 자동으로 메모리를 관리하는 기능이다.사용하지 않는 객체들을 자동으로 메모리에서 제거하여 메모리 누수를 방지한다.개발자가 메모리를 직접 관리할 필요가 없으며, 메모리 누수와 이중 해제 등 메모리 관련 버그를 줄여 프로그램의 안정성을 높이며, 메모리 공간을 효율적으로 사용할 수 있도록 한다.GC의 대상도달성(Reachability)을 통해 가비지...",
    "content": "자바에서 자동으로 메모리를 관리하는 기능이다.사용하지 않는 객체들을 자동으로 메모리에서 제거하여 메모리 누수를 방지한다.개발자가 메모리를 직접 관리할 필요가 없으며, 메모리 누수와 이중 해제 등 메모리 관련 버그를 줄여 프로그램의 안정성을 높이며, 메모리 공간을 효율적으로 사용할 수 있도록 한다.GC의 대상도달성(Reachability)을 통해 가비지의 대상이 되는지 판단한다.  Reachable : 객체가 참조되고 있는 상태  Unreachable : 객체가 참조되고 있지 않은 상태로 GC의 대상이다.객체들은 실제로 Heap 영역에 생성되고, 스태틱(메서드) 영역과 스택 영역에서는 생성된 객체의 주소를 참조하는 형식이다.Heap 영역 객체의 참조 변수가 삭제되는 현상이 발생하면 Unreachable가 발생한다.이러한 객체를 가비지 컬렉션이 제거한다.  루트 집합체(지역변수, 활성스레드, 정적변수 등)에서 시작하여 참조를 따라갔을 때 도달할 수 없는 객  순환 참조가 있더라도 외부에서 이들을 참조하는 루트가 없는 경우 가비지 컬렉션이 대상이 된디.  메서드가 종료되거나, 해당 메서드에서 선언된 지역변수가 더 이상 사용되지 않을 때, 해당 지역 변수에 참조된 객체는가비지이다.  객체가 참조되던 변수가 null로 설정되는 경우  익명 객체나 임시 객체의 경우 사용 범위가 제한 적이므로, 사용 후 가비지가 된다.  종료된 스레드의 객체GC 동작 방식자바는 JVM을 통해 실행되며, JVM에는 힙이라는 메모리 공간이 있다.힙은 다음과 같이 나뉜다.      Young Generation (새로운 객체가 생성되는 공간)    Old Generation (오랫동안 참조되고 있는 객체들이 이동되는 공간)    Permanent Generation (클래스 메타데이터, 컴파일된 코드를 저장하는 공간으로 자바8이후 메타 스페이스로 대체된다.)    객체 생성: 새로운 객체가 Young Generation의 Eden 영역에 생성된다.  Minor GC 실행: Eden 영역이 꽉 차면 Minor GC가 실행되어, 사용 중인 객체는 Survivor 영역으로 이동되고, 나머지 객체는 삭제된다.  Old Generation 이동: 여러 번의 Minor GC를 거친 객체는 Old Generation으로 이동한다.  Major GC 실행:          Old Generation이 가득 차거나, 메모리가 부족할 때, Major GC가 실행된다.      Old Generation 내에서 사용되지 않는 객체를 제거한다.        Full GC 실행: 전체 메모리가 부족하거나 Old Generation과 Young Generation 모두를 대상으로 메모리를 정리할 때 Full GC가 발생한다.Garbage Collection 종류  Minor GC          동작 시점 : Young Generation이 가득 찾을 때 동작한다.      Eden 영역과 Suvivor 영역의 객체를 검사하여 더 이상 사용되지 않는 객체를 제거한다.      Eden에서 살아남은 객체들은 Survivor 영역으로 이동하고, 일정 횟수 이상 살아남은 객체들은 Old Generation으로 이동한다.      비교적 빠른 처리가 가능하며, 자주 발생한다.        Major GC (Old Generation GC, Full GC)          동작 시점 : Old Generation이 가득 찬 경우, Permanent/metaspace 영역에서 메모리 부족이 발생할 때 동작한다.      Old Generation에서 참조되지 않는 객체를 제거한다.      Minor GC 보다 시간이 오래 소요되며, 전체 애플리케이션을 잠시 멈추는 Stop-the-world 상태가 발생한다.      Full GC: Old Generation과 Young Generation 모두를 청소하는 GC로, Minor GC보다 비용이 크고 성능에 영향을 많이 미친다.      Garbage Collection 언제??  Eden 영역이 가득 차게 되면 Minor GC가 발생한다.  오랫동안 참조되는 객체들이 Old Generatiton으로 이동하고, Old Generation이 가득 참면 Major GC 또는 Full GC가 발생한다.  메모리 부족으로 더 이상 객체를 할당할 수 없을 때 GC가 발생한다.  명시적으로 System.gc()를 호출하여 GC를 실행할 수 있지만, 즉시 실행되지 않으며, JVM은 이를 무시할 수 있다.왜 필요할까?  개발자가 메모리 할당 및 해제를 수동으로 관리하지 않아도 되어, 메모리 누수를 방지하고, 안정적인 메모리 사용이 가능해진다.  불필요한 객체를 자동으로 정리함으로써, 사용 가능한 메모리 공간을 효율적으로 관리할 수 있다.  메모리 누수, 잘못된 참조로 인해 프로그램이 불안정해지는 것을 방지할 수 있다.알고리즘  Serial GC : 단일 스레드로 가비지 컬렉션을 수행하는 가장 기본적인 알고리즘으로, 작은 애플리케이션에 적합하다.  Parallel GC : 여러 스레드를 사용해 가비지 컬렉션을 수행하여 성능을 높이는 방식이다.  CMS : Old Generation에서 GC를 백그라운드에서 수행하는 방식이다.  G1 GC : 힙 메모리를 여러 구역으로 나누고, 가장 가비지가 많은 영역을 우선적으로 수집하는 방식으로, 큰 애플리케이션에 효율적이다.단점  Stop-the-world : 가비지 컬렉션 중 애플리케이션 실행을 멈추는 현상으로, Major CG에서 큰 영향을 미친다.성능 최적화가 필요한 실시간 시스템에서 문제가 될 수 있다.  가비지 컬렉션 자체도 메모리 및 CPU 리소스를 소모하는 작업으로, 성능저하가 발생할 수 있다.  메모리가 언제 해제되는지 예측이 힘들다.자동으로 메모리 관리가 이루어지기 때문에 개발자는 비즈니스 로직에 집중할 수 있으며,GC가 자주 실행되기 때문에 메모리 누수나 해제 오류에 대해 걱정할 필요가 줄어든다.하지만 GC가 실행될 때, 일시적으로 애플리케이션 성능이 저하될 수 있으며, 특히, Full GC는 애플리케이션을 중단시키는 경우가 많아 응답성이 떨어질 수 있다.그리고 실행 시점을 예측할 수 없어, 특정 작업이 필요할 때 GC가 발생하면 성능에 영향을 미칠 수 있다.GC가 비효율적으로 작동하는 경우, 필요한 메모리보다 더 많은 메모리를 소비한다.GC 튜닝 목표  성능 최적화 : GC의 성능을 조정하여 애플리케이션의 응답을 향상시키고, 불필요한 지연을 최소화한다.  메모리 사용량 관리 : 메모리 소비를 최적화하여 애플리케이션이 사용 가능한 메모리 자원을 효율적으로 사용할 수 있도록 한다.  리소스 균형 : CPU, 메모리 등의 시스템 자원을 효율적으로 관리하여 전반적인 시스템 성능을 최적화한다.G1GCG1GC는 자바7에서 도입된 GC 알고리즘으로, Java9의 기본 알고리즘이다.  low Latency, High Throughput(처리량)을 목표, 대용량 힙을 효과적으로 관리하도록 설계되었다.  리전 기반의 메모리 관리 :          힙을 여러 개의 작은 리전으로 나누어 관리한다.      각 리전은 서로 독립적이기 때문에 메모리를 동적으로 할당하고 해제할 수 있어, 더 유연한 메모리 관리 기능이 가능하다.        Pause Prediction Model          예측 가능한 응답 시간을 목표로 GC Pause Time를 제어할 수 있다.      개발자가 지정한 시간 내에 가비지 컬렉션이 완료되도록 최적화된 방식으로 동작한다.        Garbage First          G1GC는 가바지 객체가 많은 리전을 먼저 수집한다.      따라섯, 메모리 회수 효율을 높이고 애플리케이션 성능을 향상시킨다.        Concurrnet Marking          G1 GC는 객체를 Mark-and-sweep 방식으로 수집한다.      동시성 수집을 통해 애플리케이션이 실행 중일 때도 백그라운드에서 가비지를 수집한다.      이를 통해 Stop-the-world 시간이 줄어든다.      Mark-and-Sweep  1. Mark  이 단계에서는 루트 객체에서 시작하여 모든 참조 가능한 객체를 마크한다.루트 객체는 애플리케이션에서 직접 참조되고 잇는 객체들로, 보통 다음과 같은 것이 포함된다.      스택에 있는 로컬 변수    전역 변수    정적 변수    DFS와 비슷한 방식으로, 루트 객체에서 시작하여 연결된 모든 객체를 탐색한다.  2. Sweep  마크되지 않은 객체를 찾아 회수한다.즉, 참조되지 않는 객체가 메모리에서 제거되어 가비지가 된다.이 과정에서 메모리가 정리되고, 가비지 객체가 차지하고 있던 메모리를 회수하여 재사용할 수 있게 된다.  3. Compact  Sweep 후 분산된 객체들을 Heap의 시작 주소로 모아 메모리가 할당된 부분과 그렇지 않은 부분으로 압축한다.리전 기반 구조의 장점  일관된 크기와 수명 관리          리전은 일정한 크기로 할당되며, 비슷한 수명과 용도를 갖는 객체들이 같은 리전에 관리된다.      따라서, 메모리 할당 및 해제가 예측이 가능하여, 특정 객체에 대한 메모리 패턴을 개발자가 쉽게 이해하고 관리할 수 있다.        간단한 메모리 할당과 해제          객체를 리전에 할당할 때 메모리 블록을 검색할 필요가 없기 때문에, 메모리 할당이 더 간단하고 빠르다.      특정 리전이 더 이상 필요하지 않은 경우, 전체 리전을 한 번에 해제할 수 있다.        동적 메모리 조정          메모리 사용 패턴에 따라 동적으로 리전 할당 및 해제할 수 있다.      특정 영역에서 메모리를 조정할 필요가 없으며, GC가 자동으로 이를 조정한다.        가비지 객체 수집 우선          가비기 객체가 많은 리전을 우선적으로 수집하여 불필요한 메모리 회수를 줄인다.      이로 인해 개발자는 소스 코드에 메모리 최적화 로직을 추가할 필요가 없다.        GC 간격 예측          G1 GC와 같은 리전 기반 GC는 GC간격을 예측할 수 있어, 성능 예측이 가능하다.      예측 가능한 GC 간격은 성능 튜닝을 용이하게 한다.      결과적으로, G1GC는 메모리 관리의 복잡성을 줄이고 성능을 안정적으로 유지하는 데 중점을 둔다. 이로써, 개발자는 GC의 세부 조정보다는 비즈니스 로직에 집중할 수 있다."
  },
  
  {
    "title": "JIT 컴파일러?",
    "url": "/posts/java-jit-compiler/",
    "categories": "Java",
    "tags": "",
    "date": "2024-10-01 00:00:00 +0800",
    





    
    "snippet": "  자바 파일(.java)을 컴파일러를 통해 클래스 파일(.class/바이트코드)로 만든다.  이후 자바 바이트 코드를 JVM이 읽고 실행한다.  자바 바이트 코드  JVM이 이해할 수 있는 언어로 변화나된 자바 소스 코드자바 컴파일러에 의해 변환되는 코드의 명령어 크기가 1 바이트여서 자바 바이트 코드라 한다.자바 바이트 코드는 자바 가상 머신만 설...",
    "content": "  자바 파일(.java)을 컴파일러를 통해 클래스 파일(.class/바이트코드)로 만든다.  이후 자바 바이트 코드를 JVM이 읽고 실행한다.  자바 바이트 코드  JVM이 이해할 수 있는 언어로 변화나된 자바 소스 코드자바 컴파일러에 의해 변환되는 코드의 명령어 크기가 1 바이트여서 자바 바이트 코드라 한다.자바 바이트 코드는 자바 가상 머신만 설치되어 있으면, 어떤 운영체제에서도 실행될 수 있다.컴파일러와 인터프리터컴파일러와 인터프리터 모두 고수준 언어를 기계어로 변환시킨다.컴파일러는 소스코드 전체를 한 번에 번역하여 목적 파일로 만들어 메모리에 적재하는 방식이다.인터프리터는 소스코드를 한 행씩 중간 코드로 번역 후 실행한다.컴파일러  컴파일이 완료된 실행 파일은 컴퓨터에서 빠르게 실행할 수 있어 효율적이다.  기계어로 번역되기 때문에 프로그램 코드가 유출되지않는다.  컴파일 에러와 관련된 에러를 초기에 발견할 수 있다.  코드 수정시 다시 컴파일 해야 한다.  컴파일 시간이 비교적 느리며, 수정이 빈번한 경우 문제가 발생할 수 있다.인터프리터  메모리를 사용하지 않으며, 시스템 간 이식성이 좋다.  전체 코드를 다시 컴파일할 필요가 없기 때문에 코드 수정에 용이한다.  매번 번역 과정을 거쳐야 하기 때문에 실행 속도가 느려 컴파일러에 비해 느리다.  중간 코드로 해석되기 때문에 프로그램의 코드가 유출될 수 있다.자바 코드를 실행하는 과정      자바 파일을 자바 컴파일러를 통해 바이트코드 파일로 컴파일 한다. 자바 컴파일러는 자바 소스코드를 JVM을 위한 기계어로 번역한다.        JVM의 실행 엔진 내에 있는 자바 인터프리터를 통해 바이트 코드를 특정 환경의 기계어로 번역하고 실행한다.  자바는 코드를 실행하기 위해서는 바이트코드로 컴파일하는 과정과, 바이트코드를 인터프리하는 과정을 거쳐야 한다.즉, 컴파일 과정만 필요한 다른 프로그래밍 언어보다 느리다.거기에 더하여 인터프리터는 컴파일러보다 속도가 느리기 때문에 성능이 떨어진다. 이러한 문제를 개선하기 위해 나온 것이 JIT 컴파일러이다.JIT 컴파일은 코드가 실행되는 과정에 실시간으로 일어나며(그래서 Just-In-Time이다), 전체 코드의 필요한 부분만 변환한다. 기계어로 변환된 코드는 캐시에 저장되기 때문에 재사용 시 컴파일을 다시 할 필요가 없다.Just-In-Time 컴파일러Java와 같은 JVM 기반 언어에서 사용되는 컴파일러로, 프로그램 실행 중 바이트코드를 기계어로 변환하는 컴파일 기법기계어로 변환된 코드를 캐시에 저장한 후 재사용시 컴파일을 다시 하지 않아도 되기 때문에 성능이 좋다.하지만 모든 코드들을 캐시하는건 아니다. JVM은 내부에서 자주 수행되는 코드들을 선별하여 캐시 공간에 넣어 둔다.어떤 기준으로 선별할까?1. 프로파일링JVM은 프로그램 실행 중 메섯드의 호출 빈도, 실행 시간을 모니터링한다.   이 데이터를 기반으로 JVM은 어떤 메서드가 핫스팟 메서드인지 판단한다.2. 임계값 설정JVM은 특정 임계값을 설정하고, 메서드 호출 빈도가 임계값을 넘는 경우 해당 코드를 JIT 컴파일 대상으로 선정한다.   임계값은 JVM에 따라 다르다.3. JIT 컴파일프로파일링 데이터와 임계값을 바탕으로, JVM은 핫스팟 메서드를 JIT 컴파일 하여 네이티브 코드로 변환한다.   JIT 컴파일러는 이 메서드를 최적화하여 다음 실행 시 성능이 향상되도록 합니다.4. 캐싱JIT 컴파일러는 컴파일된 메서드를 캐시에 저장한다.   그 후 동일한 메서드가 다음에 호출될 때 빠르게 접근할 수 있다.    캐시는 메서드의 네이티브 코드를 저장하고, 필요할 때 재사용하여 성능을 향상시킨다.5. 스케줄링JIT 컴파일은 CPU 자원과 메모리 사용량을 고려하여 실행된다.메서드 호출빈도가 높은 경우 JIT 컴파일 우선순위를 높여, 많이 호출되는 메서드일수록 삘리 최적화하려고 한다.   하지만 CPU 사용량이 높다면, JIT 컴파일을 늦추거나 제한할 수 있습니다.   CPU 부하가 낮은 시점에 컴파일 작업이 수행될 수 있도록 하며, 애플리케이션의 전체 성능에 영향을 미치지 않도록 한다.6. 정책 조정JVM은 다양한 정책을 통해 핫스팟 메서드를 최적화할 수 있다.   특정 메서드의 호출 빈도가 급증하면 JVM은 해당 메서드에 대해 추가 최적화를 적용할 수 있다.프로파일링과 임계값을 기반으로 핫스팟을 선정하여 캐싱한다.호출 빈도와 실행 시간을 모니터링하여, 자주 호출되거나 성능이 중요한 메서드에 대해 JIT 컴파일과 캐싱을 수행하는 방식이다.이를 통해 성능을 최적화하고, 실행 속도를 향상 시킬 수 있다.C1, C2실제로 JVM의 JIT 컴파일러 내부에는 2가지 컴파일러인 C1컴파일러와 C2컴파일러가 있다.C1은 level1~3, C2는 level4를 담당한다.C1 - Client Compiler빠른 시작 시간을 목표로 설계된 Client 모드에서 동작하는 JIT 컴파일러이다.간단한 최적화를 수행하며, 복잡한 최적화는 적용하지 않기 때문에 코드 컴파일에 시간이 적게 걸린다.서버 어플리케이션보다는 데스크탑 어플리케이션,GUI 어플리케이션과 같은 짧은 실행 시간과 빠른 응답속도가 중요한 프로그램에 적합하다.  프로그램이 실행될 때 빠르게 바이트코드를 기계어로 변환하여 바로 실행할 수 있다.  인라인, dead code elimination, 루프 최적화등 기본 최적화 작업만 수행한다.  최적화를 간단히 하기 때문에 프로그램이 빠르게 시작할 수 있다.C2 - Server Compiler서버 모드에섯 동작하며, 고성능을 목표로 복잡한 최적화를 수행하는 JIT 컴파일러이다.시작 시간은 느리지만, 장기 실행 프로그램에 더 적합한 컴파일러로, 성능이 중요한 서버 환경에서 주로 사용한다.  복잡한 루프 전환, 인라인 확정, 탈출 분석 등 고급 최적화를 수행하여 성능을 극대화한다.  고급 최적화를 적용하기 때문에 컴파일 시간이 상대적으로 길며, 프로그램 시작 시점에서는 더 많은 시간이 소요된다.  최적화된 코드로 인해 CPU, 메모리 사용을 줄인다.Tiered Compilation (계층적 컴파일)C1, C2 컴파일러의 장점을 결합한 JVM 컴파일 전략이다.C1 컴파일러로 빠르게 바이트 코드를 기계어로 변환하여 실행하고, 프로그램이 더 오래 실행되면,C2 컴파일러로 고급 최적화를 수행한다.특징1. 성능 최적화바이트 코드를 실행하는 대신, 자주 실행되는 코드를 JIT 컴파일러가 직접 기계어로 변환하면 더 빠르게 실행된다.이를 통해 실행 성능이 향상된다.2. 동적 최적화JIT 컴파일러는 실행 중에 코드의 사용 패턴을 분석하여 최적회된 코드를 생성할 수 있다.3. 메모리 효율성필요할 때만 바이트 코드를 컴파일하기 때문에, 메모리 사용을 최적화할 수 있다.4. 호환성 유지바이트 코드를 처음부터 기계어로 변환하는 AOT(Ahead-of-Time) 컴파일러와 달리, JIT는바이트 코드 상태로 유지하다가 실행 시점에 필요한 부분을 변환한다.  이를 통해 다양한 플랫폼에서 동일한 바이트 코드를 실행할 수 있는 JVM의 이식성을 유지하면서성능을 개선할 수 있다.  AOT 컴파일  프로그램 코드를 실행하기 전 미리 기계어로 변환하는 방식실행 시점에 추가적인 컴파일 작업이 필요하지 않아 실행 속도가 빠르다.AOT로 생성된 기계어는 특정 플랫폼에서만 실행이 가능하다.플랫폼에 종속적이며, 다른 환경에서 실행하려면 별도로 AOT 컴파일 해야 한다.JIT의 작동 방식  프로그램이 실행되면 JVM은 바이트코드를 인터프리터를 통해 한 줄씩 해석하며 실행한다.  실행 중, 특정 메서드나 코드 블록이 자주 호출되면 JIT 컴파일러가 해당 부분을 감지한다.  그 코드를 기계어로 변환하고 캐싱하여, 이후부터는 변환된 기계어를 사용해 더 빠르 실행한다."
  },
  
  {
    "title": "쿠키, 세션 그리고 토큰 인증",
    "url": "/posts/network-authentication-method/",
    "categories": "Network",
    "tags": "",
    "date": "2024-09-28 00:00:00 +0800",
    





    
    "snippet": "HTTP는 상태를 Stateless 의 비연결 프로토콜이다. 따라서, 서버는 이전의 요청이 정보에 대해서 알 수 없다.HTTP 비연결성, 보안 문제를 해결하기 위한 방법에는 쿠키, 세션, 토큰 방식이 있다.쿠키 인증쿠키는 서버가 사용자의 웹 브라우저에 전송하는 작은 데이터 조각이다.key=value 형식의 문자열 데이터 묶음으로,브라우저는 이 문자열 ...",
    "content": "HTTP는 상태를 Stateless 의 비연결 프로토콜이다. 따라서, 서버는 이전의 요청이 정보에 대해서 알 수 없다.HTTP 비연결성, 보안 문제를 해결하기 위한 방법에는 쿠키, 세션, 토큰 방식이 있다.쿠키 인증쿠키는 서버가 사용자의 웹 브라우저에 전송하는 작은 데이터 조각이다.key=value 형식의 문자열 데이터 묶음으로,브라우저는 이 문자열 데이터 조각을 저장해두었다가, 동일한 서버에서 재 요청시 쿠키 데이터를 전송한다.서버와 클라이언트 간의 연결 유지를 구현하기 위해 서로를 인식할 수 있는 식별데이터이다.  브라우저에 정보를 저장하여, 사용자가 웹 사이트에 다시 방문할때 로그인 정보나, 사용자의 정보를 유지할 수 있다.  쿠키는 서버에서 생성하고 클라이언트에 저장된다.  이후 요청마다 자동으로 서버로 전송된다.인증 방식단점  이 방식은 요청시 쿠키의 값을 그대로 보내기 때문에 유출 또는 조작될 위험이 크다.  용량에 제한이 있어 많은 정보를 담을 수 없다.  브라우저마다 쿠키에 대한 지원 형태가 달라 브라우저가 공유가 불가능하다.  쿠키의 사이즈가 커질수로 네트워크 부하가 심해진다.세션쿠키 방식은 상태를 유지할 수는 있지만 보안의 위험이 있다.이를 해결하기 위해 중요한 정보를 서버측에서 관리하는 방식이다.  세선은 서버에 데이터를 저장한다.  사용자가 로그인을 하면, 서버는 그 사용자에 대한 세션 ID를 생성한다.  그리고 그 세션ID을 클라이언트에 보낸다.  이후 요청시, 클라이언트는 세션 ID를 서버에 보내고, 서버는 ID를 바탕으로 사용자의 상태를 얻는다.  민감한 데이터가 서버에 저장되며, 클라이언트 측에서 접근할 수 없기 때문에, 보안에 좋다.세션은 쿠키를 기반으로 동작한다.인증방식단점  탈취자가 세션ID 자체를 탈취하여 클라이언트로 위장할 수 있다.  사용자가 많아지는 경우 서버에 부하가 심해진다.토큰 인증클라이언트가 서버에 접속하면 서버에서 해당 클라이언트에 인증되었다는 의미로 ‘토큰’을 부여한다.토큰은 유일하며, 토큰을 발급받은 클라이언트는 다시 서버에 요청을 보낼 때 요청 헤더에 토큰을 심어서 보낸다.서버에서는 클라이언트로부터 받은 토큰을 서버에서 제공한 토큰과의 일치 여부를 확인하여 처리한다.토큰은 서버가 아닌 클라이언트에 저장되기 때문에 서버에 부담을 줄 수 있다.  서버가 세션을 유지할 필요 없이, 클라이언트가 요청 시 토큰을 사용해 인증할 수 있다.  JWT 같은 토큰은 서버가 아닌 클라이언트 측에서 발급 및 저장되며, 각 요청 시 토큰을 함께 보내 인증한다.  토큰에는 필요한 정보(사용자 정보, 만료 시간 등)가 포함되어 있어,서버가 매번 데이터베이스를 조회할 필요 없이 사용자 신원을 확인할 수 있다.  API 및 분산 시스템에 적합하며, 서버에 부하가 적다.인증방식단점  토큰 자체의 데이터 길이가 길어져, 인증 요청이 많아질수록 네트워크 부하가 심해질 수 있다.  Payload는 조회가 가능하기 때문에 유저의 중요한 정보를 담아서는 안된다.  탈취시 대처 방법이 없다."
  },
  
  {
    "title": "티켓팅 시스템 - 개요",
    "url": "/posts/kboticket-introduce/",
    "categories": "kboticket",
    "tags": "",
    "date": "2024-09-27 00:00:00 +0800",
    





    
    "snippet": "올해 유독 KBO의 열기가 뜨거웠다.나 역시도 야구를 좋아해서 꼭꼭 챙겨보았다.직관하러 갈 때 주로 티켓링크, 인터파크를 이용하여서 티켓 예매를 했는데 수천 번대의 대기 순서를 통해 야구의 열기를 한번 더 실감할 수 있었다.어떤 과정을 거쳐서 이렇게 많은 사람들이 대기하고 들어가서 티켓을 구매할 수 있을까.관심이 생겨 대용량 트래픽이 몰리는 티켓 예매...",
    "content": "올해 유독 KBO의 열기가 뜨거웠다.나 역시도 야구를 좋아해서 꼭꼭 챙겨보았다.직관하러 갈 때 주로 티켓링크, 인터파크를 이용하여서 티켓 예매를 했는데 수천 번대의 대기 순서를 통해 야구의 열기를 한번 더 실감할 수 있었다.어떤 과정을 거쳐서 이렇게 많은 사람들이 대기하고 들어가서 티켓을 구매할 수 있을까.관심이 생겨 대용량 트래픽이 몰리는 티켓 예매 시스템을 프로젝트 주제로 선정하였다.구상티켓 오픈 시간(경기 7일 전 11시)에 대량의 트래픽이 몰리는 상황을 가정하였다.예매 백엔드 플로우1. 회원가입/ 로그아웃  유저는 회원가입 및 로그인을 한다. (인증/인가)2. 경기 목록 조회  원하는 경기 목록을 조회할 수 있으며, 이전 목록은 조회할 수 없다.  오픈된 경기에 한해서 경기 상세(예매) 페이지로 진입 가능  오픈 전인 경우 진입 불가능  비회원 진입 가능3. 경기 상세(에매) 페이지 진입  인증된 유저만 이용 가능  경기 7일 전 오전 11시에 오픈 (스케줄러)  오픈과 동시에 사용자 접근 (대량의 트래픽이 몰리는 상황 가정)  대기열 구현4. 좌석 선점 (선점 시간 : 7분)  인증된 유저만 이용 가능  다른 유저가 이미 선점한 좌석인 경우: 선점 불가  선점한 유저가 없는 경우 : 선점5. 결제 (토스페이먼츠 이용)  선점 시간 이내에 결제 진행되어야 한다.  선점 시간 이내에 하지 못한 경우 선점된 좌석은 취소된다.6. 결제취소 (토스페이먼츠 이용)  선점 시간 이내에 결제 진행되어야 한다.  선점 시간 이내에 하지 못한 경우 선점된 좌석은 취소된다.7. 예매 상세 내역  인증된 유저만 이용 가능db 구조서버 구성"
  },
  
  {
    "title": "HTTP (Hyper Text Transfer Protocol)",
    "url": "/posts/network-http/",
    "categories": "Algorithm",
    "tags": "",
    "date": "2024-09-25 00:00:00 +0800",
    





    
    "snippet": "웹에서 클라이언트(브라우저)와 서버 간에 데이터를 주고받기 위한 프로토콜.인터넷을 통해 다양한 웹 리소스를 전송할 수 있다. 비연결형이며 상태를 유지하지 않고, 요청과 응답에 의해 통신이 이루어진다.특징  비연결성 : 클라이언트와 서버는 요청, 응답이 완료되면 연결을 끊는다. 각 요청은 독립적이면 이전 요청의 정보는 다음 요청에 전달되지 않는다.  S...",
    "content": "웹에서 클라이언트(브라우저)와 서버 간에 데이터를 주고받기 위한 프로토콜.인터넷을 통해 다양한 웹 리소스를 전송할 수 있다. 비연결형이며 상태를 유지하지 않고, 요청과 응답에 의해 통신이 이루어진다.특징  비연결성 : 클라이언트와 서버는 요청, 응답이 완료되면 연결을 끊는다. 각 요청은 독립적이면 이전 요청의 정보는 다음 요청에 전달되지 않는다.  Stateless : 서버는 요청 간 클라이언트의 상태를 저장하지 않는다. 따라서 클라이언트가 이전에 어떤 페이지를 접근했는지 알 수 없다. 이것을 보완하기 위해 쿠키, 세션 등을 사용하여 상태를 유지할 수 있다.  요청-응답 구조 : 클라이언트가 서버에 요청을 보내면 서버는 응답을 반환한다.요청과 응답은 헤더와 본문으로 구성된다.  텍스트 기반 : 사람이 읽을 수 있는 형식으로 데이터를 전송한다.요청과 응답 메시지는 텍스트로 작성되며, 클라이언트와 서버는 이를 파싱하고 해석한다.구조요청      요청 라인:HTTP 메소드, 요청 URL, HTTP 버전으로 구성된다.예: GET /index.html HTTP/1.1        헤더(Header):요청에 대한 부가 정보를 제공하며, 클라이언트와 서버가 어떤 형식으로 데이터를 주고받을지 정의한.예: Host: www.example.com, User-Agent: Mozilla/5.0        본문(Body):선택적이며, 주로 POST, PUT 요청에서 서버로 전송할 데이터를 포함합니다. 예를 들어, 사용자 폼 데이터가 본문에 포함될 수 있습니다.  응답      상태 라인HTTP 버전, 상태 코드, 상태 메시지로 구성됩니다.예: HTTP/1.1 200 OK        헤더(Header):응답에 대한 메타데이터를 포함합니다. 예를 들어, Content-Type: text/html은 서버가 HTML 데이터를 반환한다는 것을 의미합니다.        본문(Body):서버가 클라이언트에게 전송하는 실제 데이터(HTML 문서, 이미지 등)가 들어 있습니다.  HTTP 메서드클라이언트가 서버에 요청할 때 어떤 동작을 할지 정의한다.1. GET서버에서 리소스를 요청할 때 사용한다. 주로 데이터를 조회한다.2. POST서버에 데이터를 전송할 때 사용한다. 폼 데이터를 전송하거나 파일을 업로드할 때 사용한다.3. PUT서버에 리소스를 생성하거나 수정할 때 사용한다. 전달된 데이터를 통해 기존 데이터를 대체한다.4. DELETE서버에서 리소스를 삭제할 때 사용한다.5. PATCH리소스의 일부를 수정할 때 사용한다.PUT과 다르게 전체 리소스를 교체하지 않고, 일부만 업데이트한다.HTTP Status Code1xx (정보) : 요청이 수신되었으며 처리가 진행 중임을 표시2xx (성공)  200 OK: 서버가 요청을 제대로 처리함  201 Created: 요청이 성공했으며, 새로운 리소스가 생성됨  202 Accepted: 요청이 수락되었지만, 처리가 완료되지 않음  204 No Content: 요청이 처리되었지만, 반환할 콘텐츠가 없음3xx (리다이렉션)  301 Moved Permanently: 요청한 리소스가 영구적으로 다른 URI로 이동했음. 클라이언트는 이후부터 새로운 URI를 사용해야 함.  302 Found: 요청한 리소스가 임시로 다른 URI에 위치함, 클라이언트는 이후에 원래 URI를 사용할 수 있음.4xx (클라이언트 오류)  400 Bad Request: 잘못된 요청으로 서버가 요청을 처리할 수 없음  401 Unauthorized: 인증을 필요로 하는 요청, 인증 실패  403 Forbidden:  서버가 요청을 이해했으나, 권한이 없기 때문에 요청을 거부함  404 Not Found: 요청한 리소스를 찾을 수 없음  405 Method Not Allowed: 클라이언트가 요청한 메소드는 허용되지 않음  409 Conflict: 요청이 서버의 상태와 충돌할 때 발생.  429 Too Many Requests: 클라이언트가 너무 많은 요청을 짧은 시간 내에 보냈을 때 발생.5xx (서버 오류)  500 Internal Server Error: 서버에서 요청을 처리하는 도중 예기치 못한 오류가 발생함  502 Bad Gateway: 서버가 게이트웨이 또는 프록시 역할을 하는 경우, 상위 서버로부터 잘못된 응답을 받은 경우  504 Gateway Timeout: 서버가 상위 서버로부터 응답을 기다리는 중 시간 초과가 발생했을 때HTTPSHTTP는 기본적으로 데이터를 암호화하지 않은 평문으로 전송한다.따라서 중간에 누군가 네트워크 트래픽을 가로챌 경우 민감한 정보(로그인 정보, 개인정보 등)가 유출될 수 있다.이를 방지하기 위해 HTTPS(HTTP Secure)가 도입되었다. HTTPS는 SSL/TLS 프로토콜을 통해 데이터를 암호화하여 전송한다.HTTPS는 인증서를 이용해서, 접속 사이트를 신뢰할 수 있는지 평가하며, 이를 통해 데이터의 기밀성과 무결성을 보장할 수 있다."
  },
  
  {
    "title": "버블 정렬 Bubble Sort 알고리즘",
    "url": "/posts/algorithm-bubble-sort/",
    "categories": "Algorithm",
    "tags": "",
    "date": "2024-09-25 00:00:00 +0800",
    





    
    "snippet": "정렬 알고리즘 중 하나로,인접한 두 요소를 비교하고 필요에 따라 자리를 교환하면서 배열을 정렬하는 방식이다.동작 방식  배열의 첫 번째 요소와 두 번째 요소를 비교한다.  첫 번째 요소가 더 크면 두 요소와 자리를 바꾼다.  그런 다음 두 번째 요소와 세 번째 요소를 비교한다.  이 과정을 배열 끝까지 반복한다. 한 번의 반복이 끝나면 가장 큰 요소가...",
    "content": "정렬 알고리즘 중 하나로,인접한 두 요소를 비교하고 필요에 따라 자리를 교환하면서 배열을 정렬하는 방식이다.동작 방식  배열의 첫 번째 요소와 두 번째 요소를 비교한다.  첫 번째 요소가 더 크면 두 요소와 자리를 바꾼다.  그런 다음 두 번째 요소와 세 번째 요소를 비교한다.  이 과정을 배열 끝까지 반복한다. 한 번의 반복이 끝나면 가장 큰 요소가 배열의 마지막 자리에 위치한다.  두 번째 반복에서는 마지막 요소는 이미 정렬되어있기 때문, 그 전까지만 반복한다.  위의 과정을 배열이 정렬될 때까지 반복한다.구현public class 버블정렬 {    public static void main(String[] args) {        int[] array = {5, 3, 8, 4, 2};        bubbleSort(array);        System.out.println(\"정렬된 배열: \" + Arrays.toString(array));    }    private static int[] bubbleSort(int[] array) {        int n = array.length;        boolean swapped;  // 교환이 일어나지 않은 경우 루프 종료        for (int i=0; i&lt;n-1; i++) { // n 번째 회전            swapped = false;            for (int j=0; j&lt;n-i-1; j++) {                if (array[j] &gt; array[j+1]) {                    int temp = array[j];                    array[j] = array[j+1];                    array[j+1] = temp;                    swapped = true;                }            }            if (!swapped) break;;        }        return array;    }}시간 복잡도  최악의 경우: O(n²)– 배열이 역순일 때(완전히 정렬되지 않은 경우) 가장 느리게 작동한다.  최선의 경우: O(n) – 배열이 이미 정렬된 상태인 경우, 한 번의 회 후 교환이 발생하지 않기 때문에 바로 종료된다.장단점장점  구현이 매우 간단하고 이해하기 쉽다  이미 정렬된 배열에 대해서는 효율적으로 동작할 수 있다 (O(n)).단점:  시간 복잡도가 O(n²)으로, 데이터가 많은 경우 성능이 떨어진다.  실제 많이 사용되지 않으며, 더 나은 성능의 정렬 알고리즘(퀵 정렬, 병합 정렬 등)이 많이 사용된다."
  },
  
  {
    "title": "LRU(Least Recently Used)Cache 알고리즘",
    "url": "/posts/algorithm-lru/",
    "categories": "Algorithm",
    "tags": "",
    "date": "2024-09-13 00:00:00 +0800",
    





    
    "snippet": "캐시는 데이터나 값을 미리 복사해 놓는 임시 저장소이다.데이터를 접근하는 시간이 오래 걸리는 경우나 값을 다시 계산하는 시간을 절약해야 할 경우 사용한다.캐시에 데이터를 미리 복사해 놓으면 계산이나 접근 없이 더 빠른 속도로 데이터에 접근이 가능하다.LRU (Least Recently Used)가장 최근에 사용되지 않은 데이터를 제거하는 방식빠른 접근...",
    "content": "캐시는 데이터나 값을 미리 복사해 놓는 임시 저장소이다.데이터를 접근하는 시간이 오래 걸리는 경우나 값을 다시 계산하는 시간을 절약해야 할 경우 사용한다.캐시에 데이터를 미리 복사해 놓으면 계산이나 접근 없이 더 빠른 속도로 데이터에 접근이 가능하다.LRU (Least Recently Used)가장 최근에 사용되지 않은 데이터를 제거하는 방식빠른 접근과, 업데이터가 가능하지만 많은 공간을 차지한다는 단점이 있다.새로운 데이터가 캐시에 저장될 때, 캐시에 있는 데이터에 접근할 때마다 해당 데이터를가장 최근에 사용된 데이터로 표시하고 가장 오래 전에 사용된 데이터를 제거한다.따라서 가장 최근에 사용된 데이터를 캐시에 보관한다.이중 연결 리스트나 해시 맵과 같은 자료 구조를 사용하여 구현할 수 있다.구현구현public class LRUCache {    class Node {        int key, value;        Node prev, next;        Node(int key, int value) {            this.key = key;            this.value = value;        }    }    private HashMap&lt;Integer, Node&gt; cache;    private int capacity, size;    private Node head, tail;    public LRUCache(int capacity) {        this.capacity = capacity;        this.size = 0;        cache = new HashMap&lt;&gt;();        this.head = new Node(0, 0);        this.tail = new Node(0, 0);        head.next = tail;        tail.prev = head;    }    public int get(int key) {        Node node = cache.get(key);        if (node == null) return -1;        moveToHead(node);        return node.value;    }    private void moveToHead(Node node) {        removeNode(node);        addToHead(node);    }    private void removeNode(Node node) {        node.prev.next = node.next;        node.next.prev = node.prev;    }    private void addToHead(Node node) {        node.prev = head;        node.next = head.next;        head.next.prev = node;        head.next = node;    }    public void put(int key, int value) {        Node node = cache.get(key);        if (node == null) {            Node newNode = new Node(key, value);            cache.put(key, newNode);            addToHead(newNode);            size++;            if (size &gt; capacity) {                Node tail = removeTail();                cache.remove(tail.key);                size--;            }        } else {            node.value = value;            moveToHead(node);        }    }    private Node removeTail() {        Node res = tail.prev;        removeNode(res);        return res;    }}"
  },
  
  {
    "title": "Backtracking",
    "url": "/posts/algorithm-backtrack/",
    "categories": "Algorithm",
    "tags": "",
    "date": "2024-09-13 00:00:00 +0800",
    





    
    "snippet": "가능한 모든 경우의 수를 탐색하는 알고리즘 기법모든 가능한 경우의 수 중에서 특정 조건을 만족하는 경우만 탐색한다. 조건을 만족하지 않으면 이전 단계로 돌아가다른 해를 탐색한다.불필요한 경로를 빨리 제거할 수 있어, 효율적이다.  해를 부분적으로 구성해 나가면서, 해당 해가 유망하지 않은 경우 탐색을 중단하고 이전 단계로 돌아간다.  각 단계에서 선택...",
    "content": "가능한 모든 경우의 수를 탐색하는 알고리즘 기법모든 가능한 경우의 수 중에서 특정 조건을 만족하는 경우만 탐색한다. 조건을 만족하지 않으면 이전 단계로 돌아가다른 해를 탐색한다.불필요한 경로를 빨리 제거할 수 있어, 효율적이다.  해를 부분적으로 구성해 나가면서, 해당 해가 유망하지 않은 경우 탐색을 중단하고 이전 단계로 돌아간다.  각 단계에서 선택을 하고, 그 선택에 따라 다시 문제를 재귀적으로 탐색한다.  Pruning 가지치기동작  가능한 해를 하나씩 만들며 조건을 만족하는지 확인한다.  각 단계에서 유망성을 확인한다.  유효하지 않으면 해당 경로의 탐색을 중단하고 이전 단계로 돌아간다.  유효한 해인 경우 결과에 추가한다.  위의 과정을 반복하여 가능한 모든 경오를 탐색한다.구현 예시숫자 n이 주어졌을 때, n개의 쌍으로 된 모든 유효한 괄호 조합을 리턴하는 함수 구현class Solution_BackTracking {    public List&lt;String&gt; backtracking(int n) {        List&lt;String&gt; res = new ArrayList&lt;&gt;();        backtrack(res, \"\", 0, 0, n);        return res;    }    private void backtrack(List&lt;String&gt; result, String currentStr, int openCnt, int closeCnt, int max) {        if (currentStr.length() == max*2) {            result.add(currentStr);            return;        }        if (openCnt &lt; max) {            backtrack(result, currentStr + \"(\", openCnt + 1, closeCnt, max);        }        if (closeCnt &lt; openCnt) {            backtrack(result, currentStr + \")\", openCnt, closeCnt + 1, max);        }    }}"
  },
  
  {
    "title": "HashMap의 구조",
    "url": "/posts/Algorithm-hashmap/",
    "categories": "Algorithm",
    "tags": "",
    "date": "2024-09-12 00:00:00 +0800",
    





    
    "snippet": "키-값의 쌍으로 데이터를 저장하는 자료구조각 키를 해시 함수로 변환하여 배열의 인덱스에 저장하여 데이터 추가, 검색, 삭제 등의 작업을 수행한다.키의 중복을 허용하지 않으며, 하나의 키에 하나의 값이 매핑된다.해시 함수는 키를 해시 코드로 변환하여 HashMap의 버킷 인덱스를 정하는데, 서로 다른 두 개의 키가 같은 해시 값을 갖는 경우가 발생한다....",
    "content": "키-값의 쌍으로 데이터를 저장하는 자료구조각 키를 해시 함수로 변환하여 배열의 인덱스에 저장하여 데이터 추가, 검색, 삭제 등의 작업을 수행한다.키의 중복을 허용하지 않으며, 하나의 키에 하나의 값이 매핑된다.해시 함수는 키를 해시 코드로 변환하여 HashMap의 버킷 인덱스를 정하는데, 서로 다른 두 개의 키가 같은 해시 값을 갖는 경우가 발생한다.이 현상을 해시 충돌이라고 한다.HashMap에서는 해시 충돌을 방지하기 위해 Chaining, Open Addressing을 이용한다.  Chaining충돌이 발생한 버킷 안에서 연결리스트, 트리 구조로 여러 키-값을 저장하는 방식  Open addressing다른 빈 버킷을 찾아 데이터를 저장하는 방식자바의 HashMap은 hashCode() 메서드를 이용해 해시 값을 얻고, 배열이 찬 경우 resize() 메서드를 이용하여 버킷 배열의 크기를 늘릴 수 있다. 기존의 항목을 새로 해싱하여 새 배열에 재분배한다.  로드 팩터 (Load Factor)  Load Factor은 HashMap이 일정 수준 채워지면 버킷 배열을 확장할지 정하는 기준이다.기본적으로 Java의 HashMap은 로드 팩터 0.75를 사용한다. 따라서 버킷의 75%가 차면 배열의 크기를 resizing하고 재해싱 한다.로드 팩터를 낮게 설정하는 경우 리사이징이 더 자주 일어나며, 높게 설정하는 경우 충돌 가능성이 증가한다.HashMap의 시간 복잡도는 평균적으로 O(1)이다.해시 충돌이 많이 발생하면, 특정 버킷에 연결된 리스트를 탐색해야 하기 때문에 시간 복잡도가  O(n)에 도달한다.하지만, Java 8 이후 트리 구조를 사용하여 최악의 경우에도 O(log n)으로 성능을 보장한다.주요 메서드1. put(key, value)키와 값을 HashMap에 추가한다.HashMap&lt;String, String&gt; dataMap = new HashMap&lt;&gt;():dataMap.put(\"key1\", \"value1\");dataMap.put(\"key2\", \"value2\");dataMap.put(\"key3\", \"value3\");  해시 함수를 통해 키를 버킷 배열의 인덱스로 변환한다.  해당 버킷이 비어있는 경우 새로운 노드를 추가한다.  충돌이 발생하는 경우, 연결 리스트를 순회하여 동일 키가 있는지 확인          동일 키가 있는 경우 값 update      동일 키가 없는 경우 리스트의 끝에 새 노드 추가      2. get(key)키에 대응하는 값을 반환한다.dataMap.get(\"key1\");  키를 해시 함수로 변환하여 버킷의 인덱스를 찾는다.  해당 버킷에 연결된 리스트를 순회하여 일치하는 키를 찾아 대응하는 값을 반환한다.  키가 없는 경우 -1 또는 null 반환한다.3. remove(key)해당 키를 삭제한다.dataMap.remove(\"key1\");  키를 해시 함수로 변환해 버킷을 찾는다.  해당 버킷에서 연결 리스트를 순회하여 키를 찾는다.  키를 찾아 해당 노드를 리스트에서 제거한다.HashMap 구조버킷 배열과 노드로 구성  버킷 배열 : 키의 해시 값에 따라 값이 저장되는 배열  노드 : 각 노드는 키-값과 다음 노드 정보를 갖으며, 연결리스트, 트리 형태로 연결된다.  버킷  배열의 한 칸으로, 해시 함수에 의해 변환된 키가 매핑되는 위치이다.버킷 배열의 크기는 보통 2의 제곱수로 설정되어 있으며, 해시 충돌을 처리하기 위해 각 버킷에 여러 개의 키-값이 저장될 수 있다.배열과 연결리스트의 결합으로 해시맵은 키에 대해 해시 함수를 사용해서 키가 저장될 배열의 인덱스를 정한다. 만약 서로 다른 두 키가 동일한 해시 값을갖게 되면, 해시 충둘이 발생한다.충돌이 발생하면, 같은 버킷에 여러 엔트리가 저장되는데, 이때 연결리스트로 연결한다.자바 8 이전에는 충돌이 발생하는 경우 연결리스트를 이용하였다.이 경우, 하나의 버킷에 많은 엔트리가 저장되면, 검색 속도가 O(n)이 된다.이를 개선하기 위해 엔트리가 일정 수준을 넘어가게되면 이진 트리 구조로 변환된다.이진 트리는 최악의 경우에도 검색 성능이 O(log n)을 유지한다.해시코드를 이용해 데이터의 저장 위치를 빠르게 찾을 수 있으며, 검색 속도를 향상시킨다.MyhashMap 구현public class MyHashMap {    class Node {        int key, value;        Node next;        Node(int key, int value) {            this.key = key;            this.value = value;            this.next = null;        }    }    private Node[] buckets;    private int capacity = 10000;    public MyHashMap() {        buckets = new Node[capacity];    }    public void put(int key, int value) {        int index = hash(key);        // insert or update        if (buckets[index] == null) {   // 없는 경우 새로운 노드 추가            buckets[index] = new Node(key, value);        } else {    // 있는 경우 연결 리스트를 탐색, 키가 있으면 update, 없으면 node 추            Node current = buckets[index];            while (current != null) {                if (current.key == key) {                    current.value = value;                    return;                }                if (current.next == null) {                    current.next = new Node(key, value);                    return;                }                current = current.next;            }        }    }    private int hash(int key) {        return key % capacity;    }    public int get(int key) {        int index = hash(key);        Node current = buckets[index];        while (current != null) {            if (current.key == key) {                return current.value;            }            current = current.next;        }        return -1;    }    public void remove(int key) {        int index = hash(key);        Node current = buckets[index];        Node prev = null;        while (current != null) {            if (current.key == key) {                if (prev == null) {                    buckets[index] = current.next;                } else {                    prev.next = current.next;                }            }            prev = current;            current = current.next;        }    }}"
  },
  
  {
    "title": "DI(Dependency Injection)",
    "url": "/posts/Spring-DI/",
    "categories": "Spring",
    "tags": "",
    "date": "2024-09-06 00:00:00 +0800",
    





    
    "snippet": "객체지향 프로그래밍에서객체 간의 의존성을 외부에서 주입하여 객체 간의 결합도를 낮추고, 코드의 재사용성과 유연성을 높이는 패턴이로써 객체가 스스로 직접 의존성을 생성하거나 관리하는 대신, 외부에서 필요한 의존성을 주입받아서 사용한다.  객체는 자신이 사용할 객체의 구현을 몰라도 되고, 인터페이스나 추상 타입에 의존한다.강합 결합?한 클래스가 다른 클래...",
    "content": "객체지향 프로그래밍에서객체 간의 의존성을 외부에서 주입하여 객체 간의 결합도를 낮추고, 코드의 재사용성과 유연성을 높이는 패턴이로써 객체가 스스로 직접 의존성을 생성하거나 관리하는 대신, 외부에서 필요한 의존성을 주입받아서 사용한다.  객체는 자신이 사용할 객체의 구현을 몰라도 되고, 인터페이스나 추상 타입에 의존한다.강합 결합?한 클래스가 다른 클래스의 구현에 직접적으로 의존하는 상황으로, 두 클래스 간의 관계를 변경하거나 유지보수가 어렵다.public class Engine {    public void start() {        System.out.println(\"Engine start!\");    }}public class ElectricEngine extends Engine {    @Override    public void start() {        System.out.println(\"Electric engine started\");    }}public class Car {    private Engine engine;        public Car() {        this.engine = new Engine();    }        public void startCar() {        engine.start();        System.out.println(\"Car started!\");    }}Car 클래스는 Engine 객체의 구현에 의존한다. 만약 Engine이 변경되거나 다른 종류의 엔진을 사용해야 하는 경우, Car의 코드를 변경해야 한다.그리고 테스트를 하는 경우 실제 Engine 객체가 필요하기 때문에 테스트가 복잡해질 수 있다.구체적인 구현?클래스의 실제 행동이나 기능을 수행하는 코드를 의미한다.Engine는 기본 엔진을 나타내는 클래스이고, ElectricEngine은 전기 엔진을 나타내는 구체적인 구현이다.각 클래스는 start() 메서드를 다르게 구현할 수 있다.Car 클래스가 특정한 Engine 객체를 직접 생성할 때, Car는 Engine의 구현에 의존하게 된다.만약 Engine의 클래스가 변경 되면 Car도 변경될 수 있다.Car가 ElectricEngine을 사용해야 한다면, 코드를 수정해야 한다.public class Car {    private Engine engine;        public Car() {        this.engine = new ElectricEngine();    }   public void startCar() {      engine.start();      System.out.println(\"Car started\");   }}이러한 방식은 Car가 특정한 엔진 구현에 강하게 결합되어 있어 유연성이 떨어진다.따라서, 새로운 엔진이 추가될 때마다 Car 클래스를 수정해야 한다.Car 클래스는 항상 ElectricEngine클래스만 사용하게되며, 만약 다른 엔진(GasolineEngine)을사용하고 싶은 경우, Car클래스를 수정해야 한다.또한 새로운 엔진이 생길 때마다 해당 엔진으로 변경하기 위해 Car 클래스를 고치는 것은 개방-폐쇄 원칙을 위반한다.이러한 문제를 해결하기 위해 의존성 주입을 사용할 수 있다.public class Car {    private Engine engine;        public Car(Engine engine) {        this.engine = engine;    }        public void startCar() {        engine.start();        System.out.println(\"Car started\");    }}Car 클래스는 Engine 인터페이스에 의존하며, 실제 구현체를 생성자를 통해 주입받는다.이 방식이 의존성 주입(DI) 패턴이다.이를 통해 유연성이 높아지며, Car클래스는 ElectricEngine 등 다양한 종류의 엔진을 사용할 수 있다.또한 테스트 시 모의 객체(Mock Object)등을 주입하여 테스트할 수 있기 때문에 단위 테스트 작성에 용이하다.Engine regularEngine = new Engine();Car car1 = new Car(regularEngine);Engine electricEngine = new ElectricEngine();Car car2 = new Car(electricEngine);car1.startCar();car2.startCar();의존성 주입 방법1. 생성자 주입public class UserService {    // final로 선언해 불변성을 보장한다.    private UserRepository userRepository;        // 의존성을 생성자를 통해 주입    public UserService(UserRepository userRepository) {       this.userRepository = userRepository;    }}  의존성을 생성자에서 받아오기 때문에, 불변성이 보장되고, 테스트가 용이하다.  생성자 주입은 의존성 주입 실패 시 컴파일 에러를 감지할 수 있다.2. Setter 주입public class UserService {        private UserRepository userRepository;        public void setUserRepository(UserRepository userRepository) {        this.userRepository = userRepository;    }}  선택적인 의존성 주입이 가능하다.  의존성을 주입받을 필드에 대한 수정 가능성이 필요할 때 유용하다.  하지만 의존성을 변경할 수 있는 상태로 유지하게 된다.  객체가생성된 후, 세터 메서드를 호출하지 않으면 의존성이 설정되지 않아 불완전한 상태가 될 수 있다.3. field 주입@Autowired 어노테이션을 사용하여 의존성을 필드에 직접 주입한다.필드에 @Autowired를 붙이면, 스프링이 자동으로 해당 타입이 빈을 찾아서 주입한다.public class UserService {    @Autowired    private UserRepository userRepository;}  필드에 직접 의존성을 주입한다.  필드 주입은 테스트나 유지보수 시 유연성이 떨어질 수 있어, 일반적으로 생성자 주입이 권장된다.  @Autowired  스프링 프레임워크에서 사용되는 어노테이션으로, 의존성 주입을 자동으로 처리한다.  스프링 컨테이넉가 클래스의 필드, 생성자, 또는 메서드에 필요한 의존성으로 자동으로 주입한다.의존성 주입의 동작 원리  스프링은 컨테이너에서 관리되는 빈들 간의 의존성을 자동으로 주입한다.  @Autowired는 스프링의 IoC 컨테이너에서 적합한 빈을 찾아 주입한다.  타입 기반 주입 방식으로, @Autowired가 선언된 필드나 생성자에 타입이 일치하는 빈을 찾아 자동으로 주입한다.Controller - Service - Repository해당 요청을 다음 클래스인 서비스에 넘겨주기 위해, private final 타입으로 서비스 멤버 변수를 정의한다.왜? final로 정의할까?final을 사용하여 선언된 필드는 객체가 생성된 이후 변경할 수 없기 때문에  의존성이 확장되고,  주입된 객체가 이후에 변경되지 않는다.final로 선언된 필드는 생성자에서 반드시 초기화되어야 한다.즉, 생성자에서 주입받는 의존성이 고정되고 그 의존성이 절대 변하지 않기 때문에, 해당 클래스가 무엇을 의존하는지 명확하게 보여준다.public class UserService {    private final UserRepository userRepository; // 의존성 고정    public UserService(UserRepository userRepository) { // 생성자 주입        this.userRepository = userRepository;    }}이 코드를 통해 UserService가 생성될 때 UserRepository를 주입받고, 이후 userRepository필드가 변경되지 않음을 확인할 수 있다.따라서, UserService는 UserRepository에 의존한다.final 필드는 한 번 주입된 의존성이 불변임을 나타낸다. 따라서 해당 객체가 생애 주기 동안 의존성을 변경할 수 없다. 하지만, final이 아닌 필드의 경우 의존성이 코드 중간에 바뀔 가능성이 있다.따라서,final을 사용하면 서비스 클래스와 컨트롤러 클래스가 한 번 매핑되고, 그 후 맵핑이 바뀌지 않는다.또한 @Autowired와 생성자 주입을 통해 컨트롤러와 서비스의 생명주기를 연결하고, 서비스와 컨트롤러가 같이 생성되도록 한다.의존성 주입은 클래스가 다른 클래스의 구현에 의존하지 않고, 인터페이스나 추상 클래스에 의존함으로써클래스 간 결합도를 낮춘다.의존성 주입을 사용하면 테스트 시, 실제 객체 대신 Mock객체나 Stub 객체를 주입하여 단위 테스트가 더 용이해진다.객체의 생성과 사용을 분리하여, 코드의 유연성과 재사용성을 높일 수 있다."
  },
  
  {
    "title": "Supplier 인터페이스와 LRU",
    "url": "/posts/java-supplier-lru/",
    "categories": "Java",
    "tags": "",
    "date": "2024-09-01 00:00:00 +0800",
    





    
    "snippet": "Supplier 인터페이스입력 매개변수 없이 출력을 생성하는 인터페이스Supplier 인터페이스는 값을 생성하거나 제공할 수 있다.사용 사례1. 지연 초기화객체나 데이터를 지연 초기화하여, 실제로 필요할 때 객체를 생성하여 성능을 높일 수 있다.public class LazyInitializationExample {    private Supplier...",
    "content": "Supplier 인터페이스입력 매개변수 없이 출력을 생성하는 인터페이스Supplier 인터페이스는 값을 생성하거나 제공할 수 있다.사용 사례1. 지연 초기화객체나 데이터를 지연 초기화하여, 실제로 필요할 때 객체를 생성하여 성능을 높일 수 있다.public class LazyInitializationExample {    private Supplier&lt;ExpensiveObject&gt; expensiveObjectSupplier = this::createExpensiveObject;    private ExpensiveObject createExpensiveObject() {        System.out.println(\"Expensive object created\");        return new ExpensiveObject();    }    public ExpensiveObject getExpensiveObject() {        return expensiveObjectSupplier.get();    }    public static void main(String[] args) {        LazyInitializationExample example = new LazyInitializationExample();        System.out.println(\"Before accessing expensive object\");        ExpensiveObject obj = example.getExpensiveObject(); // 이 시점에서 객체 생성        System.out.println(\"After accessing expensive object\");    }}class ExpensiveObject {    public ExpensiveObject() {        // 복잡한 초기화 작업    }}객체의 생성이 필요할 때까지 지연되기 때문에 초기화 시점에 대한 제어가 가능하며, 따라서 불필요한 리소스 사용을 줄일 수 있다.2. 기본 값 제어어떤 메서드에서 기본적으로 사용될 값을 Supplier를 통해 정의할 수 있다.코드에서 반복적으로 사용되는 기본값을 관리하거나, 다양하나 상황에서 기본 값을 다르게 설정할 때 용이하다.import java.util.function.Supplier;public class DefaultValueExample {    private Supplier&lt;String&gt; defaultNameSupplier = () -&gt; \"Default Name\";    public String getName(String name) {        return name != null ? name : defaultNameSupplier.get();    }    public static void main(String[] args) {        DefaultValueExample example = new DefaultValueExample();        System.out.println(example.getName(null)); // 출력: Default Name        System.out.println(example.getName(\"John\")); // 출력: John    }}3. 캐싱특정 계산의 결과를 캐싱할 수 있다.최초 계산 후 캐싱하여 이후 호출시 동일한 값을 반환한다.값을 재사용함으로써 성능을 최적화할 수 있다.import java.util.function.Supplier;public class MemoizationExample {    private Supplier&lt;Integer&gt; expensiveCalculation = this::calculate;    private Integer calculate() {        System.out.println(\"Performing expensive calculation...\");        return 42; // 복잡한 계산의 결과    }    public Integer getCalculationResult() {        return expensiveCalculation.get();    }    public static void main(String[] args) {        MemoizationExample example = new MemoizationExample();        System.out.println(example.getCalculationResult()); // 첫 번째 호출: 계산 수행        System.out.println(example.getCalculationResult()); // 두 번째 호출: 캐시된 결과 반환    }}4. 흐름 제어코드의 실행 흐름을 유연하게 제어할 수 있으며, 조건에 따라 특정 코드를 실행하거나 실행하지 않도록 설정할 수 있다.특정 값이나 객체의 생성 타이밍을 설정할 수 있고, 반복적인 코드의 중복을 줄일 때 유용하다.import java.util.function.Supplier;public class ControlFlowExample {    private Supplier&lt;String&gt; debugMessageSupplier = () -&gt; \"Debug: Something went wrong!\";    public void performAction(boolean debug) {        if (debug) {            System.out.println(debugMessageSupplier.get()); // 디버그 메시지 출력        } else {            System.out.println(\"Action performed successfully\");        }    }    public static void main(String[] args) {        ControlFlowExample example = new ControlFlowExample();        example.performAction(true);  // 디버그 모드        example.performAction(false); // 일반 모드    }}Supplier와 캐싱 최적화 전략캐싱 최적화를 통해 속도를 개선하고, 자원을 절약하고 캐시된 데이터를 최신 상태를 유지한다.주로 자주 조회되는 데이터, 높은 비용, 제한된 자원, 데이터가 최신으로 유지되어야 하는 경우에 캐싱 전략을 최적화 한다.1. 캐시 만료 시간 설정캐시된 데이터가 오랫동안 사용되지 않으면, 그 데이터는 오래된 정보가 된다. 이 경우 만료 시간을 설정하여 최신 데이터를 유지하고, 필요하지 않은 데이터를 자동으로 제거할 수 있다.Supplier를 사용하여 만료 시간에 따라 새로 계산된 값을 캐싱한다.2.LRU (Least Recently Used) 캐싱 알고리즘가장 오랫동안 사용되지 않은 데이터를 우선적으로 제거하여, 메모리 사용을 최적화한다. LinkedHashMap과 같은 자료구조를 사용하여 LRU 캐시를 쉽게 구현할 수 있다.Supplier는 LRU 캐시 내에서 데이터를 처음 요청받을 때 실제로 값을 생성할 수 있는 방법으로 사용될 수 있다.3.Cache Invalidation캐시된 데이터가 더 이상 유효하지 않을 때, 수동 또는 자동으로 캐시를 무효화한다.이는 최신 데이터가 필요하거나, 특정 이벤트가 발생했을 때 유용하,.위의 CachedValue 클래스에서 invalidateCache 메서드는 수동으로 캐시를 무효화할 수 있는 방법을 제공한다.4.Lazy Loading처음에 데이터를 로드하지 않고, 필요할 때만 데이터를 로드한다.  이 전략은 초기 로딩 시간을 줄이고, 불필요한 리소스 사용을 방지한다.Supplier는 Lazy Loading을 구현하는 데 필수 도구로, 값이 필요할 때만 생성되도록 한다.5.동시성 제어여러 스레드가 동시에 캐시에 접근하는 경우, 캐시의 일관성을 유지하기 위한 동시성 제어가 필요하다.ConcurrentHashMap과 같은 스레드 안전한 자료 구조를 사용하거나, synchronized 블록을 사용하여 동시성 문제를 해결할 수 있다.Least Recently Used (LRU)?가장 오랫동안 사용되지 않은 데이터를 우선적으로 캐시에서 제거하는 방법으로, 이를 통해 최근에 사용한 데이터는 캐시에 유지할 수 있다.메모리가 제한된 환경에서 오래된 데이터는 제거하고 최신 데이터를 유지하여 메모리를 효율적으로 관리할 수 있다. 또한 자주 사용되는 데이터에 빠르게 접근할 수 있도록 하여 성능을 높일 수 있따. 또한 최신의 데이터를 유지하여 일관성을 보장할 수 있다.LRU 알고리즘의 핵심은 각 데이터의 사용 시점(최근 사용 시간)을 추적하는 것이다.  데이터 접근 시점 갱신: 데이터를 접근(읽기/쓰기)할 때마다 그 데이터의 최근 사용 시간을 갱신한다.  캐시 가득 참: 캐시가 가득 차서 새로운 데이터를 추가해야 할 경우, 가장 오랫동안 사용되지 않은 데이터를 제거한다.  새로운 데이터 추가: 제거된 자리에 새로운 데이터를 추가한다.LRU 캐싱은 이중 연결 리스트, 해시맵을 사용하여 구현할 수 있다.  이중 연결 리스트 (Doubly Linked List): 노드의 삽입, 삭제를 효율적으로 수행할 수 있으며, 가장 최근에 사용된 데이터를 리스트의 앞쪽에 위치시키고, 가장 오래된 데이터를 리스트의 뒤쪽에 위치시킨다.  해시맵 (HashMap): 데이터의 빠른 조회와 참조를 위해 사용하며, 키를 통해 해당 노드를 빠르게 찾을 수 있다.LRU 캐싱 알고리즘의 데이터 구조새로운 데이터가 추가될 때마다 해당 데이터를 가장 최근에 사용된 데이터로 갱신해야 한다. 최근에 사용된 데이터를 LinkedHashMap의 뒤로 이동시키고, 가장 앞에 있는 데이터를 LRU 데이터로 판별하여 삭제하는 메커니즘을 구현해야 한다.또한, 삭제될 때를 예측하여 불필요한 데이터를 즉시 삭제해야 한다.  HashMap을 확장한 구조  doubleLinkedList 형태DoubleLinkedList?LinkedList를 이중으로 사용하여 요소의 순서를 유지하는 리스트로,자바의 링크드리스트는 더블링크드리스트로 구현되어있다.LinkedHashMap에는 accessOrder 이라는 값이 있다.Entry 에 access 하는 mode를 나타낸다  true : access 빈도 낮은 것부터 접근  false : 입력된 순서로 Entry 에 접근linkedList는 키, 값, next, after, before를 갖는다.  before : 이 노드 앞에 삽입된 노드를 가리킴  after : 이 노드 뒤에 삽입된 노드를 가리킴  key : 제공된 키  value : 제공된 값  next : 배열 테이블의 동일한 버킷에 있는 다음 노드를 가리킴HashMap과의 차이HashMap을 확장한 구조이기 때문에 HashMap의 장점 + 순서보장을 할 수 있는 구조가 linkedHashMap라고 할 수 있다.순서 지정 기능으로 인해 HashMap보다 더 많은 메모리가 필요하다.시간복잡도는 HashMap과 동일하게 get,put,remove,containsKey 메소드를 호출할 때 O(1)을 갖는다.HashMap과 마찬가지로 동기화 처리가 되어있지 않기 때문에 multi-thread환경에서 사용은 적절하지 않다.LinkedHashMap 를 사용하여 LRU 캐싱 알고리즘을 구현하고, 데이터를 접근할 때마다 해당 데이터의 “사용 시간” 또는 “접근 시간”을 업데이트하여 최근에 사용된 데이터를 파악하, 이를 바탕으로 가장 오랫동안 사용되지 않은 데이터를 식별하고 처리한다.LRU 캐싱 알고리즘을 구현할 때 고려해야 할 핵심 요소이중 연결 리스트와 해시맵의 조합 형태로,LinkedHashMap의 생성자에서 accessOrder 파라미터를 true로 설정하면, 데이터가 접근될 때마다 노드가 리스트의 앞쪽으로 이동하게 되어 LRU 캐싱을 자동으로 구현한다.이 코드에서 removeEldestEntry 메서드는 캐시의 크기가 설정된 용량을 초과할 때 가장 오래된 항목을 자동으로 제거한다.import java.util.LinkedHashMap;import java.util.Map;public class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; {    private final int capacity;    public LRUCache(int capacity) {        super(capacity, 0.75f, true);        this.capacity = capacity;    }    @Override    protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) {        return size() &gt; capacity;    }}1. 시간 복잡도 최적화  빠른 데이터 접근: 캐시된 데이터를 빠르게 접근할 수 있어야 합니다. 이를 위해 HashMap을 사용하여 O(1) 시간 복잡도로 데이터를 검색할 수 있도록 한다.  빠른 데이터 갱신: 이중 연결 리스트를 사용하여 삽입, 삭제시 캐시된 항목을 리스트의 처음이나 끝으로 쉽게 이동시킬 수 있다.    2. 메모리 효율성    메모리 사용량: HashMap과 이중 연결 리스트를 함께 사용하면 캐시 효율성이 높아지지만, 추가적인 메모리 오버헤드가 발생한다.  캐시 크기 설정: 캐시 크기가 너무 작으면 빈번한 캐시 미스가 발생하고, 너무 크면 메모리 낭비가 발생한다. 따라서, 적절한 캐시 크기를 설정해야 한다.    3. 캐시 갱신    데이터 삽입 정책: 새로운 데이터가 캐시에 삽입되면, 이를 가장 최근에 사용된 데이터로 간주하고 이중 연결 리스트의 맨 앞이 된다.  캐시 크기 초과 시 정책: 캐시가 가득 찼을 때 새로운 데이터를 추가해야 하는 경우, 이중 연결 리스트의 맨 끝에 있는, 즉 가장 오랫동안 사용되지 않은 데이터를 제거한다.    4. 동시성 관리    스레드 안전성: 멀티스레드 환경에서 캐시가 안전하게 작동하도록 동기화가 필요하다.동기화는 성능 저하를 유발할 수 있으므로 필요한 부분에만 최소한으로 적용해야 한다.    5. 캐시의 초기화 및 무효화    캐시 초기화: 시스템 시작 시 캐시를 미리 채우거나, 캐시가 가득 찼을 때 특정 조건에 따라 캐시를 초기화할 수 있어야 한다.  캐시 무효화: 데이터가 갱신되거나 시스템 환경이 변할 때, 캐시의 특정 데이터를 무효화할 필요가 있다.이를 통해 캐시가 최신 상태를 유지하도록 할 수 있다.    6. 추가적인 최적화 기법    사용 패턴 분석: 캐시 사용 패턴을 분석하여 LRU 외에 다른 캐싱 전략이 더 적합한지 평가할 수 있다. 예를 들어, 자주 사용되는 데이터는 캐시에 오래 남도록 하는 전략을 추가할 수 있다.  다중 레벨 캐싱: 메모리와 디스크 또는 네트워크 캐시를 조합한 다중 레벨 캐싱을 고려할 수 있다.메모리에 여유가 없을 때 디스크 기반 캐시를 사용하여 적중률을 높일 수 있다."
  },
  
  {
    "title": "Stream API",
    "url": "/posts/java-stream_api/",
    "categories": "Java",
    "tags": "",
    "date": "2024-09-01 00:00:00 +0800",
    





    
    "snippet": "Stream API데이터 처리를 간결하고 효율적으로 할 수 있도록 도와주는 APIJava8 부터 도입되어 컬렉션의 데이터를 함수형으로 처리할 수 있도록 해준다. 데이터 소스(컬렉션, 배열, I/O 채널 등)에서 파이프라인 방식으로 연속적인 연산을 수행할 수 있다.특징1. 불변성스트림은 기존의 데이터를 변경하지 않고, 새로운 스트림을 생성하여 작업을 수...",
    "content": "Stream API데이터 처리를 간결하고 효율적으로 할 수 있도록 도와주는 APIJava8 부터 도입되어 컬렉션의 데이터를 함수형으로 처리할 수 있도록 해준다. 데이터 소스(컬렉션, 배열, I/O 채널 등)에서 파이프라인 방식으로 연속적인 연산을 수행할 수 있다.특징1. 불변성스트림은 기존의 데이터를 변경하지 않고, 새로운 스트림을 생성하여 작업을 수행한다.2. 지연 연산 Lazy Evaluation스트림에는 중간 연산과 최종 연산이 있는데, 최종 연산이 호출될 때까지 중간 연산이 실제로 수행되지 않는 것을 말한다.지연 연산으로 불필요한 계산이 줄어들어 성능을 최적화할 수 있다.3. 파이프라이닝 Pipelining여러 중간 연산을 연결하여 하나의 파이프라인을 구성할 수 있다.파이프라인은 한 번의 최종 연산을 통해 처리할 수 있다.List&lt;String&gt; fruits = Arrays.asList(\"apple\", \"banana\", \"orange\");Listt&lt;String&gt; result = fruits.stream()                             .filter(name -&gt; name.length() &gt; 5)                             .map(String::toUpperCase)                             .sorted()                             .collect(Collectors.toList());4. 함수형 프로그래밍 지원함수형 인터페이스와 람다 표현식을 활용하여 함수형 프로그래밍을 지원하며, 이를 통해 코드를 간결하게 할 수 있다.5. 다양한 데이터 소스 지원Collection 인터페이스를 구현한 클래스 뿐 아니라 배열, 파일 등 다양한 데이터를 사용할 수 있다.6. 유형 스트림 지원기본형 타입을 위한 스트림을 별도로 제공하여 박싱 비용을 줄일 수 있다.Lazy EvaluationJava Stream API에서 중간 연산이 최종 연산이 호출될 때까지 실제로 수행되지 않는 것을 말한다.구현 방식1. 스트림을 생성한다.스트림은 데이터의 요소들의 연속적인 데이터 흐름이다.스트림을 생성하면, 데이터를 일관된 방식으로 처리할 수 있는 파이프 라인을 만들 수 있다.List&lt;String&gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\");Stream&lt;String&gt; nameStream = names.stream(); // 스트림 생성        String[] nameArray = {\"Alice\", \"Bob\", \"Charlie\"};Stream&lt;String&gt; nameStream = Arrays.stream(nameArray); // 스트림 생성        Stream&lt;String&gt; nameStream = Stream.of(\"Alice\", \"Bob\", \"Charlie\"); // 스트림 생성2. 중간 연산을 정의한다.중간 연산(filtter, map, sorted)이 스트림에 연결된다.  각 중간 연산은 스트림을 변환하는 새로운 스트림을 반화하며, 실제 데이터는 처리되지 않는다.중간 연산은 다음 연산을 위한 연산 체인을 설정한다.3. 최종 연산을 호출한다.최종 연산(collect, forEach, reduce)이 호출되면 스트림의 데이터가 실제로 처리된다.   이때 스트림의 중간 연산이 실행된다.장점      스트림은 필요한 데이터만 처리하기 때문에 성능을 향상시킨다.        중간 연산이 지연되어 필요한 시점에 처리되기 때문에 메모리 사용이 줄어든다.        여러 중간 연산이 연결된 경우, 하나의 파이프라인에서 순차적으로 처리되기 때문에 불필요한 중간 결과가 생성되지 않는다.모든 연산이 최종 연산이 호출될 때 한 번에 처리된다.  단점  오류가 발생할 경우, 실제 실행 시점에서 오류가 발생하기 때문에 중간 연산에서 발생한 문제를 추적하기 어렵다.스트림은 데이터를 변경하지 않는다? 왜?스트림은 연산 과정에서 원본 데이터를 복사하는 것이 아닌, 참조된 데이터를 바탕으로 필요한 연산을 수행하여 새로운 데이터를 생성한다.한 번 사용된 이후 재사용할 수 없는 일회성 객체이며, 이를 통해 원본 데이터의 불변성을 유지할 수 있다.또한 참조 변수에 저장하지 않고 곧바로 연산을 수행할 수 있다. 즉, 스트림 객체를 별도로 저장하지 않고 사용하는 것이 가능하다.List&lt;String&gt; names = Arrays.asList(\"apple\", \"banana\", \"coke\");names.stream()          // 스트림 생성     .filter(name -&gt; name.startsWith(\"a\"))   // 중간연산      .filter(String::toUpperCase)   // 중간연산      .forEach(System.out::println);          // 최종연산위 코드에서는 트림을 생성한 후, 바로 연산(filter, forEach)을 수행한다.일회성 객체로, 최종 연산이 수행되면 더 이상 해당 스트림을 사용할 수 없다.만약 동일한 연산을 다시 수행하려면 names.stream()으로 새로 스트림을 생성해야 한다.스트림의 파이프라인은 최종 연산이 호출될 때 한 번에 실행되고 그 후에 스트림은 종료된다.다시 사용하려고 하면 IllegalStateException이 발생한다.Stream&lt;String&gt; stream = names.stream().filter(name -&gt; name.startsWith(\"A\"));stream.collect(Collectors.toList()); // 최종 연산stream.collect(Collectors.toList()); // IllegalStateException 발생Stateful &amp; StatefulessStateful 연산 (Stateful Operations)Stateful Stream은 스트림의 중간 연산 중 이전 단계의 결과를 바탕으로 현재 연산을 수행하는 것이디ㅏ.  전체 스트림의 상태를 추적하기 때문에 성능이 떨어질 수 있다.          sorted(), distinct() 가 있으며, 전체 데이터의 상태를 고려해야 하기 때문에 연산 중 일시적으로 전체 데이터를 저장하거나 처리해야 한다.        상태를 추적해야 하기 때문에 메모리 사용량이 증가하고 성능이 저하될 수 있다.      요소 간의 관계를 고려하거나, 스트림 전체를 정렬, 필터링해야 할 때 사용한다.    sorted          스트림의 모든 요소를 정렬하기 위해 전체 스트림을 고려한다.      전체 데이터를 메모리에 로드하고 정렬해야 하기 때문에 상태를 유지한다.        distinct          중복을 제거하기 위해 스트림의 모든 요소를 기억하고 비교해야 하기 때문에 상태를 유지한다.      Stateless 연산 (Stateless Operations)연산을 수행할 때 스트림의 요소 간의 상태를 유지하지 않고, 각 요소를 독립적으로 처리하는 연산으로 요소 간의 관계를 고려하지 않는다.  연산은 각 요소를 독립적으로 처리하며, 이전 또는 다른 요소의 상태에 의존하지 안흔다.      상태를 유지하지 않기 때문에 메모리 사용량이 적고 성능이 좋다.        filter()각 요소를 개별적으로 검사하여 조건에 맞는 요소만 남기며, 다른 요소의 상태나 관계를 고려하지 않는다.    map()각 요소를 다른 형태로 변환하며, 이 과정에서 요소 간이 관계를 고려하지 않는다.중간 연산과 최종 연산중간 연산스트림 파이프라인에서 스트림을 변환하거나 필터링한다.지연 평가를 통해 최종 연산이 호출될 때까지 실제로 수행되지 않는다.연속해서 호출할 수 있으며, 스트림 파이프라인을 구성할 수 있다.  filter(Predicate) : 조건에 맞는 요소만 필터링하여 새로운 스트림 반환    List&lt;String&gt; names = Arrays.asList(\"amy\", \"jenny\", \"bob\", \"jun\");Stream&lt;String&gt; filteredStream = names.streaam()                                   .filter(name -&gt; name.startsWith(\"j\"));        map(Function&lt;T, R&gt;) : 각 요소를 다른 형태로 변환하여 새로운 스트림 반환    List&lt;String&gt; names = Arrays.asList(\"amy\", \"jenny\", \"bob\", \"jun\");Stream&lt;String&gt; upperCaseStream = names.stream()                                    .map(String::toUpperCase);        sorted(Comparator) : 스트릠의 요소를 정렬하여 새로운 스트림 반환    List&lt;Integer&gt; numbers = Arrays.asList(5, 3, 1, 4, 2);Stream&lt;Integer&gt; sortedStream = numbers.stream().sorted();      최종 연산스트림 파이프라인의 결과를 생성한다.스트림의 요소를 실제로 처리하여 결과를 반환하며, 스트림이 종료되고 더 이상 사용할 수 없다. 최종 연산이 호출되면, 중간 연산이 실행된다.- forEach(Consumer&lt; T &gt;)스트림의 각 요소에 대해 주어진 작업 수행List&lt;String&gt; names = Arrays.asList(\"amy\", \"jenny\", \"bob\", \"jun\");names.stream().forEach(System.out::println);- collect(Collector&lt;T, A, R&gt;)스트림의 요소를 수집하여 컬렉션 또는 다른 형태의 결과 생성List&lt;String&gt; names = Arrays.asList(\"amy\", \"jenny\", \"bob\", \"jun\");List&lt;String&gt; collectedNames = names.stream()        .collect(Collectors.toList());- reduce(BinaryOperator)스트림의 요소를 하나로 결합하여 단일 결과 생성List&lt;Integer&gt; numbers = Arrays.asList(5, 3, 1, 4, 2);int sum = numbers.stream()        .reduce(0, Integer::sum);"
  },
  
  {
    "title": "Lambda 와 함수형 인터페이스",
    "url": "/posts/java-lamda/",
    "categories": "Java",
    "tags": "",
    "date": "2024-09-01 00:00:00 +0800",
    





    
    "snippet": "람다 표현식은 자바의 메서드를 하나의 식으로 간결하게 표현한 것 이다.이전에는 자바에서 메서드를 표현하려면 클래스를 정의해야 했다. 하지만 자바 8 부터 람다식을 통해 메서드의 이름과 반환값을 생략할 수 있고, 이를 변수에 넣어 코드를 간결하게 한다.int add (int a, int b) {    return a + b; }// 이는 아래와 같이 변...",
    "content": "람다 표현식은 자바의 메서드를 하나의 식으로 간결하게 표현한 것 이다.이전에는 자바에서 메서드를 표현하려면 클래스를 정의해야 했다. 하지만 자바 8 부터 람다식을 통해 메서드의 이름과 반환값을 생략할 수 있고, 이를 변수에 넣어 코드를 간결하게 한다.int add (int a, int b) {    return a + b; }// 이는 아래와 같이 변경할 수 있다.(a, b) -&gt; a + b;(매개변수) -&gt; {함수 본문} 의 형태로,매개 변수가 없는 경우 () 를 사용하고, 매개 변수가 하나 인 경우 괄호를 생략할 수 있으며, 함수의 본문이 하나인 경우 중괄호와 return을 생략할 수 있다.// 매개변수가 없고, 표현식이 하나() -&gt; System.out.println(\"hello\"):// 매개 변수가 하나x -&gt; x * x;// 매개변수가 여러 개이고, 본문이 여러 줄(x, y) -&gt; {    int sum = x + y;    return sum;}람다 표현식의 특징1. 간결하다람다 표현식을 사용하면 코드가 간결해진다.// 익명 클래스로 Runnable 구현Runnable r1 = new Runnable() {    @Override    public void run() {        System.out.println(\"Hello, World!\");    }};// 람다 표현식으로 Runnable 구현Runnable r2 = () -&gt; System.out.println(\"Hello, World!\");2. 익명성람다 표현식은 익명함수로, 함수의 이름을 정의하지 않고 사용할 수 있다.  익명 함수란?  이름이 없는 함수로, 익명 함수는 모두 일급 객체이다.일급 객체인 함수는 변수처럼 사용이 가능하며, 매개변수로 전달이 가능하다.3. 타입 추론람다 표현식에서는 컴파일러가 타입을 추론할 수 있기 때문에, 매개변수의 타입을 명시적으로 지정하지 않아도 된다.// 타입 명시Function&lt;String, Integer&gt; stringLength1 = (String s) -&gt; s.length();// 타입 추론Function&lt;String, Integer&gt; stringLength2 = s -&gt; s.length();4. 클로저 지원자신이 선언된 스코프의 변수에 접근할 수 있다.public class LambdaExample {    public static void main(String[] args) {        int number = 10;          Runnable r = () -&gt; System.out.println(number);        r.run();  // 출력: 10    }}5. 고차 함수 지원람다 표현식은 고차 함수를 지원한다. 고차 함수는 다른 함수를 매개변수로 받거나, 함수를 반환하는 함수이다.람다식을 이용하면, 고차 함수를 쉽게 정의하고 사용할 수 잇따.람다 표현식을 사용하여 코드를 더 간결하게 할 수 있다. filter 메서드를 이용해 조건을 나타내는 람다 표현식을 매개변수로 받아 필터링을 쉽게 구현할 수 있다.또한 이런 filter 메서드는 여러 상황에서 재사용할 수 있다. 조건만 다르게 해서 재사용할 수 있기 때문에, 코드의 중복이 줄고 유지보수가 쉽다.컬렌션의 필터링, 매핑, 집계 등 여러 작업을 람다를 이용해서 간결하게 처리할 수 있으며, 재사용성을 높인다.import java.util.function.Function;public class LambdaExample {    public static void main(String[] args) {        Function&lt;Integer, Function&lt;Integer, Integer&gt;&gt; add = x -&gt; y -&gt; x + y;        System.out.println(add.apply(2).apply(3));  // 출력: 5    }}6. 병렬 처리 가능import java.util.Arrays;import java.util.List;public class LambdaExample {    public static void main(String[] args) {        List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);        // 병렬 처리        list.parallelStream()            .filter(n -&gt; n % 2 == 0)            .forEach(System.out::println);    }}7. 함수형 인터페이스 구현함수형 인터페이스는 하나의 추상 메서드를 갖는 인터페이스이다.public class FunctionalInterfaceExample {   public static void main(String[] args) {      MyFunctionInterface add = (a, b) -&gt; a + b;      System.out.println(add.execute(5, 3));   }}// 함수형 인터페이스 정의@FunctionalInterfaceinterface MyFunctionInterface {   int execute(int x, int y);}인터페이스에 추상 메서드가 여러 개라면?함수형 인터페이스는 추상 메서드를 하나만 갖는 인터페이스이다. 이 추상 메서드는 람다표현식을 사용하여 구현할 수 있다.추상 메서드가 여러 개인 인터페이스의 경우 함수형 인터페이스가 아니기 때문에 람다 표현식으로 구현할 수 없다.만약 여러 개의 메서드가 필요한 경우에는 각각의 메서드를 분리하여 함수형 인터페이스로 만들어야 한다.@FunctionInterfaceinterface FunctionInterface {   void execute();}public class Example {   public static void main(String[] args) {      FunctionInterface function = () -&gt; Systemout.println(\"hello\");      function.execute();   }}8. 기존 인터페이스와 호환자바에서 제공하는 함수형 인터페이스에는 Runnable, Function, Predicate, Consumer, Supplier, Callable 등이 있다.◾️ Runnable스레드를 실행하기 위한 함수형 인터페이스◾️ Function&lt;T, R&gt;  T 타입의 매개변수를 입력 받아, R을 리턴하는 함수형 인터페이스  R apply (T t)    Function&lt;String, Integer&gt; lengthFunction = s -&gt; s.length;int length = lengthFunction.apply(\"Hello\");        입력을 받아서 출력으로 변환하며, 주로 변환 작업에 사용된다.  ◾️ Predicate&lt; T &gt;  T타입의 매개변수를 입력 받아, 조건 검사 후 boolean 값을 반환하는 함수형 인터페이스  boolean test(T t)    Predicate&lt;String&gt; isEmpty = s -&gt; s.isEmpty();boolean result = isEmpty.test(\"\"); // true        입력값에 대해 boolean 값을 반환하며, 조건 검증에 사용한다.  ◾️ Consumer&lt; T &gt;  T타입의 입력을 받아 동작을 수행한 후, 결과를 반환하지 않는 함수형 인터페이스이다.  void accept(T t)    Consumer&lt;String&gt; str = i -&gt; System.out.println(i);print.accept(\"Hello, World!\");        입력을 받아서 동작을 수행하며, 결과를 반환하지 않는다.  ◾️ Supplier&lt; T &gt;  매개변수 없이 T타입의 값을 반환하는 함수형 인터페이스로 객체를 생성하거나 값을 제공한다.  T get()    Supplier&lt;Integer&gt; randomSupplier = () -&gt; (int) (Math.random() * 100);int randomValue = randomSupplier.get(); // 임의의 정수 반환        매개 변수를 받지 않고, 값을 생성하거나 제공한다.  "
  },
  
  {
    "title": "Event-Driven Architecture",
    "url": "/posts/java-event-driven/",
    "categories": "Java",
    "tags": "",
    "date": "2024-08-29 00:00:00 +0800",
    





    
    "snippet": "일반적으로 API는 클라이언트가 요청한 값에 대해서 응답을 제공한다.클라이언트(웹 애플리케이션, 모바일 앱, 서버)가 특정 데이터를 요청하면, API는 그 요청에 알맞은 데이터를 반환한다.API는 클라이언트의 요청에 대해서만 응답을 반환하며, 클라이언트의 요청 없이 API가 데이터를 보내지 않는다.하지만 API가 클라이언트의 요청 없이 데이터를 보내야...",
    "content": "일반적으로 API는 클라이언트가 요청한 값에 대해서 응답을 제공한다.클라이언트(웹 애플리케이션, 모바일 앱, 서버)가 특정 데이터를 요청하면, API는 그 요청에 알맞은 데이터를 반환한다.API는 클라이언트의 요청에 대해서만 응답을 반환하며, 클라이언트의 요청 없이 API가 데이터를 보내지 않는다.하지만 API가 클라이언트의 요청 없이 데이터를 보내야 하는 상황이 있다. (이벤트, 실시간 알림 등)API가 클라이언트의 요청 없이 데이터를 주도적으로 전달하기 위해 훅, 서버-사이드 이벤트(SSE), 웹소켓, 푸시 알림, 폴링/롱 폴링과 같은 기술들이 개발되었다. 이러한 기술은 클라이언트와 서버 간의 실시간 통신, 효율적인 데이터 전달, 그리고 더 나은 사용자 경험을 제공한다.API가 클라이언트의 요청없이 데이터를 보내는 경우1. 실시간 알림 시스템  사용자가 메시지를 받았거나, 중요한 업데이트가 발생했을 때 이를 실시간으로 전송한다.  채팅 애플리케이션, 이메일 알림, 소셜미디어 알림2. 실시간 데이터 스트리밍  실시간 스포츠 경기 데이터처럼 실시간으로 변동되는 데이터를 클라이언트가 지속적으로 받아야하는 경우  주식 가격이나 환율이 실시간으로 변동할 때, 클라이언트에게 즉시 해당 데이터를 제공한다.3. 자동회된 작업 처리  시스템에서 특정 조건이 만족되거나 이벤트가 발생했을 때, 자동으로 클라이언트에 데이터를 보내야 하는 경우  주문이 완료되었을 때, 결제 시스템이 자동으로 클라이언트에게 영수증을 전송하는 경우  백엔드 서버에서 데이터가 업데이트되었을 때, 관련 데이터를 자동으로 다른 서비스나 클라이언트에게 전달한다.4. 상태 변화 모니터링  시스템의 상태가 변할 때 이를 즉시 클라이언트에 알려야 하는 경우  서버의 상태가 정상에서 오류로 변경되었을 때, 이를 실시간으로 모니터링 시스템에 알린다.5. 트리거 기반 워크플로우  특정 이벤트가 발생하면 워크플로우를 자동으로 시작하고, 그에 따라 클라이언트에게 데이터를 보내야하는 경웹훅(Webhook)서버가 특정 이벤트를 발생시켰을 때, 미리 정의된 url로 http 요청을 보내는 방식클라이언트가 서버에 따로 요청을 보내지 않아도 서버가 클라이언트에 데이터를 전송할 수 있다.  결제 완료, 사용자 등록, 데이터베이스 업데이트 등이 발생할 때 웹훅을 통해 관련 정보를 클라이언트에 전송한다.  클라이언트는 서버에 웹훅 URL을 등록하고, 서버는 특정 이벤트 발생 시 해당 URL로 HTTP POST 요청을 보낸다.서버-사이드 이벤트(Server-Sent Events, SSE)서버가 클라이언트에 실시간 데이터를 지속적으로 스트리밍 하는 방식클라이언트가 한 번 서번에 연결을 맺으면, 서버는 클라이언트가 연결을 끊지 않는 한 실시간으로 데이터를 계속해서 전송할 수 있다.  실시간 주식 가격 업데이트, 뉴스 피드, 실시간 알림 등  클라이언트는 서버와 연결을 맺고, 서버는 그 연결을 통해 실시간으로 데이터를 전송한다. 주로 HTTP 프로토콜을 사용하며, 클라이언트는 이벤트를 수신한다.웹소켓(WebSocket)클라이언트와 서버 간의 실시간 양방향 통신을 가능하게 하는 프로토콜연결이 한 번 성립되면, 클라이언트와 서버는 서로 데이터를 자유롭게 주고받을 수 있다.  실시간 채팅 애플리케이션, 실시간 게임, 협업 도구 등  클라이언트와 서버가 처음에 핸드셰이크를 통해 웹소켓 연결을 맺으면, 이후 양방향 데이터 전송이 가능하다.푸시 알림(Push Notifications)모바일 애플리케이션에서 많이 사용되는 방식으로 서버가 클라이언트(모바일)에 알림을 푸시하는 방식푸시 알림은 서버가 클라이언트의 상태에 따라 메시지를 보낸다.  메시지 알림, 새 콘텐츠 업데이트 알림 등  푸시 서버를 통해 클라이언트에 알림을 전달한다. 클라이언트는 푸시 토큰을 서버에 등록해두고, 서버는 해당 토큰을 사용해특정 클라이언트에 알림을 보낸다.폴링(Polling)과 롱 폴링(Long Polling)클라이언트가 주기적으로 서버에 데이터를 요청하는 방식폴링은 클라이언트가 정해진 간격으로 서버에 요청을 보내고, 롱 폴링은 서버가 새로운 데이터가 있을 때까지 응답을 지연시킨 뒤클라이언트에 응답을 보낸다.  실시간 알림에 사용되나 비효율적  클라이언트가 정해진 주기로 서버에 요청을 보내거나, 롱 폴링에서 클라이언트가 요청을 보내고 서버가 새 데이터가 생길 때까지 응답을 기다린 후 데이터를 보낸다.위의 기술들은 클라이언트와 서버 간의 실시간 통신, 효율적인 데이터 전달, 그리고 더 나은 사용자 경험을 제공하기 위해 등장했으며, 이벤트 드리븐 방식으로 처리한다.Event-Driven Architecture분산된 애플리케이션 서비스들이 이벤트를 기반으로 통신하고 서로의 동작을 야기하는 패턴이벤트 처리 과정Event  시스템 내에서 발생하는 중요한 사건이나 상태 변화  버튼 클릭, 스크롤, 데이터베이스에 새로운 항목 추가, 특정 시간에 도달 등등Event Source  시스템 내에서 중요한 상태 변화, 이벤트 감지  특정 비즈니스 이벤트를 트리거한다.  사용자의 행동(클릭, 입력), 시스템 내의 상태 변화(파일 생성, 데이터 업데이트) 등Event Producer  이벤트 소스가 감지한 상태 변화, 동작을 바탕으로 이벤트 메시지 생성한다.  에빈트를 준비하고 발행한다.  데이터베이스에서 새로운 레코드가 생성되거나, 사용자 애플리케이션에서 특정 역할을 수행했을 때 이벤트 프로듀서가 이벤트 메시지를 생성한다.Event Emitter  이벤트 프로듀서가 생성한 이벤트 메시지를 시스템 내에서 전파한다.  이벤트 메시지를 이벤트 브로커나 이벤트 버스로 전달한다.Event Message  이벤트에 관한 정보를 담고 있는 데이터 구조  이벤트의 유형과 관련된 데이터를 포함한다.  이벤트에 대한 정보를 포함하며, 시스템 내 다른 컴포넌트들이 이 정보를 통해 작업을 수행한다.  구성요소  이벤트 타입 : 이벤트의 종류 (OrderCreated, UserSignUp)페이로드 : 이벤트와 관련된 데이터 (주문 ID, 사용자 정보)메타데이터 : 이벤트 발생 시간, 위치, 우선 순위 등 부가 정보Event Broker/ Message Queue  이벤트 메시지를 수신하고, 이를 관리하여 등록된 이벤트 소비자에게 전달한다.  메시지 큐는 이벤트를 일시적으로 저장하고, 차례로 소비자에게 전달한다.  이벤트 프로듀서와 이벤트 컨슈머 간의 비동기적 통신을 가능하게 한다.  Event Producer 큐에 이벤트 메시지를 넣고, Event Consumer 큐에서 메시지를 꺼내 처리한다.  Apache Kafka, RabbitMQ, Amazon SQS.Event Bus  이벤트 메시지를 발행하고, 여러 Event Consumer에 전달한다.  애플리케이션 내에서 이벤트를 라우팅하고 관리한다.  대규모 마이크로서비스 아키텍처에서 여러 서비스가 이벤트 버스를 통해 서로 이벤트를 주고 받는다.Event Consumer  이벤트 메시지를 수신하고 그에 맞는 작업을 수행한다.  Consumer은 특정 이벤트에 대해 등록되어 있으며, 이벤트가 발생하면 이를 처리한다.  주문이 생성되면, 주문 처리 서비스가 그 이벤트를 받아 결제 처리를 한다.Event Stream  연속적으로 발생하는 이벤트를 시간 순서대로 기록하는 로그 또는 데이터 구조  스트림에서 발생한 이벤트들을 순차적으로 처리하며, 실시간 데이터 처리에 유용한다.  Apache Kafka와 같은 시스템에서 이벤트 스트림을 관리하며, 실시간 데이터 파이프라인을 구축한다.동작 방식1. 이벤트 발생  특정 조건이나 사용자 행동을 인해 이벤트가 발생한다.2. 이벤트 생성  이벤트 프로듀서가 상태 변화에 대한 이벤트 메시지를 생성한다.3. 이벤트 전파  이벤트 프로듀서가 생성한 이벤트 메시지를 이벤트 브로커나 이벤트 버스로 전송한다.4. 이벤트 전달  이벤트 브로커, 메시지 큐는 이벤트 메시지를 수신하고, 이를 관리하여 등록된 이벤트 소비자에게 전달한다.  이벤트 버스는 이벤트 메시지를 애플리케이션 내에서 라우팅하고, 여러 Consumer에 전달한다.5. 이벤트 처리  이벤트 소비자가 이벤트 메시지를 수신한 후, 그에 맞는 작업을 수행한다.  주문이 생성되었을 때 결제를 처리하거나, 이메일을 전송하는 작업이 이루어질 수 있다.6. 후속 작업  하나의 이벤트의 처리 결과로 다른 이벤트가 발생할 수 있으, 추가적인 이벤트가 발생할 수 있다.  결제가 완료되면 ‘결제완료’ 이벤트가 발생하고, 이를 기반으로 배송 시스템에서 작업이 시작될 수 있다.특징1. 비동기성 및 비차단 I/O이벤트 드리븐 모델은 비동기로 동작하ㅏ기 때문에, 작업이 완료될 때까지 프로그램이 대기하지 않고 다른 작업을 수행할 수 있다. 따라서 시스템 자원을 낭비하지 않고 다른 작업을 처리할 수 있다.2. 높은 동시성 처리이벤트 드리븐 모델은 많은 동시 연결을 할 수 있다. 수천 개 이상의 동시 연결을 단일 스레드로 처리할 수 있기 때문에 확장성이 뛰어나다.스레드 기반 모델의 경우 각 연결에 대해 별도의 스레드를 생성하기 때문에 많은 연결이 발생할 경우 스레드 관리가 복잡해지고 리소스 소모가 커진다.3. 반응성 및 사용자 경험UI 애플리케이션에서 사용자 입력에 즉각적으로 반응하여 빠른 응답을 제공하기 때문에 사용자 경험 반응성을 높일 수 있다.4. 복잡한 상태 관리 용이상태 기계와 같은 구조를 사용하여, 다양한 상태에서 발생하는 여러 이벤트를 효율적으로 처리할 수 있다.5. 예측 가능성각 이벤트에 대한 처리가 예측이 가능하기 때문에, 시스템과 신뢰성과 유지보수성을 높일 수 있다.장단점  비동기적으로 처리하기 때문에, 시스템이 더 많은 이벤트를 처리할 수 있다. (확장성)  이벤트 처리 로직을 분리하여, 새로운 기능을 추가하거나 변경할 때 기존 시스템에 영향을 최소화할 수 있다. (유연성)  이벤트 발생 즉시 반응할 수 있어 실시간 시스템에 용이하다.  이벤트의 흐름을 추적하고 디버깅이 어려우며, 이벤트가 여러 시스템에 걸쳐 발생할 때 복잡도가 증가한다.  비동기 처리로 인해 데이터의 일관성을 유지하기 어려우며, 추가적인 설계, 관리가 필요할 수 있다.  이벤트나 버스의 관리 및 유지보수에 추가적인 리소스가 필요하기때문에 오버헤드가 발생할 수 있다.사용 사례  사용자 인터페이스 : 버튼 클릭, 마우스 이동 등 사용자 입력에 반응하는 작업을 처리한다.  실시간 애플리케이션 : 채팅 애플리케이션, 실시간 알림 등에서 이벤트를 기반으로 데이터를 전송한다.  마이크로서비스 아키텍처 : 각 서비스가 독립적으로 이벤트를 발생시키고 이를 다른 서비스가 수신하여 처리한다.  IoT 시스템 : 센서 데이터가 변경되거나 특정 조건이 충족될 때 이벤트를 발생시키고, 그에 대응하는 작업을 한다.MSA와의 관계마이크로서비스 아키텍처는 애플리케이션을 여러 개의 독립적인 서비스로 분리하는 설계 패턴으로 각 서비스는 특정 비즈니스 기능을 담당하며, 독립적으로 배포, 확장, 유지보수가 가능하다.이벤트 드리븐 아키텍처는 마이크로 서비스 간 통신을 효과적으로 관리하는 데 유용하다.서비스 간의 결합도를 낮추고, 서비스들이 더 독립적으로 동작하도록 한다."
  },
  
  {
    "title": "DB Lock",
    "url": "/posts/java-dblock/",
    "categories": "Java",
    "tags": "",
    "date": "2024-08-29 00:00:00 +0800",
    





    
    "snippet": "Concurrency여러 작업이 동시에 실행되는 것처럼 보이도록 관리되는 상태하나의 CPU에서 여러 작업이 실행될 때, CPU는 빠르게 작업을 전환하여 마치 여러 작업이 동시에 실행되는 것처럼 보이게 한다.동시성을 활용하면 프로그램의 여러 부분이 동시에 실행되어, 더 많은 작업을 빠르게 처리할 수 있고, 자원을 효율적으로 사용하며,응답을 향상시킬 수 ...",
    "content": "Concurrency여러 작업이 동시에 실행되는 것처럼 보이도록 관리되는 상태하나의 CPU에서 여러 작업이 실행될 때, CPU는 빠르게 작업을 전환하여 마치 여러 작업이 동시에 실행되는 것처럼 보이게 한다.동시성을 활용하면 프로그램의 여러 부분이 동시에 실행되어, 더 많은 작업을 빠르게 처리할 수 있고, 자원을 효율적으로 사용하며,응답을 향상시킬 수 있다.특히 데이터베이스는 다수의 사용자가 동시에 접근한다. 이 과정에서 사용자에 대한 제어가 적절하게 이루어지지 않으면 데이터의 일관성과 무결성이 깨지게 된다.따라서 동시성 제어를 통해 여러 사용자가 동시에 여러 개의 트랜잭션을 수행 때, 데이터의 일관성이 깨지지 않도록 해야한다.락의 범위DB, 파일, 테이블, 페이지, 컬럼 등낙관적 락 (Optimistic Lock)자원에 락을 걸지 않고, 동시성 문제가 발생하면 그때 그때 처리하는 방식수정 작업을 할때 수정했다고 명시하여 다른 트랜잭션이 동일한 조건으로 값을 수정할 수 없도록 한다.version과 같은 별도의 컬럼을 추가하여 충돌의 발생을 막는다.version(hashcode/ timestamp)의 상태로 충돌을 확인하며, 충돌된 경우 롤백한다.데이터 충돌이 자주 일어나지 않을 것이라고 예상되는 경우 주로 사용한다.조회 작업이 많기 때문에 동시 접근 성능이 중요하다.장단점충돌이 안난다는 가정하에, 동시 요청에 대한 처리 성능이 좋다.그러나 충돌이 빈번하게 일어나는 경우, 롤백처리에 대한 비용이 많이 들어 성능이 떨어질 수 있다.또한, 개발자가 직접 롤백을 구현해야하기 때문에 시스템 구조에 따라 복잡해질 수 있다.비관적 락 (Pessimistic Lock)공유 자원에 접근할 때, 데이터 충돌이 발생할 가능성을 미리 고려하고 이를 방지하기 위해자원에 대해 락을 미리 거는 방법하나의 트랜잭션이 자원에 접근시 락을 걸고, 다른 트랜잭션이 접근하지 못하게 하여 조회 또는 갱신 처리가 완료될 때까지 락을 유지한다.  Shared Lock(공유, 읽기 잠금)  Exclusive Lock(배타, 쓰기 잠금)충돌이 자주 발생하는 상황에 유리하며 데이터의 무결성을 보장한다. 하지만 조회 작업이 많은 경우 성능이 떨어지고,서로 자원이 필요한 경우 데드락에 걸릴 가능성이 있다.따라서, 조건을 추가하여 대기시간을 주거나 예외 처리를 할 수 있다.  NO WIAT  잠금을 획득하지 못하면 바로 예외를 발생시킨다. 트랜잭션은 다른 트랜잭션의 잠금이 해제될 때까지 대기하지 않고, 바로 실패한다. 즉각 적인 실패 응답이 필요한 경우 사용  WAIT[n]  트랜잭션이 잠금을 요청했을 때, 해당 자원이 잠겨있는 경우, 최대 n 초 동안 대기한다.n 초 동안 잠금이 해제되지 않으면 예외가 발생하며 트랜잭션이 실패한다.트랜잭션이 시작될 때 Shared Lock 또는 Exclusive Lock을 걸고 시작한다.공유 락 (Shared Lock, Read Lock)특정 자원에 대해 여러 트랜잭션이 동시에 읽기 작업을 수행할 수 있도록 허용하는 락여러 트랜잭션이 동시에 접근하여 데이터를 읽을 수 있지만, 쓰기 작업은 제한된다. 주로 데이터 읽기의 동시성을 높이기 위해사용하며, 어떤 자원에 공유락이 동시에 여러 개 적용될 수 있다.일반적으로 select 할 때 공유락이 발생하며, 어떤 자원이 공유락에 걸려있는 경우 베타적 락을 걸 수 없다.공유락의 특징  동시 읽기 허용공유락이 설정된 자원은 여러 트랜잭션이 동시에 읽을 수 있다. 데이터를 읽는 작업이 병렬로 수행되기 때문에 성능이 향상된다.  쓰기 제한공유락이 설정된 자원에 대해 다른 트랜잭션이 쓰기 작업을 수행하려고 하면그 트랜잭션은 공유락이 해제될 때까지 대기해야 한다.데이터를 일관되게 유지하고, 읽기 중인 데이터가 변경되지 않도록 보장한다.  락 충돌만약 한 트랜잭션이 공유락을 걸고 데이터를 읽고 있을 때, 다른 트랜잭션이 해당 자원에 배타락을 걸려고 시도하면 충돌이 발생한다.이 경우 쓰기 작업은 공유락이 해제될 때까지 대기한다.  데이터 일관성 유지공유락은 트랜잭션이 데이터를 읽는 동안 해당 데이터가 다른 트랜잭션에 의해 변경되지 않도록 보호한다.공유락의 장단점여러 트랜잭션이 동시에 데이터를 읽을 수 있어 읽기 작업의 효율성이 높으며, 데이터를 읽는 동안 데이터의 일관성을 유지할 수 있다.그러나 여러 트랜잭션이 공유락을 설정한 상태엣서는 쓰기 작업을 기다려야 하기 때문에 성능저하가 발생할 수 있다.또한 데드락이 발생할 수 있다.배타 락 (Exclusive Lock, Write Lock)특정 자원(데이터, 행, 테이블 등)에 대해 하나의 트랜잭션이 독점적으로 접근할 수 있도록 설정하는 락배타락이 걸린 자원에는 다른 트랜잭션이 읽기, 쓰기 작업을 수행할 수 없다.SELECT * FROM Member WHERE id = 1 FOR UPDATE;배타락을 설정하기 위해 사용하는 구문이며, 해당 데이터에 쓰기락을 걸어, 다른 트랜잭션이 동시에 그 데이터에 접근, 수정하지 못하도록 한다.배타락의 특징  독점적 접근자원을 잠근 트랜잭션이 자원을 독점적으로 접그할 수 있다. 다른 트랜잭션은 해당 자원이 잠겨있는 동안 접근할 수 없다.  쓰기 작업 보호일반적으로 쓰기(수정, 삭제, 삽입 등) 작업을 수행하기 전에 설정된다.따라서 다른 트랜잭션이 해당 자원을 동시에 수정하지 못하도록 하여 충돌을 방지한다.  동시성 제어데이터를 보호하고 여러 트랜잭션이 동시에 데이터를 처리할 때 발생할 수 있는 문제를 예방한다.  락 대기다른 트랜잭션이 배타락이 걸린 자원에 접근하려고 하면, 해당 트랜잭션은 락이 해제될 때까지대기해야 한다.예를 들어, 은행 시스템에서 특정 계좌의 잔액을 수정하는 트랜잭션이 있다.트랜잭션 A가 계좌의 잔액을 수정하려고 할 때, 먼저 해당 계좌 데이터에 배타락을 설정한다.이때, 트랜잭션 A가 작업을 완료하고 락을 해제할 때까지, 트랜잭션 B는 그 계좌에 접근할 수 없게된다.트랜잭션 A가 작업을 완료한 후 락을 해제하면, 트랜잭션 B가 계좌에 접근할 수 있다.데이터의 무결성과 일관성을 보장하며 충돌을 미리 방지하여 데이터의 손상과 비 일관성을 방지한다.그러나 자원이 락이 걸린 동안 다른 트랜잭션이 대기해야 하므로 성능 저하가 발생할 수 있으며,대기 시간이 길어질 경우, 데드락의 가능성이 증가한다.배타락의 장단점데이터의 무결성과 일관성을 보장하며, 충돌을 사전에 방지하기 때문에 데이터의 손상과 비일관성을 방지할 수 있다.그러나 자원이 락에 걸린 동안 다른 트랜잭션이 대기해야하기 때문에 성능 저하가 발생할 수 있으며, 대기 시간이 길어질 경우 데드락의 가능성이 증가한다."
  },
  
  {
    "title": "Socket",
    "url": "/posts/java-socket/",
    "categories": "Java",
    "tags": "",
    "date": "2024-08-27 00:00:00 +0800",
    





    
    "snippet": "자바의 소켓은 네트워크 상에서 데이터를 주고 받기 위한 통신 채널을 제공하는 프로그래밍 인터페이스이다.소켓은 TCP/IP나 UDP같은 프로토콜을 사용하여 네트워크에 연결된 두 프로그램 사이에서 데이터를 송수신할 수 있도록 한다.이를 통해 자바 프로그램 간, 또는 자바 프로그램과 다른 시스템 간에 통신할 수 있다.Socket소켓은 TCP/IP 기반의 네...",
    "content": "자바의 소켓은 네트워크 상에서 데이터를 주고 받기 위한 통신 채널을 제공하는 프로그래밍 인터페이스이다.소켓은 TCP/IP나 UDP같은 프로토콜을 사용하여 네트워크에 연결된 두 프로그램 사이에서 데이터를 송수신할 수 있도록 한다.이를 통해 자바 프로그램 간, 또는 자바 프로그램과 다른 시스템 간에 통신할 수 있다.Socket소켓은 TCP/IP 기반의 네트워크 통신에서 데이터 송수신의 마지막 접점으로 IP주소와 포트 번호를 결합한 것이다.  IP 주소 : 통신 대상의 주솟  포트 번호 : 특정 애플리케이션이 사용하는 네트워크 포트네트워크를 통해 두 컴퓨터 간의 데이터 통신을 하고, 클라이언트와 서버 간의 연결을 관리한다.클라이언트가 서버에 연결 요청을 보내고, 서버가 이 요청을 수락하면 데이터 전송이 시작된다.지속적으로 연결을 유지하며 실시간으로 데이터를 주고 받는다.클라이언트와 서버로 구분되며, 네트워크 상에서 클라이언트와 서버에 해당하는 컴퓨터를 식별하기 위해 IP 주소와 해당 컴퓨터 내에서 현재 통신에 사용되는 응용프로그램을 식별하기 위한 포트번호가 사용된다.Server데이터 제공Client데이터를 요청하여 제공받는 쪽주요 클래스Socket  클라이언트가 서버에 연결할 때 사용하는 클래스  클라이언트가 서버에 연결을 요청한 후, 서버에서 수락하면 통신이 가능하다.  소켓 객체를 생성하면 서버와의 연결이 즉시 이루어진다.  이후 입력 스트림과 출력 스트림을 통해 데이터를 송수신한다.    Socket socket = new Socket(\"서버 IP 주소\", 포트 번호);      ServerSocket  서버가 클라이언트의 연결을 기다릴 때 사용되는 클래스  서버는 특정 포트에서 클라이언트의 연결 요청을 수신한다.  연결이 수락되면 Socket 객체를 생성하여 통신을 시작한다.  accept()메서드를 호출시 클라이언트와의 연결을 수락하고, Socket 객체를 반환한다.    ServerSocket serverSocket = new ServerSockekt(포트번호);Socket socket = serverSocket.accept();   // 클라이언트 연결 수락      InputStream/ OutputStream  소켓을 통해 데이터를 주고 받기 위한 스트림  소켓이 연결되면, 이 스트림을 통해 데이터를 읽고 쓰는 작업을 한다.  바이트 단위InputStream input = socket.getInputStream();  // 소켓에서 입력 스트림을 가져옴BufferedReader reader = new BufferedReader(new InputStreamReader(input));String message = reader.readLine() // 데이터를 읽음OutputStream output = socket.getOutputStream();  // 소켓에서 출력 스트림을 가져옴PrintWriter writer = new PrintWriter(output, true);writer.println(\"Hello, Server!\");  // 데이터를 보냄  바이트 단위로 데이터를 처리하며, 텍스트, 이미지, 파일과 같은 데이터를 전송할 때 사용된다.  텍스트 데이터를 다루는 경우 InputStreamReader(), OutputStreamWriter를 사용하여 바이트 스트림을 문자 스트림으로 변환할 수 있습니다.InetAddress  IP 주소를 다루는 클래스  네트워크에서 호스트의 IP 주소를 얻거나, 호스트 이름을 IP 주소로 변환한다.InetAddress.getByName(String host)주어진 호스트 이름을 IP 주소로 변환한다.InetAddress address = InetAddress.getByName(\"www.naver.com\");InetAddress.getLocalHost()로컬 컴퓨터의 IP  주소를 가져온다.InetAddress localAddress = InetAddress.getLocalHost();InetAddress.getByAdderss(byte[] addr)주어진 바이트 배열로부터 IP 주소 생성클라이언트와 서버 간의 연결      ServerSocket 생성 후 대기서버가 ServerSocket 를 생성 후, accept() 메서드를 호출하여 클라이언트의 연결 요청을 대기한다.        클라이언트 측 설정 후 연결 요청클라이언트는 서버의 IP 주소와 포트 번호로 Socket 객체를 생성하고, 서버에 연결을 요청한다.        서버에서 연결 수락서버는 클라이언트의 연결 요청을 수락하고, 연결된 클라이언트와 통신하기 위해 Socket 객체를 생성한다.        데이터 송수신클라이언트와 서버는 InputStream, OutputStream을 사용하여 데이터를 주고 받는다.        연결 종료통신이 끝나면 클라이언트와 서버는 각각 소켓을 닫아 연결을 종료한다.  데이터 처리소켓을 통해 데이터를 주고받는 과정에서 데이터를 적절한 형식으로 변환하고 수신 후, 원래의 형식으로 변환하는 작업이 필요하다.이 과정을 패킹, 언패킹이라고 한다.패킹 Packing전송 전 데이터를 바이트 배열이나 스트림으로 변환하는 과정  텍스트 데이터String message = \"Hello\";byte[] data = message.getBytes(message);outputStream.write(data);  객체 데이터객체를 전송하는 경우, 객체를 직렬화한 후, 바이트 배열로 변환한다.  ObjectOutputStream을 사용하여 객체를 직렬화한다.ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());oos.writeObject(myObject);언패킹 Unpacking수신된 바이트 데이터를 원래 형식으로 변환하는 과정  텍스트 데이터byte[] buffer = new byte[1024];  // 수시할 데이터를 담을 버퍼int bytesRead = inputStream.read(buffer);   // 읽은 바이트 수 반환String receivedMessage = new String(buffer, 0, bytesRead, \"UTF-8\");  buffer : 수신된 바이트 데이터가 저장된 배열  0 : 바이트 배열의 시작 위치  bytesRead : 실제로 읽어들인 바이트 수  UTF-8 : 데이터가 UTF-8 인코딩으로 전송되었음을 가정하고 변환  객체 데이터 직렬화된 객체를 수신한 경우, 역직렬화를 통해 원래 객체로 복원한다.ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());MyObject myObject = (MyObject) ois.readObject();예외IOException  데이터 전송 중 연결이 끊어지거나, 네트워크 오류가 발생하는 경우  서버가 다운되거나, 클라이언트와 연결이 갑자기 끊어지는 경우 발생한다.SocketTimeoutException  소켓에서 데이터 수신을 대기하는 동안 일정 시간 내에 응답이 없는 경우 발생한다.  소켓에서 타임아웃을 설정할 수 있으며, 타임아웃이 지나면 예외가 발생한다.UnknownHostException잘못된 호스트 이름이나 IP주소를 사용하여 소켓을 생성할 때 발생  호스트 이름을 사용하여 소켓을 생성할 때, 도메인 이름이 잘못되었거나 존재하지 않는 경우 발생한다.  도메인 이름을 IP 주소로 변환하는 DNS 서버에 문제가 있거나, 네트워크 연결이 끊어지는 경우 발생할 수 있다.  소켓을 생성하기 전 호스트 이름으 유효한지 검증하는 방법을 통해 예방할 수 있다.  InetAddress클래스를 사용하여 도메인 이름이 IP 주소로 변환될 수 있는지 미리 확인할 수 있다.try {    InetAddress address = InetAddress.gettByteName(\"invalid.com\");    Socket socket = new Socket(address, 8080);} catch (UnknownHostException e) {    System.out.println(\"Invalid host name: \" + e.getMessage());}네트워크 연결이 정상적인지, DNS 서버가 올바르게 동작하는지 확인해야 한다.BindException  서버 소켓이 이미 사용 중인 포트에 바인딩하려고 할 때 발생한다.  리눅스/유닉스 기반 시스템에서 권한이 없는 사용자가 1024 이하의 포트 번호에 바인딩하려고 할 때 발생할 수 있다.  서버 소켓을 생성하기 전에 해당 포트가 이미 사용 중인지 확인하여, 다른 포트를 사용하거나, 사용 중인 포트를 해제한 후 포트를 사용할 수 있다.try {    ServerSocket serverSocket = new ServerSocket(8080);} catch (BindException e) {    System.out.println(\"Port 8080 is already in use. Please choose another port.\");    // 다른 포트를 선택하거나, 현재 사용 중인 포트를 해제 후 재시도 로직 추가}1024 이하의 포트를 사용하는 경우, 관리자 권한으로 프로그램을 실행하거나, 관리자 권한을 부여 받을 수 있다.EOFException클라이언트나 서버가 데이터를 더 이상 전송하지 않는 경우 발생한다.  스트림의 끝을 만나는 경우 발생ClassNotFoundException  객체를 역렬화할 때, 해당 클래스가 현재 클래스패스에 존재하지 않는 경우 발생  주로 네트워크 통신에서 클라이언트와 서버 간의 클래스 버전이 일치하지 않거나 클래스가 누락된 경우 발생한다.  동일한 클래스를 포함한 JAR 파일을 클라이언트와 서버에 모두 배포하여 버전 불일치 문제를 방지한다.  만약 클라이언트와 서버의 환경이 다른 경우, 서버에서 클라이언트로 클래스 파일을 전송하거나, 클래스 로더를 사용해 동적으로 로드할 수 있는 방법을 고려해야 한다.구현public class Socket_Server {    public static void main(String[] args) {        BufferedReader br = null;        PrintWriter pw = null;        ServerSocket serverSocket = null;        Socket socket = null;        Scanner sc = new Scanner(System.in);        try {            try {                serverSocket = new ServerSocket(8081);                socket.setSoTimeout(10000);            } catch (BindException e) {                System.out.println(\"Port(8081) is already in use.\");                return;            }            System.out.println(\"[Server] Client 연결 대기 중\");            try {                socket = serverSocket.accept();                socket.setSoTimeout(5000);            } catch (SocketTimeoutException e) {                System.out.println(\"Client connection timed out\");                return;            }            System.out.println(\"Client 연결 성공\");            br = new BufferedReader(new InputStreamReader(socket.getInputStream()));            pw = new PrintWriter(socket.getOutputStream());            while (true) {                try {                    String input = br.readLine();                    if (\"quit\".equalsIgnoreCase(input)) break;                    System.out.println(\"From Client: \" + input);                    System.out.println(\"Send ==&gt; \");                    String output = sc.next();                    pw.println(output);                    pw.flush();                    if (\"quit\".equalsIgnoreCase(output)) break;                } catch (SocketTimeoutException e) {                    System.out.println(\"Socket read Time out\");                } catch (IOException e) {                    System.out.println(\"I/O error occurred while reading or writing data.\");                    break;                } catch (Exception e) {                    System.out.println(\"Unexpected error occurred: \" + e.getMessage());                    e.printStackTrace();                    break;                }            }        } catch (UnknownHostException e) {            System.out.println(\"Unknown host: \" + e.getMessage());        } catch (SocketTimeoutException e) {            System.out.println(\"Server socket timed out while waiting for a client connection.\");        } catch (IOException e) {            System.out.println(\"I/O error occurred during socket setup: \" + e.getMessage());        } catch (Exception e) {            System.out.println(\"Unexpected error occurred: \" + e.getMessage());        }        finally {            try {                sc.close();                socket.close();                serverSocket.close();                System.out.println(\"연결 종료\");            } catch (IOException e) {                System.out.println(\"Error Closing Resources: \" + e.getMessage());            }        }    }}public class Socket_Client {    public static void main(String[] args) {        BufferedReader br = null;        PrintWriter pw = null;        Socket socket = null;        Scanner sc = new Scanner(System.in);        try {            socket = new Socket(\"127.0.0.1\", 8081);            br = new BufferedReader(new InputStreamReader(socket.getInputStream()));            pw = new PrintWriter(socket.getOutputStream());            while (true) {                System.out.println(\"Send ==&gt;&gt; \");                String output = sc.nextLine();                pw.println(output);                pw.flush();                if(\"quit\".equalsIgnoreCase(output)) break;                String input = br.readLine();                System.out.println(\"From Server: \" + input);                if(\"quit\".equalsIgnoreCase(input)) break;            }        } catch (IOException e) {            System.out.println(e.getMessage());        } finally {            try {                sc.close();                if (socket != null) socket.close();                System.out.println(\"서버 연결 종료\");            } catch (IOException e) {                System.out.println(\"소켓 통신 error\");            }        }    }}멀티 채팅서버 소켓이 루프를 돌면서 클라이언트가 연결될 때마다 새로운 스레드를 생성한다.이렇게 생성된 스레드는 클라이언트에서 메세지가 들어올때마다 전체 클라이언트에 브로드캐스트한다."
  },
  
  {
    "title": "프로세스의 상태",
    "url": "/posts/os-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4/",
    "categories": "OS",
    "tags": "",
    "date": "2024-08-20 00:00:00 +0800",
    





    
    "snippet": "Process실행 중인 프로그램CPU에서 명령을 수행하기 위한 데이터와 상태 정보를 포함한다.하나의 프로그램은 여러 개의 프로세스를 가질 수 있고, 각 프로세스는 독립적으로 실행된다.스택, 힙, 데이터, 코드로 구성된다.프로세스 문맥은 운영체제가 프로세스의 실행 상태를 추적하고 관리하기 위해 필요한 정보이디ㅏ.프로세스가 CPU에서 실행되다가 중단될 때...",
    "content": "Process실행 중인 프로그램CPU에서 명령을 수행하기 위한 데이터와 상태 정보를 포함한다.하나의 프로그램은 여러 개의 프로세스를 가질 수 있고, 각 프로세스는 독립적으로 실행된다.스택, 힙, 데이터, 코드로 구성된다.프로세스 문맥은 운영체제가 프로세스의 실행 상태를 추적하고 관리하기 위해 필요한 정보이디ㅏ.프로세스가 CPU에서 실행되다가 중단될 때, 다시 실행될 때 이전과 동일한 상태에서 시작할 수 있도록 한다.문맥전환은 CPU가 한 프로세스의 문맥을 저장하고 다른 프로세스의 문맥을 로드하여 실행을 전환하는 과정을 말한다.Process Conext크게 세 가지(하드웨어 문맥, 프로세스의 주소 공간, 커널 상의 문맥)로 구성된다.하드웨어 문맥은 CPU 수행 상태를 나타내는 것으로 PC와 각종 레지스터에 저장하고 있는 값이다.프로세스의 주소 공간은 코드, 데이터, 스택으로 구성된 프로세스만의 독자적인 주소 공간이다.커널상의 문맥은 프로세스 관리를 위한 PCB와 Kernel stack이다.PCB (Process Control Block)각 프로세스의 문맥을 저장하는 자료 구조로 운영체제가 각 프로세스를 관리하기 위해 사용한다.      Process ID : PID(Process Identification Number) 주로 PID 라고 줄여서 부릅니다. : 프로세스 고유 식별 번호        Process State(프로세스 상태) : 프로세스의 현재 상태(생성, 준비, 실행, 대기, 종료)를 기억 시킵니다.        Program Counter(계수기) : 다음에 실행되는 명령어의 주소를 기억시킵니다.        Process Priority(스케줄링 정보) : 프로세스 우선순위 등과 같은 스케줄링 관련 정보를 기억시킵니다.        CPU Registers : 프로세스의 레지스터 상태를 저장하는 공간 등, CPU 내 범용 레지스터, 데이터 레지스터, 세그먼트 레지스터 등이 갖고 있는 값을 기억시킵니다.        Owner(계정 정보) : CPU 사용시간의 정보(Quantum), 각종 스케줄러에 필요한 정보를 기억시킵니다.        기억장치 관리 정보 : 프로그램이 적재될 기억 장치의 시작 지점(베이스 레지스터), 종료 지점(한계 레지스터), 페이지 테이블 등의 정보를 기억시킵니다.        입출력 정보 : 프로세스 수행 시 필요한 주변 장치, 파일들의 정보를 기억시킵니다  CPU 레지스터프로세스가 실행 중이었던 시점의 CPU 레지스터 값들이 저장된다. 프로그램 카운터와 스택 포인터 등의 레지스터를 포함한다.메모리 관리 정보페이지 테이블, 세그먼트 테이블 등 프로세스가 사용하는 메모리 관련 정보가 포함된다.스택함수 호출 시 전달된 인자, 복귀 주소, 지역 변수 등 저장되는 영역I/O 상태 정보함수 호출 시 전달되는 인자, 복귀 주소, 지역 변수 등이 저장되는 영역Context Switching한 프로세스의 실행을 중단하고 다른 프로세스를 실행할 때 발생      현재 실행 중인 프로세스의 문맥 저장현재 프로세스의 CPU 레지스터 값, 프로그램 카운터, 메모리 상태를 PCB에 저장        다른 프로세스의 문맥 로드다음에 실행할 프로세스의 PCB에서 문맥 정보를 불러와 CPU 레지스터에 로드한다.        프로세스 실행 재개로드된 문맥 정보에 따라 새로운 프로세스가 실행한다.  문맥 전환은 필수적이지만, 자주 발생하는 경우 오버헤드가 발생한다.Context Switching은 언제 발생하는지?  멀티 태스킹 또는 시분할 시스템에서 할당된 시간이 종료된 경우  입출력 또는 시스템 호출  우선순위에 따른 프로세스 스케줄링  프로세스가 종료되는 경우  인터럽트 발생 시  자발적인 CPU 양도프로세스와 스레드는 Cont도ext Switching이 발생 차이프로세스는 code, data, heap, stack 영역을 독립적으로 가지고 있습니다. 따라서 Context Swtiching이 발생할 때, 독립적인 메모리를 포함하여, 캐시 메모리를 비워줘야 해서 스레드에 비해 상대적으로 많은 오버헤드가 발생합니다. 이와 달리 스레드는 code, data, heap 영역을 공유하고 stack 영역만 독립적으로 가지고 있기 때문에, 캐시 메모리를 비우지 않아도 되고 프로세스에 비해 상대적으로 적은 오버헤드가 발생합니다.Context Switching 시 캐시 차이프로세스는 독립적인 메모리 공간을 갖는다. 서로 다른 프로세스 간 문맥 전환이 일어날 때, 이전 프로세스가 사용하던 데이터가 CPU에 남아있을 수 잇따.그러나 새로운 프로세스의 메모리 주소 공간이 다르기 때문에 캐시 데이터는 새로운 프로세스에 대해 무효하다.새로운 프로세스의 데이터를 다시 캐시에 로드해야 되기 때문에, 초기에는 캐시 미스가 발생한다.이로 인해서 CPU가 메모리에서 데이터를 다시 읽어와야 한다.프로세스 간의 문맥 전환 시, TLB도 무효화되기 때문에 새로운 프로세스에 맞는 주소 변환을 다시 로드해야 한다.스레드는 동일한 프로세스 내에서 실행되기 때문에 메모리 공간을 공유한다.같은 프로세스 내의 스레드 간 문맥 전환시 메모리 주소 공간이 동일하기 때문에, 캐시에 저장된 데이터가 유효하다.따라서 캐시 미스가 덜 발생하며, 캐시의 내용을 다시 로드할 필요가 적다.동일한 주소 공간을 공유하기 때문에 TLB도 그대로 유효하다. 그러나 여러 스레드가 캐시를 공유하면서동시에 접근할 경우 캐시 경쟁이 발생할 수 있다.  Translation Lookaside Buffer프로세스의 스레드에 대한 정보PCB는 프로세스의 기본 정보를 관리하는데, 각 프로세스 내의 스레드에 대한 정보를 간접적으로 관리한다.TCP는 스레드 제어 블록으로 스레드의 상태, 레짓스터, 스택 포인터 등을 저장하는 자료구조로, 프로세스의 여러 스레드를 개별적으로 관리한다.프로세스는 공유 메모리를 통해 스레드들이 동일한 주소 공간에 접근하게 하며, 스케줄러는 TCB를 참조하여 스레드의 실행 순서를 정한다.  TCP (Thread Control Block)Thread IDThread StatusCPU 정보 (PC, Register)Thread Priority스레드의 생성을 트리거한 프로세스를 가리키는 포인터스레드에서 만든 스레드를 가리키는 포인터Context Switching 에서 프로세스 수행 중에 입출력 상태로 전환되어서 대기 상태로 전환 되는데, CPU를 어떻게 하는 것이 효율적인가?Context Switching 에서 입출력 인터럽트가 발생하게 되면 실행 상태에 있던 프로세스는 대기 상태로 전환됩니다.이때, CPU 스케줄러에 의해서 해당 프로세스의 자원은 반환됩니다. 이후 CPU가 입출력 인터럽트의 완료를 기다리는 동안 준비 상태 큐에 있는 프로세스 중에서 스케줄링 알고리즘에 따라 실행 상태로 들어가고,대기 상태에 있던 프로세스는 입출력 작업이 완료되게 되면 다시 준비상태 큐로 들어갑니다.인터럽트의 처리 순서CPU는 인터럽트를 우선순위에 따라서 처리한다.PCB의 자료구조PCB는 Doubly Linked List 방식으로 관리된다.PCB의 List Head에 PCB들이 생성될 때마다 붙으며, 주소 값으로 연결이 이루어져 있는 연결리스트이기 때문에 삽입 삭제가 용이합니다.Context Switching 시에 주소공간에 대한 캐시 처리가 어떻게 이루어지는지 설명해주세요.기존의 프로세스들을 메모리에 적재할 때, 순차적으로 적재를 하게 되면 단편화 문제가 발생하는데, 이를 방지하기 위해서 가상 메모리 기법이 생겼고, 가상 메모리 기법은 세그멘테이션과 페이징 기법으로 나눌 수 있다.가상 메모리 기법으로 분할 된 메모리의 페이지들은 페이지 테이블에서 관리를 하게 되는데, 메모리에 실제 주소를 참조하기 위해서는페이지 테이블에 한번 접근(fetch)페이지 테이블을 기반으로 실제 메모리로 접근 (Memory Access)와 같은 과정이 필요한데, 실행할 때마다 같은 table에 속한 메모리 주소를 찾고 다시 메인 메모리에 접근해야 하는 불필요한 일이 발생합니다.이런 메모리의 접근을 줄이기 위해서 TLB가 등장했고, TLB는 page table의 임시저장 캐시 역할을 합니다. TLB는 L3 캐시에 위치해있습니다. 이때 TLB에는 최근에 읽었던 변환될 물리 주소를 매핑해서 저장을합니다. 따라서 TLB를 활용하면 한 프로세스 내의 다른 스레드를 Context Switching 하는 경우 invalid가 발생하지 않아, 주소 공간을 참조하는데 하드웨어 적으로 이점을 볼 수 있고, 프로세스가 Context Switching을 하게 되는 경우, kernel 주소 공간을 제외한 모든 영역을 invalid 하기 때문에, 스레드와 달리 손해를 보게 됩니다.Process StatusNew프로세스가 생성된 상태Ready프로세스가 CPU에 실행되기 위해 대기하는 상태로, CPU자원이 할당되지 않은 상태Running프로세스가 CPU를 할당받아 실제로 실행 중인 상태Waiting프로세스가 특정 자원이나 이벤트를 기다리는 상태Terminated프로세스가 실행이 완료되거나 종료된 상태상태 전이 동작Dispatch우선순위가 높은 프로세스를 선정하여 명령어를 실행한다Timeout클럭이 인터럽트를 발생시켜 제어권을 빼앗는다.(Preemption:독점방지)Block프로세서가 입출력, 자원 등을 기다리기 위해 대기상태로 전환한다.Wake up입출력이 완료되거나 자원이 할당되어 다시 실행한다.Scheduling운영체제는 여러 프로세스가 CPU를 공유할 수 있도록 프로세스를 스케줄링한다.스케줄러는 준비 상태의 프로세스 중 하나를 선택하여 CPU를 할당한다. 프로세스가 작업을 완료하거나 대기 상태로전환되면 다음 프로세스에 CPU를 할당한다."
  },
  
  {
    "title": "ThreadLocal",
    "url": "/posts/java-threadlocal/",
    "categories": "Java",
    "tags": "",
    "date": "2024-08-20 00:00:00 +0800",
    





    
    "snippet": "ThreadLocal각각의 스레드 별로 별도의 저장 공간을 제공하는 컨테이너각 스레드는 자신만의 별도의 데이터를 가질 수 있고, 다른 스레드와 독립적으로 데이터를 설정하고 조회할 수 있다.각 인스턴스는 특정 스레드에 연결되어 있는 데이터를 참조하며 다른 스레드에 영향을 주지 않는다.이를 통해 멀티 스레드 환경에서도 스레드 간 데이터 공유와 동기화 문제...",
    "content": "ThreadLocal각각의 스레드 별로 별도의 저장 공간을 제공하는 컨테이너각 스레드는 자신만의 별도의 데이터를 가질 수 있고, 다른 스레드와 독립적으로 데이터를 설정하고 조회할 수 있다.각 인스턴스는 특정 스레드에 연결되어 있는 데이터를 참조하며 다른 스레드에 영향을 주지 않는다.이를 통해 멀티 스레드 환경에서도 스레드 간 데이터 공유와 동기화 문제를 해결할 수 있다.각 요청마다 사용자 인증 정보를 threadLocal 에 저장하여 스레드 별로 관리할 수 있고, 이를 통해 여러 요청 간 사용자 정보를 명시적으로 전달하지 않고도 사용할 수 있다.또한 데이터베이스 트랜잭션에서 Connection 객체를 ThreadLocal에 저장하여 각 스레드가 독립적으로 데이터베이스 연결을 관리하고, 트랜잭션 내에서 데이터베이스 연결을 공유하여 스레드 간의 충돌을 방지할 수 있.한 번 계산된 결과를 스레드별로 캐시해서 다시 계산하지 않고 재사용할 수 있다.public class ThreadLocalExample {    private static final ThreadLocal&lt;Integer&gt; threadLocalValue = ThreadLocal.withInitial(() -&gt; 0);    public static void main(String[] args) {        Runnable task = () -&gt; {            threadLocalValue.set((int) (Math.random() * 100));            System.out.println(\"Thread local value: \" + threadLocalValue.get());        };        Thread thread1 = new Thread(task);        Thread thread2 = new Thread(task);        Thread thread3 = new Thread(task);        thread1.start();        thread2.start();        thread3.start();        System.out.println(threadLocalValue.get());    }}하지만 메모리 누수를 유발할 수 있으며 ThreadLocal에 저장된 데이터는 스레드가 종료되어도 자동으로 해제되지 않는다. 따라서 사용이 끝난 후 remove() 메서드를 호출해서 데이터를 삭제해야 한다.ThreadLocal 클래스의 initialValue() 메서드ThreadLocal 변수가 처음 사용될 때 호출하며 각 스레드 별로 별도의 초기값을 반환한다.각 스레드가 독립적으로 관리해야 하는 데이터의 초기값을 설정할 때 사용되며 로그인 사용자 정보, 트랜잭션 관리를 위한 초기 상태등을 초기화 한다.스레드 재사용과 remove()데이터를 해제하는 메서드스레드가 재사용되는 겨우 이전에 설정된 데이터가 존재하기 때문에 이전의 데이터와 공유될 수 있다.ThreadLocal 변수의 데이터는 스레드마다 독립적으로 관리되지만, 스레드 풀에서 스레드가 재사용되는 동안여러 스레드가 동시에 같은 변수에 접근하면 데이터의 일관성에 문제가 발생할 수 있다.따라서 remove()를 이용하여 이전의 데이터를 해제해 주어야 한다.사용하지 않는 경우 해당 스레드의 생명 주기 동안 메모리 리소스가 유지되기 때문에 메모리 누수가 발생할 수 있다.또한, 스레드 풀의 사용을 제한할 수 있다. 스레드 풀을 사용하지 않으면 스레드가 작업을 완료한 후 종료되기 때문에 자동으로 ThreadLocal 변수가 제거된.사용자 정의 스레드 팩토리를 사용하여 스레드가 종료될 때 ThreadLocal 변수를 명시적으로 제거할 수 있도록 구현하는 방법도 있습니다.다remove()ThreadLocal의 remove() 메서드를 호출하면, 현재 스레드와 연결된 ThreadLocal 값이 ThreadLocalMap에서 제거됩니다. 이때 변수의 삭제와 관련된 중요한 포인트는 다음과 같습니다:  remove() 메서드 호출 시점실제 동작: remove() 메서드가 호출되면, 현재 스레드에 할당된 ThreadLocalMap에서 해당 ThreadLocal 객체에 대한 참조가 삭제됩니다. 이로 인해 해당 스레드와 연결된 ThreadLocal 값은 더 이상 접근할 수 없게 됩니다.메모리 정리: ThreadLocal에 저장된 값에 대한 참조가 사라지므로, 해당 값은 더 이상 사용되지 않으며, JVM의 Garbage Collector(GC)에 의해 수거될 수 있는 상태가 됩니다. 즉, 메모리에서 실제로 제거되는 시점은 GC가 이 객체를 수거할 때입니다.  실제 메모리에서의 삭제 시점GC에 의해 수거: ThreadLocalMap에서 참조가 제거되면, ThreadLocal 객체와 그 값은 다른 곳에서 참조되지 않는 한 메모리에서 수거될 수 있는 상태가 됩니다. 하지만 실제로 메모리에서 언제 삭제될지는 GC의 작동 시점에 달려 있습니다.강제 수거: 메모리 누수를 방지하기 위해, ThreadLocal.remove()를 호출한 후에는 가능한 ThreadLocal 객체가 가비지 컬렉션 대상이 되도록 강제로 참조를 해제하는 것이 좋습니다.  가비지 컬렉션과의 관계약한 참조(Weak Reference): ThreadLocalMap은 ThreadLocal 키를 약한 참조로 저장합니다. 이는 ThreadLocal 객체가 더 이상 강한 참조를 가지고 있지 않으면 GC에 의해 수거될 수 있음을 의미합니다. 하지만, ThreadLocal에 연결된 값은 여전히 강한 참조로 유지되기 때문에 remove()를 호출해 해당 참조를 해제하지 않으면 메모리 누수가 발생할 수 있습니다.스레드 팩토리스레드 클래스의 run 메서드에섯 ThreadLocal.remove()를 호출하여 스레드 종료 전에 변수를 제거할 수 있다.ThreadFactory 인터페이스를 구현해 새로운 스레드를 생성하고 생성된 스레드에서 remove() 메서드를 호출해 자원의 누수를 방지해야한다. 스레드 풀은 스레드를 재사용하기 때문에 재사용 이전에 ThreadLocal 값이 남아있지 않도록, 사용후 값을 제거해주어야 한다.remove()메서드를 이용하여 변수를 정리하여 메모리 누수를 방지해야 한다.set() 메서드?변수를 제거한 후 해당 변수를 다시 사용하기 위해 set() 메서드를 사용해 새로운 값을 설정할 수 있다.스레드가 종료ThreadLocal 변수를 제거하지 않고도 스레드가 종료될 때 자동으로 제거되는 방법은 스레드가 짧은 생명주기를 갖는 경우에 실행될 수 있습니다. ㅎ스레드가 종료되면 스레드에 바인딩된 ThreadLocal 변수들도 함께 제거된다.단위테스트나 통합 테이스에서도 일반적으로 테스트가 완료되면 종료되기 때문에 제거할 필요가 없다.ThreadLocal.withInitial()초기값을 설정하는 메서드로 변수의 초기화 로직을 간소화할 수 있다.모든 스레드가 동일한 초기값을 갖기 때문에 일관성을 유지할 수 있으며 초기값 설정이 변수 선언과 동시에 일어나기 때문에 코드가 가독성이 좋다.제거한 변수를 다시 사용하려면?1. get() 또는 set() 메서드를 호출하여 초기화get() 메서드 호출remove() 메서드가 호출된 후에 get() 메서드를 호출하면, ThreadLocal 변수는 초기화된다. 만약 ThreadLocal이 기본값 초기화 로직을 가지고 있다면, get() 메서드를 호출할 때 이 로직이 실행되어 새로운 값이 설정된다.만약 초기화 로직이 없다면, get() 메서드는 null을 반환한다.set() 메서드 호출set(T value) 메서드를 사용하여 ThreadLocal 변수에 새로운 값을 명시적으로 설정할 수 있다. 이렇게 하면 해당 스레드에 대해 새로운 값이 할당된다.사용자 정의 스레드 팩토리스레드 클래스의 run 메서드에섯 ThreadLocal.remove()를 호출하여 스레드 종료 전에 변수를 제거할 수 있다.ThreadFactory 인터페이스를 구현해 새로운 스레드를 생성하고 생성된 스레드에서 remove() 메서드를 호출해 자원의 누수를 방지해야한다.스레드 풀은 스레드를 재사용하기 때문에 재사용 이전에 ThreadLocal 값이 남아있지 않도록, 사용후 값을 제거해주어야 한다.remove()메서드를 이용하여 변수를 정리하여 메모리 누수를 방지해야 한다.remove() 메서드를 호출하는 것이 중요한 이유는 스레드가 종료되도 변수값이 메모리에 남아있기 때문에 제거해주어야한다… 메모리 누수가 발생하지 않도록다른 방법으로는 변수를 초기화하거나 제거하여  데이터가 남지않도록 하거나 beforeExecute(), afterExecute() 메서드에서 threadLocal 변수의 값을 초기화하는 방법이 있다.beforeExecute(), afterExecute()beforeExecute()와 afterExecute() 메서드를 이용 스레드가 작업을 시작하고 종료할 때 ThreadLocal 변수의 상태를 관리할 수 있다. 주의할 점은 메서드 내부에서의 동기화 문제와, 스레드가 재사용될 때 데이터가 남지않도록 해야한다.또한 스레드 종료 후 변수를 제거하여 메모리 누수를 방지해야 한다.ThreadPoolExecutor의 execute(), submit()execute는 Runnable 작업을 제출하고 결과를 반환하지 않는다submit는 Runnable 또는 Callable 작업을 제출하고 Future를 통해 결과를 얻을 수 있다."
  },
  
  {
    "title": "운영체제의 동작",
    "url": "/posts/os-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/",
    "categories": "OS",
    "tags": "",
    "date": "2024-08-19 00:00:00 +0800",
    





    
    "snippet": "Operating System운영체제는 하드웨어 자원을 관리하고, 응용 프로그램과 하드웨어 사이를 중재하는 인터페이스이다.사용자와 컴퓨터 시스템 간의 인터페이스를 제공하며, 하드웨어 자원을 관리하고, 프로그램을 효율적으로 실행하도록 한다.크게 사용자 영역과 커널 영역으로 이루어지며, 커널, 사용자 인터페이스, 시스템 라이브러리, 시스템 유틸리티로 구성...",
    "content": "Operating System운영체제는 하드웨어 자원을 관리하고, 응용 프로그램과 하드웨어 사이를 중재하는 인터페이스이다.사용자와 컴퓨터 시스템 간의 인터페이스를 제공하며, 하드웨어 자원을 관리하고, 프로그램을 효율적으로 실행하도록 한다.크게 사용자 영역과 커널 영역으로 이루어지며, 커널, 사용자 인터페이스, 시스템 라이브러리, 시스템 유틸리티로 구성된다.1. 사용자 영역  응용 프로그램이 실행되는 메모리 공간  사용자 프로그램이 실행되며, 운영체제의 서비스에 대한 요청을 시스템 콜을 통해 수행한다.  하드웨어 자원에 직접 접근할 수 없으며, 운영체제의 커널을 통해서만 접근한다.  하나의 프로그램의 오류가 다른 프로그램이나 운영체제에 영향을 미치지 않는다.  다양한 사용자 프로그램이 실행된다.1) 인터페이스  사용자와 운영체제 간 상호작용 담당  GUI, CLI 형태로 제공된다.  CLI (Command Line Interface): 명령어 기반으로 사용자가 텍스트 명령을 입력하여 시스템을 제어하는 방식. (예: Linux의 Bash, Windows의 Command Prompt)  GUI (Graphical User Interface): 아이콘, 윈도우, 마우스 등의 그래픽을 이용해 사용자가 시스템을 쉽게 조작할 수 있는 방식. (예: Windows, macOS의 데스크탑 환경)2) 시스템 라이브러리 (System Libraries)운영체제가 제공하는 공용 코드와 함수의 모음. 응용 프로그램들이 하드웨어와 상호작용할 때 이 라이브러리를 통해 커널과 통신한다.  시스템 호출(system call), 입출력 처리, 메모리 할당 등의 기능을 제공하는 표준화된 인터페이스 역할3) 시스템 유틸리티 (System Utilities)사용자가 시스템을 관리, 유지보수할 수 있도록 도와주는 소프트웨어 도구  백업, 디스크 정리, 파일 복구, 시스템 모니터링과 같은 관리 도구2. 커널 영역  커널이 실행되는 메모리 공간  하드웨어와 소프트웨어 간의 상호작용을 관리하고 시스템 자원을 제어한다.  커널은 모든 하드웨어 자원에 대한 직접적인 접근 권한을 갖는다.  사용자 프로그램의 요청을 처리하고, 시스템 보안 유지, 자원 관리 및 프로세스 관리 등의 기능 수행.커널의 역할기본적으로 프로그램이 실행되기 위해서는 프로그램이 메인 메모리에 적재되어야 한다.  운영체제 역시 프로그램이기 때문에 메인 메모리에 적재되어야 하지만, 운영체제의 크기가 너무 커서 전체를 메모리에 올릴 경우 비효율적이다.따라서 운영체제의 핵심인 커널이라고 하는 부분만 메인메모리에 적재하여 운영체제를 사용하도록 한다.즉, 커널(Kernel)은 운영체제의 핵심 부분으로, 메모리에 상주하여 하드웨어와 소프트웨어 간의 인터페이스 역할을 한다. 커널은 컴퓨터가 부팅되면 메모리에 로드되어 실행된다.  프로세스 관리 : 프로세스에 CPU를 배분하고 작업에 필요한 환경을 제공한다.  메모리 관리 : 프로세스에 작업 공간을 배치하고 실제 메모리보다 큰 가상 공간을 제공한다.  파일 시스템 관리 : 데이터를 저장하고 접근할 수 있는 인터페이스를 제공한다.  입출력 관리 : 필요한 입출력 서비스를 제공한다.  프로세스 간 통신 관리 : 공동 작업을 위한 각 프로세스 간 통신 환경을 제공한다.동작 원리  인터럽트 처리하드웨어 장치에서 발생하는 인터럽트를 처리하여, 커널이 하드웨어 장치와 소통할 수 있도록 한다.  컨텍스트 스위칭CPU가 하나의 프로세스에서 다른 프로세스로 전환할 때, 현재 프로세스의 상태를 저장하고 새로운 프로세스의 상태를 로드한다.  가상 메모리 관리물리적 메모리의 부족을 처리하기 위해 가상 메모리 시스템을 사용하여 디스크 공간을 임시 메모리 처럼 사용한다.3. System Call사용자나 프로그램이 직접적으로 하드웨어 자원에 접근하는 것을 막고 커널을 보호하기 위한 인터페이스사용자 프로그램이 커널 서비스이 필요할 때 시스템 콜을 사용하여 커널 영역으로 전환한다.CPU는 사용자 모드에서 커널 모드로 전환되며, 커널은 요청된 작업을 수행한 후 결과를 사용자 프로그램에 반환한다.4. Driver프린터, 키보드 및 디스크 드라이브와 같은 하드웨어 장치와 운영체제 간의 동신을 가능하게 하는 소프트웨어운영체제 동작 순서1. 부팅  컴퓨터에 전원이 공급되면, 하드웨어 장치가 초기화 된다.  하드웨어의 기본적인 기능을 점검하는 테스트(POS)가 실행되며, 이 과정에서 메모리, CPU, 키보드 등 정상적으로 동작하는지 확인한다.  성공시 bootloader를 실행한다.  부트로더는 하드디스크나 SSD에 저장된 운영체제를 메모리로 불러온다. (이때, 커널이 메모리로 로드된다.)  bootloader운영체제를 메모리에 로드하는 프로그램2. 커널 초기화  커널은 하드웨어 장치를 제어하기 위한 장치 드라이버를 초기화한다.  커널은 프로세스 관리 시스템을 설정하여 CPU 자원을 효율적으로 배분할 수 있도록 준비한다.  커널은 메모리 관리 시스템을 초기화하여 프로그램이 사용할 수 있는 메모리 영역을 설정하고 관리한다.  운영체제는 파일 시스템을 마운트하여, 하드디스크 등에서 데이터를 읽고 쓸 수 있게 한다.3. 서비스 및 데몬 실행  네트워크, 프린터, 사용자 인증 등과 관련된 서비스가 실행된다.  백그라운드에서 지속적으로 실행되는 프로그램들로, 로그 관리, 네트워크 연결 관리 등을 처리한다.4. 사용자 인터페이스 제공  사용자에게 로그인 화면을 제공한다. ID, PWD를 입력하여 인증 절차를 거친다.  사용자 인증 후, 데스크탑 환경(윈도우 시슷템, 아이콘, 메뉴 등)이 로드된다.5. 프로그램 실행 및 관리  사용자가 프로그램을 실행하면, 운영체제는 해당 프로그램을 메모리에 로드하고 CPU를 할당하여 실행한다.  운영체제는 프로세스를 관리하며, 필요한 경우 멀티태스킹을 통해 여러 프로그램이 동시에 실행할 수 있도록 한다.  파일 저장, 프린터 출력, 네트워크 연결등 모든 입출력 작업을 운영체제가 관리한다.6. 종료 및 셧다운  사용자가 프로그램을 종료하면, 운영체제는 해당 프로그램에 할당된 메모리와 리소스를 해제한다.  사용자가 시스템 종료를 선택하면, 운영체제는 실행중인 모든 프로그램과 서비스를 종료하고, 파일 시스템을 안전하게 언마운트 한 뒤 전원을 끈다."
  },
  
  {
    "title": "NIO",
    "url": "/posts/java-NIO/",
    "categories": "Java",
    "tags": "",
    "date": "2024-08-14 00:00:00 +0800",
    





    
    "snippet": "Java NIO 는 JDK 1.4 에 적용된 패키지로 기존의 Java I/O 느린 단점을 보완Java IO  파일의 경로와 이름 등의 메타 데이터를 포함한 InputStream, OutputStream 객체 생성  InputStream 및 OutputStream 객체를 사용하여 read(), write() 등의 메서드 호출이 메서드들은 JVM을 통해 ...",
    "content": "Java NIO 는 JDK 1.4 에 적용된 패키지로 기존의 Java I/O 느린 단점을 보완Java IO  파일의 경로와 이름 등의 메타 데이터를 포함한 InputStream, OutputStream 객체 생성  InputStream 및 OutputStream 객체를 사용하여 read(), write() 등의 메서드 호출이 메서드들은 JVM을 통해 해당 플랫폼의 운영체제와 상호 작용한다.  JVM은 운영 체제의 파일 시스템 API를 사용하여 파일에 대한 실제 읽기 및 쓰기 작업을 한다. 이 때, 운영 체제는 해당 파일을 찾아 디스크에서 읽기 작업을 수행하거나, 쓰기 작업을 수행하여 디스크에 데이터를 저장한다.  운영 체제는 파일로부터 읽은 데이터를 커널의 버퍼에 저장한 뒤 JVM의 사용자 공간 버퍼로 복사하거나, 사용자 공간 버퍼의 데이터를 파일 시스템으로 전달한다.이 과정에서 대체로 Thread 를 block 시킨다.Java IO 와 NIOIO  동기 방식, 블로킹 방식, 단방향 전송, 스트림  입력 스트림과 출력 스트림이 구분되어 있으며 별도로 생성해야 한다.  버퍼를 사용하지 않으며 1바이트씩 읽고 출력하기 때문에 속도가 느리다.  BufferdInputStream, BufferedOutputStream, BufferedReader, BufferedWriter와 같은 보조 스트림을 별도로 제공하여 버퍼 기능을 지원한다.  스트림으로부터 입력된 전체 데이터를 별도로 저장하지 않으면, 입력 데이터의 위치를 이동하면서 자유롭게 이용할 수 없다.  블로킹을 빠져나오려면 스트림을 닫아야 한다.  연결 클라이언트 수가 적고 전송되는 데이터가 대용량이며 순차적으로 처리될 필요가 있는 경우 사용NIO  채널, 스트림, 동기, 비동기, 블로킹, 넌블로킹, 양방향, 버퍼  하나의 채널로 데이터를 읽고 쓰기가 가능한 양방향 전송  버퍼를 사용해서 입출력 성능이 좋으며 버퍼에 저장하기 때문에 버퍼 내에서 데이터 위치를 이동해가며 필요한 부분을 읽고 쓸 수 있다.  interrupt를 사용해 블로킹을 빠져나올 수 있다.  연결 클라이언트 수가 많고 전송되는 데이터 용량이 적으며, 입출력 작업 처리가 빨리 끝나는 경우 사용Selector여러 채널을 동시에 감시하여 데이터가 읽거나 쓸 준비가 되어있는지 확인여러 채널에서 발생하는 I/O 이벤트를 동시에 처리할 수 있게 하여 단일 스레드로 여러 I/O 연산을 처리한다.이를 통해 하나의 스레드가 여러 I/O 작업을 비동기로 처리할 수 있다.Channel파일이나 소켓과 같은 I/O 대상과 연결되어 있는, 데이터가 읽고 쓰이는 통로실제 데이터 전송을 담당하며 파일, 네트워크 소켓 등 다양한 데이터 소스와 연결되고, 데이터는 채널을 통해 읽거나 쓸 수 있다. 실제로 read, write 를 수행하는 주체이다.Buffer채널에서 읽거나 쓴 데이터를 임시로 저장하는 메모리 블록NIO의 모든 데이터는 버퍼를 통해 처리되며, 채널과 버퍼 간 데이터 이동이 발생한다. 채널과 상호작용하여 데이터를 저장하는 메모리 블록을 데이터는 채널에서 버퍼로 읽히거나, 버퍼에서 채널로 쓰인다.Selector는 여러 Channel을 등록하여 감시한다.데이터가 준비된 채널이 있으면 셀렉터가 이것을 확인하고 해당 채널에 관련된 버퍼를 통해 데이터를 처리한다.이를 통해서 하나의 스레드가 여러 I/O 작업을 처리합니다.Blocking은 채널에서 데이터가 준비될 때까지 스레드가 대기한다. Non-blocking 의 경우 채널에서 데이터가 준비되지 않은 경우 블로킹 되지 않고 다른 작업을 수행하고, 데이터가 준비되면 나중에 다시 확인한다.Non-blocking 구현하기 위해서는 configureBlocking(false)를 사용하여 non-blocking 모드로 설정한다. 그러면 채널의 I/O 작업이 블로킹되지 않고 반환한다.즉 데이터가 준비되지 않은 경우 read(), write() 호출이 블로킹 되지 않고 -1, 0을 반환하여 바로 다른 작업을 할 수 있다.Selector의 select() 메서드를 호출해서 준비된 채널을 확인 한다.채널이 준비될때까지 블로킹되거나, 준비된 채널이 없으면 반환됩니다.준비된 채널을 얻으면 해당 채널을 통해서 read(), write() 통해 데이터를 읽거나 사용할 수 있다.select()가 반환한 값 중 0은 준비된 채널이 없음을 의미하며, 양수가 나오는 경우 준비된 채널의 수를 의미한다.selectedKeys()selectedKeys() 메서드 호출을 통해 준비된 채널의 집합을 얻을 수 있으며, 각 selectedKey를 확인해 준비된 작업을 수행할 수 있다.작업 완료 후 selectionKey를 selectedKeys에서 제거하여 다음 select() 호출에서 중복으로 처리되지 않도록 한다.  interest set SelectionKey에서 감시하고 싶은 채널의 I/O 읽기 또는 쓰기 이벤트를 감시하도록 설정  ready setSelector가 select() 또는 selectNow()로 감지한 채널의 현재 상태Selector가 현재 준비된 I/O 작업을 가진 채널의 SelectionKey 객체들을 가지고 있으며 이 값은 select(), selectNow() 호출을 통해 받은 채널의 수와 동일하.select() 와 selectNow()두 메서드의 차이는 블로킹 여부와 대기시간에 있다.select()select()는 채널이 준비될 때까지 블로킹된다. 지정된 시간 동안 대기하며, 준비된 채널의 수를 반환한다.준비된 채널이 없는 경우 스레드를 대기 상태로 두어 준비된 채널이 있을때까지 기다린다.selectNow()블로킹 없이 현재 준비된 채널의 상태를 실시간으로 확인하는 메서드로 비동기로 채널 상태를 검사할 때 유용하다.스레드를 대기시키지 않고 빠르게 상태를 확인할 수 있지만 호출이 빈번하게 일어나느 경우 CPU 사용률이 증가할 수 있다.준비된 채널이 없으면 즉시 반환되며, 대기하지 않는다.select()에서 블로킹을 피하기 위한 대안으로 타임아웃을 설정하여 지정된 시간동안만 대기하거나, selectNow()를 사용할 수 있다.또는 여러 개의 selector()을 사용하면 여러 개의 채널을 동시에 관리할 수 있."
  },
  
  {
    "title": "JVM 내부 동작 원리",
    "url": "/posts/jvm/",
    "categories": "Java",
    "tags": "",
    "date": "2024-08-12 00:00:00 +0800",
    





    
    "snippet": "JVM (Java Virtual Machine)  Write once, Run everyWhere  Java 프로그램 실행을 담당하는 가상의 컴퓨터로, Java 바이트 코드 실행, 메모리 관리, 가비지 컬렉션 등을 담당한다.  자바와 운영체제 사이에서 중계자 역할을 하며, 자바가 운영체제에 구애받지 않고 프로그램을 실행할 수 있도록 도와준다.JRE (...",
    "content": "JVM (Java Virtual Machine)  Write once, Run everyWhere  Java 프로그램 실행을 담당하는 가상의 컴퓨터로, Java 바이트 코드 실행, 메모리 관리, 가비지 컬렉션 등을 담당한다.  자바와 운영체제 사이에서 중계자 역할을 하며, 자바가 운영체제에 구애받지 않고 프로그램을 실행할 수 있도록 도와준다.JRE (Java Runtime Environment)  Java 프로그램 실행을 위한 환경을 제공하며, JVM과 Java 클래스 라이브러리가 포함된다.  JRE만 있으면 Java 프로그램을 실행할 수 있지만, Java 프로그램을 개발하기 위해서는 JDK가 필요하다.  JDK 를 설치하면 JRE도 같이 설치된다. (JDK = JRE + a)JDK (Java Development Kit)  Java 애플리케이션을 개발하기 위한 도구 모음으로 JRE와 함께, 컴파일러, 디버거, 기타 개발 도구가 포함된다.  Java 프로그램을 개발, 컴파일, 실행할 수 있는 모든 것을 제공한다.  JDK를 이용하여 Java 코드를 작성하고, 이를 실행하기 위해 JRE를 사용한다.  JVM 특징            컴파일된 바이트 코드를 기계어로 변환              스택 기반의 가상 머신              메모리 관리와 GC 수행      예로 C는 바로 기계어로 컴파일하기 때문에, HW 기종에 맞게 각각 컴파일 되어야 한다.반면, 자바 프로그램은 중간 단계 언어( *.class )로 컴파일 하여 JVM만 각 OS에 설치되어 있다면 HW 기종에 관계 없이 한 번만 컴파일 하면 된다.  바이너리 코드/ 바이트 코드/ 기계어  바이너리 코드      컴퓨터가 인식할 수 있는 0과 1로 구성된 이진코드    모든 바이너리 코드가 기계어는 아니다.    바이트 코드      JVM 이 이해할 수 있는 중간 코드    고급 언어로 작성된 코드가 컴파일되어 생성된다.    플랫폼에 독립적이며, 어떤 플랫폼에서든 JVM이 있는 한 실행할 수 있다.    JIT(Just-in-time)컴파일러 또는 인터프리터에 의해 네이티브 코드로 변환되어 실행된다.    기계어      CPU가 직접 해독하고 실행할 수 있는 특정한 바이너리 코드    특정 CPU 아키텍처에 종속적이며, CPU 제조사가 정의한 명령어 집합에 따라 달라진다.    CPU가 변경되면 기계어가 달라진다. (같은 동작을 하는 명령어지만 완전히 다른 0과 1이 나열될 수도 있다.)    모든 기계어가 이진코드 인 것은 아니며, 기계어는 특정 언어가 아니다.  즉, 소스 파일(.java)은 자바 클래스 파일(.clss)로 컴파일 된다.JVM이 클래스파일(*.class)을 OS에 맞는 기계어로 변환(인터프리터와 JIT 컴파일러를 통해)하여 실행된다.Java 실행 방식1. 자바 컴파일  자바 소스 파일이 컴파일러에 의해 바이트코드 파일로 변환된다.2. 클래스 로딩  JVM은 Class Loader를 통해 클래스 파일을 메모리의 Runtime Data Area의 메서드 영역에 로드한다.3. 클래스 검증  로드된 클래스 파일이 자바 언어 명세에 따라 유효한지 검증한다.4. 메모리 할당 및 초기화  JVM은 클래스의 변수를 위한 메모리를 할당하고 그 변수를 기본값으로 초기화한다.  해당 클래스의 정적 변수와 정적 메서드를 위한 메모리를 메서드 영역에 할당한다.  이 메모리는 클래스가 로드될 때 생성되며, 각 클래스에 대한 메타데이터와 함께 저장된다.5. JVM 은 execution engine 통한 실행  JVM은 Execution Engine을 통해 클래스 파일의 바이트 코드를 해석하여 기계어로 변환하고 해석한다.  이 과정에서 JIT 컴파일러 사용하여 성능을 향상시킨다.          JIT 컴파일러는 프로그램을 실행 하는 동안 반복되는 코드 블록을 식별하고 이를 네이티브 기계 코드로 컴파일하여 실행 속도를 향상시킨다      execution engine : Loading 된 클래스의 바이트코드를 해석 (바이트-&gt;바이너리)      6. GC을 수행  JVM은 더 이상 필요하지 않은 객체를 감지하고 자동으로 메모리에서 해제한다.7. 자원 해제 및 종료  프로그램이 종료되거나 JVM이 종료될 때, JVM은 사용한 리소스를 해제하고 종료한다.JVM 구성요소JVM은 크게 아래과 같이 구성되어 있다.  Class Loader  Runtime Data Area          PC register      Stack Area      Native Method Stack      Heap Area      Method Area        Execution Engine          Interpreter      JIT Compiler      Garbage Collector      Class Loader System자바 클래스 파일(.class)을 실행 시점(Runtime)에 읽어 메모리(Runtime Data Area)에 로드하고 실행하기 위해 사용하는 메커니즘클래스 로더는 JVM의 일부분으로, JVM이 실행되는 동안 메모리 내에 존재한다.자바 프로그램의 실행 중 필요한 클래스를 동적으로 로드하고, 연결하고 초기화하는 역할을 한다.자바의 클래스들은 한 번에 모든 클래스가 메모리에 올라가지 않고, 필요할 때 메모리에 올라간다.로딩 -&gt; 링크 -&gt; 초기화로딩클래스 로더는 클래스 패스에서 (.claass)파일을 찾아 메모리에 로드한다.이때 클래스 로더는 .class 파일을 바이너리 형식으로 읽어, JVM의 메모리 영역인 메서드 영역에 저장한다.로딩이 왼료되면, 해당 클래스 타입의 Class 객체가 생성되어 Heap 영역에 저장된다.이 클래스 객체는 해당 클래스에 대한 메타데이터(클래스, 인터페이스, Enum 등)와 정보를 포함한다.한번에 메모리에 모두 로드하지 않고, 필요한 경우 동적으로 메모리에 로드한다.1. Bootstrap Class LoaderJVM의 핵식 클래스 로더로 rt.jar와 같은 핵심 자바 API를 로드한다.네이티브 코드로 구현되어 있으며, Java로 접근할 수 없고 가장 높은 우선순위를 갖는다.2. Extension Class Loaderlib/ext 디렉터리나 java.ext.dirs 시스템 속성에 지정된 위치에서 확장 클래스들을 로드한다.부트스트랩 클래스 로더 다음의 계층에 위치하며, 사용자 정의 클래스 로더보다 우선적으로 사용한다.3. Application Class Loader애플리케이션 클래스패스(classpath)에 지정된 클래스, 애플리케이션에서 작성한 클래스와 라이브러리를 로드한다.자바 응용 프로그램의 기본 클래스 로더로, 대부분의 사용자 클래스와 라이브러리를 로드하는데 사용된다.링크로드된 클래스 파일을 JVM이 사용할 수 있도록 준비  Verify -&gt; Prepare -&gt; Resolve1. Verification.class 파일 형식이 유효한지 검사한다. 로드된 클래스가 자바 언어 명세에 부합한지 확인하고, 유효하지 않은 경우 런타임 에러(java.lang.VerifyError)가 발생 한다.2. Preparation클래스 변수(static 변수)와 같은 메모리를 할당하고 초기화한다.3. Resolution클래스의 심볼릭 메모리 레퍼런스를 메모리 영역에 존재하는 실제 메모리 주소로 변경한다.  심볼릭 메모리 레퍼런스  클래스의 특정 메모리 주소를 참조 관계로 구성한 것이 아닌 참조 대상의 이름만 갖는 것즉, 실제 메모리 주소가 아니라 이름만 갖는다.Initialization클래스 변수의 초기화 코드가 실행된다. static 초기화 블록이 실행되며, 변수가 초기화된다.링크의 prepare 단계에서 확보한 메모리 영역에 클래스 변수들 (= static 변수)를 적절한 값으로 초기화한다.Using초기화된 클래스는 이제 JVM에서 사용될 준비가 되어 있으며, 인스턴스 생성이나 메서드 호출과 같은 작업이 가능하다.Unloading클래스 로더가 클래스를 메모리에서 제거한다.JVM이 필요하지 않은 클래스를 GC를 통해 언로드한다.Runtime Data AreaJVM이 프로세스로 수행되기 위해 OS로 부터 할당받는 메모리 영역으로 데이터 저장, 스레드 관리, 메서드 실행, 객체 관리 등을 수행한다.프로그램 실행 시, 메서드 호출에 따라 스택 프레임이 생성되고, 메서드 호출이 완료되면 해당 스택 프레임이 제거된다.객체는 힙에 동적으로 생성되며, 가비지 컬렉션을 통해 메모리를 관리한다.클래스는 처음 참조될 때 메서드 영역에 로드되며, 이후 해당 클래스 정보는 메서드 영역에서 재사용 된다.Method Area  JVM이 시작될 때 생성되며, 모든 스레드가 공유하는 영역  여기에 스태틱 영역(정적 변수들이 저장되는 공간)이 포함된다.  클래스정보, 변수정보, Method, static 변수, 상수풀 등이 저장된다.Heap Area  모든 스레드에 공유되며, new 명령어로 생성된 인스턴스와 객체가 저장되는 영역  GC의 대상이 된다.  힙은 JVM에서 가장 큰 메모리 영역으로 모든 스레드가 공유한다.  GC가 주기적으로 힙 메모리를 청소하여 사용되지 않는 객체를 제거한다.PC Register  스레드가 현재 실행 중인 명령어의 주소를 추적하며, 각 스레드는 독립적인 PC 레지스터를 갖는다.  현재 실행 중인 자바 바이트코드 명령어의 주소를 저장하고, 이 주소를 사용하여 다음에 실행할 명령어를 결정한다.  메서드 호출 및 명령어 실행 후, PC 레지스터의 값을 업데이트하여 다음 명령어의 주소를 가리킨다.  JVM은 스택 기반의 가상 머신으로, 모든 명령어 실행은 스택 프레임을 통해 이루어진다.  JVM은 메서드가 호출될 때마다 새로운 스택 프레임을 생성하고, 해당 프레임에 PC 레지스터 값을 업데이트하여 각 메서드의 실행 흐름을 관리한다.메섣드 호출이 완료되면 스택 프레임이 제거되고, PC 레지스터는 이전 호출로 돌아간다.CPU는 명령어를 실행하고 제어하는 장치로, 주기억장치(메모리)와 상호작용하여 데이터를 처리한다.명령어는 CPU 내부의 레지스터와 캐시메모리를 통해 빠르게 처리된다.자바는 JVM이라는 가상 머신에서 실행된다. 따라서 자바 프로그램은 OS나 CPU에서 직접 실행되지 않고, JVM이 중간에서 처리한다.PC 레지스터는 CPU가 현재 실행 중인 명령어의 주소를 저장하는 레지스터로, JVM의 각 스레드는 자신의니 PC 레지스터를 각ㅈ는다.명령어는 스택 프레임의 Operands 영역에 저장되며, JVM은 이 영역에서 명령어를 가져와 PC 레지스터에 주소를 저장한 후 , CPU에게 실행할 명령어를 전달한다.CPU는 PC레지스터의 주소를 참조하여 해당 명령어를 메모리에서 읽어 실행한다.명령어 실행이 끝나면, PC 레지스터의 값은 다음 실행할 명령어의 주소로 업데이트 된다.위의 과정은 스레드가 메서드 호출 시다마 반복된다.Stack Area  각 스레드마다 하나씩 생성  호출된 메소드의 파라미터, 지역 변수, 리턴 값 및 연산 값 등이 저장되는 영역  메소드가 호출될때마다 스택 프레임이라 불리는 블럭이 하나씩 생성되고 메서드 실행이 종료되면 삭제된다.  스택 오버플로우 발생시 JVM은 해당 스레드에 대해 예외를 발생시킨다.  LIFO  구성요소  스택 프레임각 메서드 호출마다 스택 프레임이 생성되며, 메서드 실행이 끝나면 제거된다.각 스택 프레임은 메서드 호출에 대한 정보를 담는다.  지역 변수 배열메서드에서 선언된 지역 변수와 매개 변수 저장  오퍼랜드 스택메서드 실행 중에 연산에 필요한 값을 저장하는 공간  프레임 데이터메서드의 실행 상태 저장(메서드 호출자, 리턴 주소 등)Native Method Stack  각 스레드마다 하나씩 생성  Java 이외의 언어로 작성된 메소드의 정보가 저장되는 공간  Kernel 이 자체적으로 Stack 을 잡아 독자적으로 프로그램을 실행시키는 영역  JNI 표준 규약 제공          JNI      자바와 다른 프로그래밍 언어 간의 상호작용을 위한 표준 규약자바 프로그램이 Native 메서드를 호출할 수 있다.자바 애플리케이션이 운영체제의 특정 기능이나 외부 라이브러리와 연동할 수 있도록 한다.      Execution Engine클래스로더를 통해 Runtime Data Area에 적재된 자바 바이트 코드를 명령어 단위로 읽어 들인다.JVM의 인터프리터, JIT는 메모리에 적재된 바이트 코드를 명령어 단위로 읽어 해석한다.각 바이트 코드는 JVM이 이해할 수 있는 명령어로 반횐된다.해석된 명령어는 CPU에 의해 실행되며, 자바 프로그램 로직이 실제로 수행된다.1. 인터프리터바이트 코드를 한 줄씩 읽어 즉시 실행한다.코드의 해석과 실행이 실시간으로 이루어져 빠르짐만, 성능 면에서는 비효율적일 수 있다.중복된 바이트 코드는 JIT 컴파일러를 사용한다.2. JIT Compiler (Just-In-Time)인터프리터의 단점을 개선하기 위해 등장반복적으로 호출되는 바이트 코드 블록을 식별하고, 이를 네이티브 머신 코드로 컴파일하여 성능을 향상 시킨다.JIT 컴파일러는 프로그램 실행 중 필요에 따라 바이트 코드를 네이티브 코드로 변환하여 실행 속도를 높인다.그 후 캐싱을 통해 동일한 부분이 호출되면 캐싱한 코드를 가져온다.따라서 한 번 바꾼 Native Code는 인터프리터가 더 이상 컴파일하지 않아도 된다.즉, 자바 바이트코드에서 Native Code로 바꾸는 과정을 JIT에서 수행한다.3. Garbage Collections가비지 컬렉션을 관리하여 힙 메모리에서 더 이상 사용되지 않는 객체를 자동으로 정리한다."
  },
  
  {
    "title": "Blocking IO와 Non-Blocking IO , 동기와 비동기",
    "url": "/posts/java-blocking/",
    "categories": "Java",
    "tags": "",
    "date": "2024-08-12 00:00:00 +0800",
    





    
    "snippet": "Blocking현재 스레드(또는 프로세스)가 어떤 작업을 수행할 때, 그 작업이 완료될 때까지 다른 작업을 할 수 없도록 대기하는 상태제어권이 호출된 함수에게 넘어가서, 함수가 작업을 끝낼때까지 제어권을 유지합니다.따라서 호출한 함수는 호출된 함수가 끝나기 전까지 다른 작업을 하지 못하고 대기합니다.  파일을 읽거나 쓰는 작업에서 파일 읽기/쓰기가 완...",
    "content": "Blocking현재 스레드(또는 프로세스)가 어떤 작업을 수행할 때, 그 작업이 완료될 때까지 다른 작업을 할 수 없도록 대기하는 상태제어권이 호출된 함수에게 넘어가서, 함수가 작업을 끝낼때까지 제어권을 유지합니다.따라서 호출한 함수는 호출된 함수가 끝나기 전까지 다른 작업을 하지 못하고 대기합니다.  파일을 읽거나 쓰는 작업에서 파일 읽기/쓰기가 완료될 때까지 스레드가 대기하는 경우  네트워크에서 데이터를 받을 때까지 응답을 기다리며 다른 작업을 하지 못하는 경우문제입출력 작업이 완료될때 까지 다른 스레드가 대기해야하기 때문에, 멀티 스레드 환경에서 대기 시간이 오래 걸릴 수 있습니다. 많은 클라이언트의 요청을 동시에 처리할 수 없으며 블록 상태가 발생할 수 있습니다.Non-Blocking작업이 즉시 처리되거나, 처리할 수 없는 경우에도 스레드가 대기하지 않고 다른 작업을 계속할 수 있는 상태제어권이 호출된 함수에게 넘어갔다가, 즉시 호출한 함수로 돌아옵니다.호출된 함수가 완료되지 않았지만, 제어권을 바로 반환하기 때문에 호출한 함수는 다른 작업을 계속할 수 있습니다.A 함수가 B 함수를 호출했을 때, B 함수는 바로 A 함수에게 제어권을 돌려주고, A 함수는 B 함수가 끝날 때까지 기다리지 않고 다른 작업을 할 수 있게 됩니다.차- 작업이 완료될 때까지 대기하지 않고, 작업 큐에 넣어 두고 다른 작업을 수행하는 경우문제복잡하며, 콜백 지옥과 같은 문제가 발생할 수 있고, 이벤트를 기반으로 동작하기 때문에 실행 흐름을 추적하거나 디버깅이 어렵습니다.비동기 작업이 많아질수록 메모리 사용량이 증가할 수 있습니다.주로 다수의 클라이언트 요청을 비동기로 처리할 때 사용되며, 웹 서버에서 여러 요청을 동시에 처리하고IO 작업이 완료될 때까지 기다리지 않고 다른 요청을 처리하는데 유용하게 사용됩니다.대규모 데이터베이스나 파일 처리에서 비동기 IO는 시스템의 처리량을 향상 시키는데 기여할 수 있습니다.구현 방법에는 자바스크립트에서 콜백함수를 사용하거나 promise 를 사용하는 방법이 있습니다.또한 자바의 NIO 와 같은 라이브러리를 사용하여 블로킹 IO 를 비동기적으로 처리할 수 있습니다.동기작업의 완료를 기다리는 방식으로, 순차적으로 실행되며 한 작업이 끝나야 다음 작업이 시작될 수 있습니다.작업의 순서가 보장되며, 코드의 실행 순서가 예측 가능합니다.비동기작업의 완료를 기다리지 않는 방식입니다.작업들이 병렬로 실행될 수 있으며, 어떤 작업이 끝날 때까지 기다리지 않고 다른 작업을 수행합니다.작업 완료는 나중에 별도로 처리되며, 작업이 완료되면 그에 대한 콜백을 받거나, 나중에 결과를 확인합니다.  Blocking 와 Non-Blocking  함수 호출 후 제어권의 반환 시점  동기 와 비동기  작업 완료 시점에 대한 처리 방식Promise?비동기 작업의 결과를 나중에 처리할 수 있는 객체로, 작업의 성공(fulfilled) 또는 실패(rejected)를 다룹니다.비동기 코드를 더 읽기 쉽게 작성하고 에러 처리를 간편하게 할 수 있습니다.코드가 복잡해질 수 있고 디버깅이 어려워질 수 있습니다. 또한 비동기 작업을 작업을 과ㅏㄴ리하기 위해 메모리를 추가로 소비하기 때문에 많은 Promise 객체가 생성될 경우 메모리 사용량이 증가합니다.따라서 모든 비동기에 에러 처리를 해야하며, Promise.all()을 사용할 때, 하나의 Promise라도 실패하면 전체가 실패로 간주되므로, 개별적으로 에러 처리를 할 필요가 있습니다.Promise 내부에서 또 다른 Promise를 반환하는 경우, 코드가 복잡해질 수 있기 때문 async/await를 사용하는 것이 더 적합할 수 있습니다.NIO (New I/O)자바의 비동기 IO를 지원하는 API로, 네트워크와 파일 작업을 효율적으로 처리할 수 있게 합니다.Selector와 Channel을 사용하여 비동기적으로 여러 IO 작업을 관리할 수 있습니다.이벤트 통지 방식Sync Blocking I/O입력 요청 등 제어권과 처리 결과를 동시에 반환  호출  블로킹  처리구현이 간단하고 직관적이며, 스레드가 직적 I/O 작업을 기다리기 때문에 비동기 처리가 필요없습니다.Sync Non-Blocking I/O자신의 작업을 하면서 결과가 반환됐는지 확인하는 방식반환됐을 경우 바로 처리합니다.  호출: 스레드가 I/O 작업을 요청합니다. 요청이 즉시 완료되지 않더라도 스레드는 다른 작업을 계속 진행합니다.  작업 상태 확인: I/O 작업의 상태를 주기적으로 확인하거나, 결과를 체크합니다.  처리: 작업이 완료되면 결과를 처리합니다. 이 과정은 동기적으로 이루어집니다.스레드가 다른 작업을 계속 수행할 수 있으므로 자원 효율성이 좋으며, 높은 I/O 성능을 요구하는 어플리케이션에서 효과적입니다.Async Blocking I/O비동기적으로 I/O 요청을 시작하고, I/O 작업의 완료를 기다리는 블로킹 방식  비동기 I/O 요청: I/O 작업을 비동기적으로 시작합니다. 요청을 보내고 제어권을 즉시 반환받습니다.  블로킹 대기: I/O 작업의 결과를 기다리는 동안, 스레드가 블로킹되며 대기합니다.  결과 처리: I/O 작업이 완료되면, 블로킹된 스레드가 결과를 처리합니다. 이 과정에서 비동기적 요소가 작용할 수 있습니다.비동기 I/O 요청을 통해 자원의 사용 효율성을 높일 수 있으며, 스레드의 효율성을 높일 수 있습니다.스레드가 블로킹되는 동안 다른 작업을 수행할 수 없기 때문에 자원의 활용도가 떨어질 수 있으며,비동기 요청과 블로킹 대기 사이의 복잡성을 관리하기 어려울 수 있습니다.Async Non-Blocking I/OI/O 작업의 완료를 기다리지 않고 다른 작업을 동시에 처리할 수 있는 접근 방식작업 요청 이후 자신의 작업은 그대로 진행. 결과가 반환되어도 바로 처리하는게 아니라 자기 작업이 끝난 이후에 콜백을 통해 추가 작업  I/O 요청: 스레드는 I/O 작업을 요청하고 즉시 제어권을 반환받습니다. 스레드는 I/O 작업의 완료를 기다리지 않습니다.  작업 완료 대기: I/O 작업은 비동기적으로 처리되며, 완료 시 콜백 함수나 Future/Promise 객체를 통해 결과를 받습니다.  결과 처리: I/O 작업이 완료되면, 콜백 함수나 Future/Promise 객체를 통해 결과를 비동기적으로 처리합니다.I/O 작업이 완료될 때까지 스레드가 대기하지 않으므로, 자원 활용도가 높고, 많은 I/O 작업을 동시에 처리할 수 있어 성능이 향상됩니다.응답 시간이 짧고, 높은 처리량을 달성할 수 있습니다.비동기 코드의 복잡성이 증가할 수 있습니다.콜백 지옥(callback hell)이나 상태 관리의 복잡함이 발생할 수 있습니다."
  },
  
  {
    "title": "Redis란?",
    "url": "/posts/redis/",
    "categories": "DB",
    "tags": "",
    "date": "2024-08-06 00:00:00 +0800",
    





    
    "snippet": "Redis (Remote dictionary server) 란?오픈 소스 인메모리 데이터 구조의 저장소로, 주로 데이터베이스, 캐시, 메시지 브로커로 사용된다.빠른 접근 속도와 다양한 데이터 구조를 지원한다.데이터를 메모리에 저장하여 빠른 접근 속도를 제공하며, 데이터를 메모리에 저장하면 디스크 I/O 를 줄이고, 높은 성능을 유지할 수 있다.키와 값...",
    "content": "Redis (Remote dictionary server) 란?오픈 소스 인메모리 데이터 구조의 저장소로, 주로 데이터베이스, 캐시, 메시지 브로커로 사용된다.빠른 접근 속도와 다양한 데이터 구조를 지원한다.데이터를 메모리에 저장하여 빠른 접근 속도를 제공하며, 데이터를 메모리에 저장하면 디스크 I/O 를 줄이고, 높은 성능을 유지할 수 있다.키와 값의 구조로 저장되며 비정형 데이터를 저장, 관리한다.인메모리?특징  인 메모리 저장소          데이터를 디스크가 아닌 RAM 에 저장하여 빠르게 접근하고 처리하는 방법빠른 접근 속도를 제공하기 때문에 지연이 적고 응답시간이 빠르다.데이터가 서버의 메모리에 유지되기 때문에 서버가 재부팅되거나 종료되면 데이터가 사라질 수 있다.  이를 보완하기 위해 스냅샷, 로그 등 영속성 옵션을 사용할 수 있다.            다양한 데이터 구조문자열(Strings), 리스트(Lists), 집합(Sets), 정렬된 집합(Sorted Sets), 해시(Hashes), 비트맵(Bitmaps), 하이퍼로그로그(HyperLogLogs), 지오스페이셜 인덱스(Geospatial Indexes) 등 다양한 데이터 구조 지원하여,데이터의 저장과 접근을 유연하게 한다.        영속성기본적으로 인메모리 데이터 저장소이지만, 데이터의 영속성을 보장할 수 있는 옵션을 제공한다.데이터 스냅샷을 디스크에 저장하거나(RDB), 변경 사항을 로그에 기록하여(AOF) 데이터 복구를 지원한다.        고급 기능Pub/Sub : 메시지 브로커 기능을 제공하여 메시지 전달 및 구독 시스템을 구현할 수 있다.트랜잭션 : 여러 명령어를 원자적으로 실행할 수 있는 기능을 제공한다.Lua 스크립팅 : Lua 스크립트를 사용하여 서버 측에서 복잡한 작업을 수행할 수 있다.        분산 및 클러스터링 지원레디스는 클러스터 모드와 샤딩 기능을 통해 데이터를 분산 저장하고, 대규모 데이터 처리와 고가용성을 지원한다.데이터를 샤딩하여 여러 노드에 분산 저장합니다. 클러스터링을 통해 고가용성과 수평적 확장을 지원한다.마스터-슬레이브 복제를 지원하여, 데이터를 여러 슬레이브 노드에 복제합니다. 복제를 통해 읽기 성능을 향상시키고 데이터의 고가용성을 보장한다.    높은 성능과 확장성단일 노드에서 수백만 개의 요청을 처리한다.사용  캐시          자주 조회되는 데이터나 결과를 메모리에 저장하여 데이터베이스의 부하를 줄이고 응답 속도를 빠르게 한다.        세션 스토리지          웹 애플리케이션에서 사용자 세션 정보를 저장하고 관리한다.        실시간 데이터 처리          실시간으로 데이터를 처리하고 분석하는 데 사용된다.      실시간 채팅 애플리케이션에서 메시지를 처리하거나 실시간 분석 대시보드에서 데이터를 스트리밍한다.        큐 시스템          작업 큐나 메시지 큐를 구현하여 비동기 작업을 처리한다.        순위 시스템          정렬된 집합을 사용하여 순위 시스템을 구현하고, 순위 기반의 데이터를 관리한다.      "
  },
  
  {
    "title": "CI/CD",
    "url": "/posts/CI-CD/",
    "categories": "DB",
    "tags": "",
    "date": "2024-08-06 00:00:00 +0800",
    





    
    "snippet": "코드 변경 사항을 자동으로 빌드, 테스트, 배포하여소프트웨어 개발과 배포 과정을 효율적이고 안정적으로 만드는 자동화 프로세스이다.CI (Continuous Integration)지속적인 통합개발자들이 각자의 작업을 병합하여 통합하는 프로세스로 병합할 때마다 자동화된 빌드와 테스트가 실행된다.개발자들이 작업한 코드를 자주 메인 브랜치에 병합하거나, 각 ...",
    "content": "코드 변경 사항을 자동으로 빌드, 테스트, 배포하여소프트웨어 개발과 배포 과정을 효율적이고 안정적으로 만드는 자동화 프로세스이다.CI (Continuous Integration)지속적인 통합개발자들이 각자의 작업을 병합하여 통합하는 프로세스로 병합할 때마다 자동화된 빌드와 테스트가 실행된다.개발자들이 작업한 코드를 자주 메인 브랜치에 병합하거나, 각 코드 변경이 올바르게 작동하는지 확인할 때 사용한다.정기적인 통합을 통해 버그를 조기에 발견한고 수정할 수 있으며, 통합 빈도가 높아지면 통합의 복잡성과 충돌이 줄어든다.CD (Continuous Delivery/ Deployment) 란?Continuous Delivery지속적인 배포코드가 변경될 때마다 자동으로 프로덕션 환경에 배포하는 프로세스로, 모든 변경 사항이 자동으로 배포되며, 개발자의 개입 없이 자동화된 테스트를 통과하면 바로 배포된다.배포를 자동화하여 변경 사항이 가능한 빨리 사용자에겍 전달되도록 하는 것이다.빈번하게 배포가 이루어지는 상황이나, 자동화된 테스트를 통과하면 바로 배포할 수 있는 경우 사용한다.변경 사항이 프로덕션 환경에 빠르게 반영되기 때문에 사용자의 피드백을 필요로하고 신속하게 반영해야 하는 경우 사용한다.모든 변경 사항이 자동으로 배포되기 때문에 엄격한 자동화된 테스트와 모니터링이 필요하다.시나리오      코드 커밋    CI 서버가 코드를 빌드하고 자동화된 테스트 실행    테스트 통과시 자동으로 프로덕션 환경에 배포    지속적 전달 CI 단계에서 통합된 코드를 언제든 프로덕션 환경에 배포될 수 있도록 준비하는 프로세스이다.코드 변경 사항은 자동화된 테스트를 통과하고, 프로덕션 환경에 배포되기 전에 수동 검토 또는 승인 단계를 거친다. 따라서 배포 시점에 대한 제어가 가능하다.항상 배포 가능 상태를 유지하여, 필요한 경우 즉시 배포할 수 있어야 한다.자동화된 테스트를 통과한 후 프로덕션에 배포할 준비가 되어있지만, 최종 배포는 수동으로 이루어질 수 있다.시나리오      코드 커밋    CI 서버가 코드를 빌드하고 자동화된 테스트 실행    테스트 통과시 배포 가능한 상태로 준비    배포 담당자나 승인자가 최종 검토 후 배포 승인    프로덕션 환경에 배포  통합과 배포 시간을 줄임으로서 효율성을 높일 수 있으며 코드의 품질을 높이고 안정성을 유지할 수 있다.CI/ CD 종류  Jenkins : 오픈 소스 자동화 서버로, 다양한 플러그인을 통해 CI/CD 파이프라인 구축 가능  CircleCI : 클라우드 기반 CI/CD 서비스  TravisCI : 오픈 소스 프로젝트에 많이 사용되는 클라우드 기반 CI 서비스  GitLab CI : GitLab에 내장된 CI/CD 도구로, GitLab 프로젝트와 통합하여 사용  AWS CodePipeline : AWS 서비스와 통합된 CI/CD 서비스, AWS 환경에서의 배포를 자동화위의 도구들은 코드의 변경 사항을 감지하고, 자동으로 빌드 및 테스트를 수행하며, 성공적으로 테스트를 통과한 코드를 프로덕션 환경에 배포하는 과정을 지원한다."
  },
  
  {
    "title": "SQL Injection",
    "url": "/posts/java-sqlinjection/",
    "categories": "DB",
    "tags": "",
    "date": "2024-08-01 00:00:00 +0800",
    





    
    "snippet": "SQL Injection공격자가 보안상의 취약점을 노리고 쿼리에 자신이 작성한 sql 문을 입력하여 데이터베이스가 비정상적으로 동작하도록 하는 공격이 공격을 통해 데이터를 유출하거나, 데이터를 조작한다.과정공격자는 웹 사이트의 입력 필드나 url 파라미터에 sql 인젝션 취약점이 있는지 파악 후, 취약점이 확인되면 쿼리에 악의적인 sql 문을 삽입한다...",
    "content": "SQL Injection공격자가 보안상의 취약점을 노리고 쿼리에 자신이 작성한 sql 문을 입력하여 데이터베이스가 비정상적으로 동작하도록 하는 공격이 공격을 통해 데이터를 유출하거나, 데이터를 조작한다.과정공격자는 웹 사이트의 입력 필드나 url 파라미터에 sql 인젝션 취약점이 있는지 파악 후, 취약점이 확인되면 쿼리에 악의적인 sql 문을 삽입한다.예를 들어 “admin; –” 와 같이 입력함으로써 쿼리를 변경한다.이로써 데이터베이스가 의도치 않은 동작을 하게 만들어 사용자의 정보를 유출할 수 있다.이러한 작업을 통해 데이터를 유출할 수 있으며, 특정 사용자의 비밀번호를 변경, 관리자 권한을 얻어 시스텡 서버를 장악할 수 있다.또한 로그인시 비밀번호 검증을 피하여 로그인이 가능하다.예방하려면?PreparedStatement를 사용하면 드라이버가 자동으로 매개변수 값을 이스케이프 처리하여 SQL Injection 공격을 방지할 수 있다.Hibernate와 같은 ORM 프레임워크를 사용하여 SQL 쿼리 작성을 자동화함으로써 위험을 줄일 수 있다.모든 사용자의 입력을 검증하고 특수문자를 이스케이프 처리한다.또한 데이터베이스 권한에 최소한의 권한을 부여하는 것이 좋다.하지만 SQL 쿼리를 동적으로 생성하는 코드에서 PreparedStatement의 파라미터 바인딩을 적절히 사용하지 않으면 여전히 취약점이 발생할 수 있다.그리고 개발자가 입력 값을 제대로 검증하지 않거나, 특히 입력 값이 코드 또는 쿼리 구조의 일부로 사용되는 경우 공격에 노출될 수 있다.따라서 입력 값의 유형, 길이, 형식 등을 철저히 검증해야 하며, 모든 변수는 반드시 PreparedStatement의 파라미터로 바인딩해야 한다.필요에 따라 특수 문자를 이스케이프 처리하고, 입력 값이 SQL 구조에 영향을 주지 않도록 한다.이러한 방법을 통해 Sql injection를 예방할 수 있다."
  },
  
  {
    "title": "LIKE 와 full-scan",
    "url": "/posts/mysql-index/",
    "categories": "DB",
    "tags": "",
    "date": "2024-07-22 00:00:00 +0800",
    





    
    "snippet": "LIKELIKE 는 SQL에서 문자열 패턴 매칭을 위해서 사용합니다.주로 where절에서 특정 패턴과 일치하는 문자열을 검색하는데 사용할 수 있습니다.하지만 데이터가 많아지는 경우 문제가 생길 수 있습니다.어떤 문제가 생길까??LIKE 연산자는 와일드 카드를 사용하여 패턴 매칭을 합니다.와일드 카드가 패턴의 시작 부분에 위치하면 Mysql의 인덱스를 ...",
    "content": "LIKELIKE 는 SQL에서 문자열 패턴 매칭을 위해서 사용합니다.주로 where절에서 특정 패턴과 일치하는 문자열을 검색하는데 사용할 수 있습니다.하지만 데이터가 많아지는 경우 문제가 생길 수 있습니다.어떤 문제가 생길까??LIKE 연산자는 와일드 카드를 사용하여 패턴 매칭을 합니다.와일드 카드가 패턴의 시작 부분에 위치하면 Mysql의 인덱스를 효과적으로 사용할 수 없습니다.예를 들어 LIKE ‘%123’ 과 같은 패턴으로 사용하는 경우 인덱스를 사용할 수 없어 성능이 떨어질  있습니다.왜 LIKE ‘%abc’ 패턴은 인덱스를 사용할 수 없을까?인덱스는 데이터가 정렬된 순서대로 값을 찾을 수 있도록 합니다.인덱스를 사용하여 검색할 때 왼쪽에서 부터 일치하는 값을 찾습니다.예를 들어 ‘abc%’와 같은 패턴은 인덱스를 사용할 수 있으나 ‘%abc’ 의 패턴의 경우 시작점이 명화하지 않기 때문에 인덱스를 사용할 수 없습니다.이와 같은 패턴을 사용하는 경우 패턴 매칭을 위해 모든 데이터를 순차적으로 스캔해야 하기 때문에full table scan이 발생합니다.데이터의 양이 많을수록 성능에 영향을 미치며, I/O 비용이 많이 발생합니다.’=’ 으로 완전일치 검색하는 경우인덱스를 사용하여 검색하는 것을 확인할 수 있다.LIKE를 이용해서 검색하는 경우% 으로 시작하는 문자열을 검색하는 경우 인덱스를 사용하지 않는 것을 확인할 수 있다.  %가 위에 있는 문자열을 검색하는 경우 인덱스를 사용하는 것을 확인할 수 있다.  이제 속도 측면에서 확인해보자’=’을 사용한 경우LIKE을 사용한 경우      %를 시작 부분에서 사용하는 경우         %를 마지막 부분에서 사용하는 경우  % 가 앞에 나오는 경우가 속도가 떨어지는 것을 볼 수 있다."
  },
  
  {
    "title": "Transactional어노테이션 과 Proxy",
    "url": "/posts/transactional-proxy/",
    "categories": "Spring",
    "tags": "",
    "date": "2024-07-17 00:00:00 +0800",
    





    
    "snippet": "@Transactional은 어떻게 동작할까?메서드의 실행이 시작될 때 트랜잭션이 시작되고, 메서드가 정상적으로 종료되면 트랜잭션이 커밋되며,예외가 발생하면 트랜잭션이 롤백된다.      스프링은 @Transactional 어노테이션이 적용된 빈을 프록시 객체로 감싼다. 이 프록시는 실제 빈의 메서드를 호출하기 전에 트랜잭션 관련 로직을 처리한다.  ...",
    "content": "@Transactional은 어떻게 동작할까?메서드의 실행이 시작될 때 트랜잭션이 시작되고, 메서드가 정상적으로 종료되면 트랜잭션이 커밋되며,예외가 발생하면 트랜잭션이 롤백된다.      스프링은 @Transactional 어노테이션이 적용된 빈을 프록시 객체로 감싼다. 이 프록시는 실제 빈의 메서드를 호출하기 전에 트랜잭션 관련 로직을 처리한다.        프록시는 메서드 호출 전에 트랜잭션을 시작합니다. 이 과정에서 트랜잭션 매니저가 트랜잭션 경계를 설정한다.        실제 메서드가 실행된다.        메서드가 정상적으로 종료되면 트랜잭션이 커밋되고, 예외가 발생하면 트랜잭션이 롤백된다.  그러면 프록시란 무엇일까?Proxy프록시는 다른 객체의 대리자로서 동작하는 객체로 실제 객체를 감싸서 부가 기능을 제공한다.스프링은 주로 AOP를 통해 트랜잭션 관리를 위해 프록시를 사용한다.프록시의 역할프록시는 실제 객체의 호출 전후에 부가 기능을 추가할 수 있다. 예를 들어, 트랜잭션 시작과 종료, 예외 발생 시 롤백 등을 처리한다.    public interface MyService {        void performTransaction();    }    @Service    public class MyServiceImpl implements MyService {        @Transactional        public void performTransaction() {            // 트랜잭션 내에서 수행할 작업         }    }       // 프록시 객체 생성 및 사용    MyService myService = (MyService) context.getBean(\"myService\");    myService.performTransaction();프록시 객체는 실제 MyServiceImpl 객체를 감싸서 트랜잭션 관리를 추가한다.클라이언트는 프록시 객체를 통해 트랜잭션이 적용된 메서드를 호출한다.프록시 생성 방식      인터페이스 기반 프록시:기본적으로 스프링은 JDK 동적 프록시를 사용하여 인터페이스를 구현하는 프록시 객체를 생성합니다.        클래스 기반 프록시 (CGLIB): 만약 빈이 인터페이스를 구현하지 않았다면, 스프링은 CGLIB를 사용하여 클래스 기반 프록시를 생성합니다.  트랜잭션 경계 설정  트랜잭션 시작: 프록시는 메서드 실행 전에 PlatformTransactionManager를 사용하여 트랜잭션을 시작한다.  트랜잭션 커밋: 메서드가 정상적으로 완료되면 TransactionManager는 트랜잭션을 커밋한다.  트랜잭션 롤백: 메서드 실행 중에 체크드 예외 이외의 예외(런타임 예외, 오류)가 발생하면 트랜잭션이 롤백된다.트랜잭션 속성@Transactional 어노테이션은 다양한 속성을 통해 트랜잭션의 동작 방식을 조정할 수 있다.  propagation: 트랜잭션 전파 방식 (예: REQUIRED, REQUIRES_NEW 등)  isolation: 트랜잭션 격리 수준 (예: READ_COMMITTED, SERIALIZABLE 등)  timeout: 트랜잭션이 완료되어야 하는 최대 시간  readOnly: 읽기 전용 트랜잭션 여부  rollbackFor: 롤백할 예외 타입  noRollbackFor: 롤백하지 않을 예외 타입프록시는 @Transactional이 적용된 메서드 호출을 가로채서 트랜잭션 관련 처리를 수행한다.이를 통해 개발자는 트랜잭션 관리 로직을 직접 작성하지 않아도 된다.프록시는 다음과 같은 방식으로 트랜잭션을 처리한다.  메서드 호출 가로채기: 클라이언트가 @Transactional이 적용된 메서드를 호출할 때, 프록시가 이 호출을 가로챈다.  트랜잭션 시작: 프록시는 PlatformTransactionManager를 사용하여 트랜잭션을 시작한다.  메서드 실행: 실제 메서드를 실행한다.  트랜잭션 커밋/롤백: 메서드 실행이 성공하면 트랜잭션을 커밋하고, 예외가 발생하면 트랜잭션을 롤백한다.    @Servicepublic class OrderService {     @Autowired private OrderRepository orderRepository; @Transactional public void placeOrder(Order order) {     // 트랜잭션 시작     orderRepository.save(order);     // 추가 로직     // 트랜잭션 커밋 }}      위의 OrderService 클래스에서 placeOrder 메서드는 @Transactional 애노테이션을 사용하여 트랜잭션 경계를 정의하고 있다.스프링은 이 클래스의 프록시를 생성하여 placeOrder 메서드 호출을 가로채고 트랜잭션을 관리한다.프록시가 트랜잭션을 처리하는 과정  프록시 생성: 스프링이 애플리케이션 컨텍스트를 초기화할 때, OrderService 빈에 대한 프록시를 생성한다.  메서드 호출 가로채기: 클라이언트가 placeOrder 메서드를 호출하면 프록시가 이 호출을 가로챈다.  트랜잭션 시작: 프록시는 TransactionManager를 사용하여 트랜잭션을 시작한다.  실제 메서드 실행: 프록시는 실제 placeOrder 메서드를 호출한다.  트랜잭션 커밋/롤백: 메서드가 정상적으로 종료되면 프록시는 트랜잭션을 커밋하고, 예외가 발생하면 트랜잭션을 롤백한다.트랜잭션이 하는 일을 프록시가 대신하는 이유  일관성 유지: 트랜잭션은 데이터베이스의 일관성과 무결성을 유지하는 데 중요한 역할을 합니다. 프록시를 사용하면 이러한 트랜잭션 관리 로직을 쉽게 적용할 수 있다.  코드 간결화: 트랜잭션 관리를 코드에서 직접 구현하지 않아도 되므로 코드가 간결해진다.  중복 방지: 동일한 트랜잭션 관리 로직을 여러 곳에서 반복해서 작성할 필요가 없다.  AOP 지원: 프록시는 스프링 AOP(Aspect-Oriented Programming)를 사용하여 트랜잭션 관리와 같은 횡단 관심사를 쉽게 구현할 수 있게 해준다.프록시는 트랜잭션을 투명하게 처리하여 개발자가 비즈니스 로직에만 집중할 수 있게 해준다.프록시 없이 트랜잭션을 관리하려면, 트랜잭션 시작, 커밋, 롤백을 수동으로 처리해야 한다. 이것은 상당히 번거롭고 오류가 발생하기 쉽다.트랜잭션 관리 직접 구현@Servicepublic class OrderService {    @Autowired    private OrderRepository orderRepository;        @Autowired    private PlatformTransactionManager transactionManager;    public void placeOrder(Order order) {        TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition());        try {            // 트랜잭션 시작            orderRepository.save(order);            // 추가 비즈니스 로직 수행                        // 트랜잭션 커밋            transactionManager.commit(status);        } catch (Exception ex) {            // 예외 발생 시 트랜잭션 롤백            transactionManager.rollback(status);            throw ex;  // 예외 재발생        }    }}프록시 없이 트랜잭션 관리의 문제점  복잡성 증가: 트랜잭션을 시작하고, 커밋하거나 롤백하는 코드가 모든 트랜잭션 메서드에 반복적으로 작성되어야 한다.  오류 가능성: 트랜잭션 시작, 커밋, 롤백 로직을 수동으로 관리하다 보면 실수로 빠뜨리거나 잘못 구현할 가능성이 높다.  비즈니스 로직과 트랜잭션 로직의 혼합: 비즈니스 로직과 트랜잭션 관리 로직이 같은 메서드에 섞여 있어 코드가 지저분해지고 유지보수가 어렵다.  재사용성 부족: 트랜잭션 관리 로직을 재사용하기 어렵고, 모든 트랜잭션이 필요한 메서드에서 중복 코드가 발생한다.프록시를 사용할 때의 장점  코드 간결성: 트랜잭션 관리 로직을 각 메서드에 작성할 필요 없이 @Transactional 애노테이션을 사용하여 트랜잭션 경계를 지정할 수 있다.  오류 감소: 스프링이 트랜잭션 관리를 대신 처리하므로, 개발자가 실수로 트랜잭션 관리 로직을 잘못 구현할 가능성이 줄어든다.  비즈니스 로직 집중: 트랜잭션 관리 로직이 분리되어 비즈니스 로직에 집중할 수 있다.  재사용성 향상: 트랜잭션 관리 로직을 재사용할 수 있고, 코드 중복이 줄어든다.    @Servicepublic class OrderService { @Autowired private OrderRepository orderRepository; @Transactional public void placeOrder(Order order) {     orderRepository.save(order);     // 추가 비즈니스 로직 수행 }}       스프링이 프록시를 통해 트랜잭션 시작, 커밋, 롤백을 자동으로 처리하므로 개발자는 비즈니스 로직에만 집중할 수 있다.@Transactional 애노테이션을 이용하면 스프링 프레임워크가 프록시를 통해 트랜잭션 관리를 대신해준다. 이를 이해하기 위해서는 스프링의 AOP (Aspect-Oriented Programming) 개념과 프록시 패턴을 이해하는 것이 중요하다.@Transactional과 프록시의 관계      AOP와 프록시 패턴: 스프링은 AOP를 이용하여 @Transactional 애노테이션을 적용할 때 프록시 패턴을 사용한다. AOP는 관점 지향 프로그래밍을 의미하며, 코드의 특정 관점에서의 공통된 기능을 분리하여 관리하는 기술이다.        프록시의 역할: @Transactional 애노테이션이 붙은 메서드가 호출될 때, 스프링 프레임워크는 그 메서드를 호출하기 전후에 추가적인 작업을 수행하기 위해 프록시 객체를 생성한다. 이 프록시 객체는 원본 객체(서비스 클래스)를 감싸며, 트랜잭션 관리와 같은 공통된 기능을 제공한다.        트랜잭션 관리: @Transactional 애노테이션이 붙은 메서드에서는 트랜잭션을 시작하고, 메서드 실행을 감싸는 프록시가 트랜잭션을 커밋 또는 롤백한다. 이 과정에서 데이터베이스 연산의 성공 또는 실패에 따라 트랜잭션을 적절하게 처리한다.        간편한 설정: 개발자는 @Transactional 애노테이션을 사용하여 간편하게 트랜잭션 경계를 정의할 수 있다. 이는 개발자가 직접 트랜잭션을 시작하고, 커밋 또는 롤백하는 코드를 작성하지 않아도 되게 한다.  @Servicepublic class OrderService {    @Autowired    private OrderRepository orderRepository;    @Transactional    public void placeOrder(Order order) {        // 비즈니스 로직 수행        orderRepository.save(order);        // 추가적인 데이터베이스 작업 등    }    // 다른 트랜잭션 메서드    @Transactional    public void cancelOrder(Order order) {        order.setStatus(OrderStatus.CANCELED);        orderRepository.save(order);        // 추가적인 로직 수행    }}이 예시에서 @Transactional 애노테이션이 붙은 placeOrder()와 cancelOrder() 메서드는 스프링 프록시가 관리하는 트랜잭션 범위에서 실행된다. 메서드 내의 모든 데이터베이스 연산은 하나의 트랜잭션으로 묶이며, 이 트랜잭션은 메서드 실행 완료 후 자동으로 커밋 또는 롤백된다.따라서 @Transactional을 이용하면 개발자는 트랜잭션 관리에 대한 복잡한 코드를 작성하지 않아도 되며, 스프링 프록시가 이를 대신 처리하여 코드의 간결성과 유지보수성을 높여준다."
  },
  
  {
    "title": "Transaction",
    "url": "/posts/transaction/",
    "categories": "Spring",
    "tags": "",
    "date": "2024-07-17 00:00:00 +0800",
    





    
    "snippet": "트랜잭션일련의 작업들을 하나로 묶어서 처리하는 단위.트랜잭션이 성공적으로 완료되면 모든 작업이 영구적으로 반영되고, 하나라도 실패하면 모든 작업이 취소된다.데이터의 일관성과 결성을 유지하는 중요한 개념이다.트랜잭션의 개념은 많이 들어서 알고 있었지만 내가 완전하게 이해하기는 어려웠다.콘서트 티켓 예매를 예로 들어보자상품을 구매하려면 어떻게 해야할까? ...",
    "content": "트랜잭션일련의 작업들을 하나로 묶어서 처리하는 단위.트랜잭션이 성공적으로 완료되면 모든 작업이 영구적으로 반영되고, 하나라도 실패하면 모든 작업이 취소된다.데이터의 일관성과 결성을 유지하는 중요한 개념이다.트랜잭션의 개념은 많이 들어서 알고 있었지만 내가 완전하게 이해하기는 어려웠다.콘서트 티켓 예매를 예로 들어보자상품을 구매하려면 어떻게 해야할까?  상품의 재고를 확인한 후 장바구니에 추가합니다.  상품을 결제합니다.  결제가 성공하면 주문을 생성하고 재고를 업데이트합니다.이 과정에서 트랜잭션을 사용하지 않는다고 하면 어떤 문제가 발생할까?재고가 부족한 상황에서 동시에 여러 사용자가 같은 상품을 구매하려고 하면 재고가 음수가 될 수 있다.또한 결제가 성공했지만 주문 생성이 실패하거나 재고 업데이트가 실패하면 데이터의 일관성이 깨질 수 있다.그리고 결제에는 성공했지만 재고가 부족한 상황에서 주문생성에 실패하면, 사용자는 돈을 지불했지만 주문이 완료되지 않을 수 있다.상품 구매 시스템에서 트랜잭션을 사용하면 여러 단계의 구매 과정을 하나의 단위로 묶어서 처리할 수 있다.모든 단계가 성공적으로 완료되거나, 도중에 실패하는 경우 모든 변경 사항이 롤백되어 데이터의 무결성과 일관성을 보장할 수 있다.스프링에서는 @Transactional 어노테이션을 사용하여 트랜잭션을 관리할 수 있다.@Servicepublic class OrderService {    // 코드 생략        @Transactional    public void orderProcess(Long productId, int quantity, PaymentInfo paymentInfo) {        Product product = productRepository.findById(productId).orElseThrow(() -&gt; new RuntimeException(\"Product not found\"));        // 재고 확인        if (product.getStock() &lt; quantity) {            throw new RuntimeException(\"Not enough stock\");        }        // 결제 처리        paymentService.processPayment(paymentInfo);        // 재고 감소        product.setStock(product.getStock() - quantity);        productRepository.save(product);        // 주문 생성        Order order = new Order();        order.setProduct(product);        order.setQuantity(quantity);        order.setTotalPrice(product.getPrice() * quantity);        orderRepository.save(order);    }}클래스나 메서드에 붙여 해당 범위 내 메서드가 트랜잭션이 되도록 보장한다.직접 객체를 생성할 필요없이 선언만으로 관리가 가능하다.트랜잭션의 특징      Atomicity 원자성 한 트랜잭션 내의 모든 연산들이 완전히 수행되거나 전혀 수행되지 않는다. ( All or Nothing )        Consistency 일관성 어떤 트랜잭션이 수행되기 전에 데이터베이스가 일관된 상태를 가졌다면 트랜잭션이 수행된 후에 일관된 상태를 갖는다.        Isolation 격리성 or 고립 여러 트랜잭션이 동시에 실행될 때 각 트랜잭션은 다른 트랜잭션의 영향을 받지않고 독립적으로 실행되어야 한다.        Durability 영속성 성공적으로 완료된 트랜잭션의 결과를 영구적으로 보존해야 한다.  영속성 컨텍스트(Persistence Context)영속성 컨텍스트는 엔티티(Entity) 객체를 관리하는 환경주로 ORM 프레임워크에서 사용되며, 데이터베이스로부터 엔티티를 읽어올 때 영속성 컨텍스트에 저장하고, 엔티티의 상태 변경을 추적하여 데이터베이스에 동기화하는 기능을 제공한다.      엔티티의 생명주기영속성 컨텍스트는 엔티티의 생명주기를 관리한다.엔티티 객체가 생성되어 영속성 컨텍스트에 저장되면 ‘영속 상태’가 되며, 데이터베이스와 동기화된다.수정된 엔티티는 트랜잭션이 커밋될 때 자동으로 데이터베이스에 반영된다.        지연 로딩(Lazy Loading)영속성 컨텍스트는 지연 로딩을 지원하여, 연관된 엔티티 객체를 실제로 사용할 때까지 데이터베이스 조회를 지연시킬 수 있다.        동일성 보장영속성 컨텍스트는 동일한 엔티티 식별자를 가진 객체에 대해 같은 인스턴스를 반환하여 동일성을 보장한다.  트랜잭션과 영속성 컨텍스트의 상호작용트랜잭션과 영속성 컨텍스트는 서로 긴밀하게 연결되어 있다.      트랜잭션 범위: 트랜잭션은 데이터베이스 작업을 논리적 단위로 묶어주며, 트랜잭션 내에서 영속성 컨텍스트는 엔티티의 상태 변경을 추적한다.트랜잭션 커밋 시 영속성 컨텍스트는 데이터베이스에 변경 사항을 반영하고, 롤백 시 변경 사항을 취소한다.        트랜잭션의 격리 수준: 트랜잭션 격리 수준(Transaction Isolation Level)은 여러 트랜잭션이 동시에 실행될 때의 동작을 제어한다. 높은 격리 수준일수록 동시성 문제를 줄일 수 있지만, 성능 저하가 발생할 수 있다.        플러시(Flushing): 영속성 컨텍스트의 변경 사항을 데이터베이스에 동기화하는 작업 일반적으로 트랜잭션 커밋 시 자동으로 플러시가 발생한다.  즉, 영속성 컨텍스트는 엔티티의 생명주기를 관리하고, 트랜잭션은 데이터베이스 작업을 단위로 묶어 원자적인 실행을 보장한다.트랜잭션의 활용      데이터베이스 상태 변경 예를 들어, 사용자가 새로운 주문을 생성할 때, 주문 내역을 데이터베이스에 반영하는 작업은 하나의 트랜잭션으로 묶인다.이 경우 주문 생성, 결제 정보 저장, 재고 조정 등 여러 개의 데이터베이스 작업이 하나의 원자적인 작업 단위로 묶이게 된다.        예외 처리와 롤백 트랜잭션은 예외 상황이 발생했을 때 데이터베이스 상태를 롤백하여 이전 상태로 복원한다.예를 들어, 주문 생성 중 결제 과정에서 오류가 발생하면, 주문과 관련된 모든 변경 사항을 취소하고 이전 상태로 돌아가야 한다.        동시성 제어 트랜잭션은 동시에 여러 사용자가 동일한 데이터에 접근할 때 발생할 수 있는 문제를 방지한다. 여러 사용자가 동시에 주문을 생성 할 때, 트랜잭션을 이용하여 충돌을 방지하고 일관성 있는 데이터 처리를 보장해야 한다.        복잡한 비즈니스 로직 처리 여러 개의 서비스 호출이나 데이터 조작 작업을 하나의 트랜잭션으로 묶어서 실행하면, 데이터 일관성을 유지하면서 원자적으로 처리해야 한다.        권한 관리 및 보안 트랜잭션을 시작할 때 권한을 확인하고, 트랜잭션이 종료될 때 권한을 제거하는 등의 작업을 통해 보안을 강화한다.  "
  },
  
  {
    "title": "JWT",
    "url": "/posts/spring-jwt/",
    "categories": "Spring",
    "tags": "",
    "date": "2024-07-02 00:00:00 +0800",
    





    
    "snippet": "프로젝트 중에 JWT를 사용하여서잘 몰라서.. 공부하고자이전에는?JWT가 보급되기 전에는 주로 세션 기반 인증 방식이 사용되었다.세션의 Stateful로 상태를 유지하는 것이 특징이다.사용자의 정보를 서버에 저장하고, 클라이언트는 세션ID를 통해 인증 상태를 유지한다.세션은 서버 메모리나 데이터베이스에 저장되어야하기 때문에 서버 측에서 상태를 유지해야...",
    "content": "프로젝트 중에 JWT를 사용하여서잘 몰라서.. 공부하고자이전에는?JWT가 보급되기 전에는 주로 세션 기반 인증 방식이 사용되었다.세션의 Stateful로 상태를 유지하는 것이 특징이다.사용자의 정보를 서버에 저장하고, 클라이언트는 세션ID를 통해 인증 상태를 유지한다.세션은 서버 메모리나 데이터베이스에 저장되어야하기 때문에 서버 측에서 상태를 유지해야 한다.매 요청마다 서버와 통신해야하며, 사용자가 많아지는 경우 부하가 심해질 수 있다.이러한 문제로 등장한 것이 JWT로 Stateless 인 것이 특징이다.JWTJSON Web Token의 약자로 정보를 JSON 형태로 클라이언트에 저장하고 서버는 해당 토큰을 검증하여인증을 처리하는 방식이다.토큰 안에 미리 인증에 필요한 정보를 넣어두면 매 요청마다 서버와 통신할 필요가 없다.이로 인해 서버 부하와 같은 문제를 해결할 수 있다.구조헤더, 페이로드, 서명 세 부분으로 구성된다.헤더 부분은 알고리즘 방식과 토큰의 타입을 갖으며, 서명 생성을 위해 어떤 알고리즘을 사용할지 식별하는 부분이다.페이로드는 클레임이라고 불리는 정보 조각을 포함한다.클레임은 토큰에 추가할 정보를 의미하며 사용자 ID, 권한 정보등이 포함된다.하지만 디코딩을 통해 들어있는 정보를 확이할 수 있기 때문에 민감한 정보는 포함하지 않는 것이 좋다.서명은 토큰을 인코딩하거나 유효성 검증을 위해서 사용되는 부분으로,헤더와 페이로드를 합친 후 비밀키를 사용하여 생성한다.서버는 클라이언트로부터 받은 토큰을 검증하기 위해 서명 부분을 해싱 알고리즘과 비밀키로 다시 생성하고이를 클라이언트가 전달한 서명과 비교하여, 일치하면 인증이 유요한 것으로 판단한다."
  },
  
  {
    "title": "영속성 컨텍스",
    "url": "/posts/jpa-%EC%98%81%EC%86%8D%EC%84%B1%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/",
    "categories": "JPA",
    "tags": "",
    "date": "2024-07-01 00:00:00 +0800",
    





    
    "snippet": "영속성 컨텍스트JPA 는 영속성 컨텍스트라는 작은 메모리 공간을 갖는다. 영속성 컨텍스트는 엔티티 매니저의 생명주기와 일치하며, 엔티티를 관리하고 데이터베이스와 통신을 처리한다.하나의 영속성 컨텍스트는 트랜잭션 단위로 관리되며, 엔티티의 상태를 추적하고 엔티티를 데이터베이스와 동기화한다.@Service@Transactionalpublic class U...",
    "content": "영속성 컨텍스트JPA 는 영속성 컨텍스트라는 작은 메모리 공간을 갖는다. 영속성 컨텍스트는 엔티티 매니저의 생명주기와 일치하며, 엔티티를 관리하고 데이터베이스와 통신을 처리한다.하나의 영속성 컨텍스트는 트랜잭션 단위로 관리되며, 엔티티의 상태를 추적하고 엔티티를 데이터베이스와 동기화한다.@Service@Transactionalpublic class UserService {        @PersistenceContext    private EntityManager em;        public void saveUser(User user) {        // 엔티티를 영속성 컨텍스트에 저장        em.persist(user);    }        public User findUser(Long userId) {      // 1차 캐시에서 엔티티를 조회 (데이터베이스 조회 필요 없음)em.find(User.class, user.getId()) 는 JPA 에서 제공하는 메서드로 데이터베이스에 접근하여      return em.find(User.class, userId);      지정된 엔티티 클래스와 키를 기반으로 엔티티를 조회합니다.    }        public void updateUser(User user) {      // 엔티티의 상태 변경 (Dirty Checking)      User managedUser = em.find(User.class, user.getId());      managedUser.setUsername(user.getUsername());      managedUser.setEmail(user.getEmail());      // 트랜잭션이 커밋될 때 데이터베이스에 자동으로 반영됨이로써 반복적으로 조죄할 때 데이터베이스에 대한 추가적인 조회를 피할 수 있으며 성능이 향상됩니다.    }            public void deleteUser(Long userId) {        // 1캐시는 영속성 컨텍스트의 생명주기에 의존하기 때문에 트랜잭션이 종료되면 1차 캐시도 함께 종료됩니다.         // 엔티티를 영속성 컨텍스트에서 제거        // 이후에 같은 엔티티를 조회할 경 다시 데이터베이스에서 조회해야 합니다.        User user = em.find(User.class, userId);        em.remove(user);        // 트랜잭션이 커밋될 때 데이터베이스에서 삭제됨    }}1차 캐시영속성 컨텍스트의 일부로 JVM 메모리에 위치합니다. 따라서 데이터베이스에 접근하는 것보다 훨씬 빠른 접근이 가능합니다.엔티티의 식별자를 키로 사용하여 엔티티를 저장한다. 이 식별자를 사용하여 빠르게 엔티티를 조회할 수 있다.    public User findUser(Long userId) {        // 1차 캐시에서 엔티티를 조회 (데이터베이스 조회 필요 없음)        return em.find(User.class, userId);    }em.find(User.class, user.getId()) 메서드는 데이터베이스에서 엔티티를 조회하고 이 엔티티를 영속성 컨텍스트에 저장한다.이때 저장된 엔티티는 1차 캐시에 저장된다.이후 동일한 엔티티를 다시 조회하는 경우 영속성 컨텍스트에서 먼저 조회하여 데이터베이스에 접근하지 않고 1차 캐시에 저장된 엔티티를 반환한다.1차 캐시를 통해 동일한 엔티티를 반복적으로 조회할 때 데이터베이스에 대한 추가적인 조회를 피할 수 있다영속성 컨텍스트는 트랜잭션 범위 내에서 관리되기 때문 동일한 엔티티에 대해 일관된 상태를 유지할 수 있다.하지만 컨텍스트의 생명주기에 의존하기 때문에 트랜잭션이 종료되면 1차 캐시도 함께 종료된다.따라섯 이후에 같은 엔티티를 조회할 때는 다시 데이터베이스에서 조회해야 한다.1차 캐시는 메모리에 저장되기 때문에 많은 수의 엔티티를 동시에 처리하 할 때 메모리 사용에 주의해야 한다.지연 로딩연관된 엔티티나 컬렉션을 실제로 사용할 때까지 데이터베이스에서 로딩하지 않고 필요한 시점에 로딩하는 기능이다.지연로딩은 FetchType.LAZY로 설정하며, 실제 엔티티가 필요한 시점에 데이터베이스에서 조회한다.반면에 즉시로딩(FetchType.EAGER)은 엔티티를 조회할 때 연관된 엔티티들을 즉시 한번에 조회한다. 이는 성능 저하를 초래할 수 있으므로 주의해서 사용해야 한다.@Entity@Table(name = \"orders\")public class Order {    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    @Column(name = \"order_id\")    private Long id;    @ManyToOne(fetch = LAZY)    @JoinColumn(name = \"user_id\")    private User user;}단순한 관계나 적은 데이터 양을 다룰 때는 즉시로딩을 사용하는 것이 좋다.대규모 데이터를 다루거나 성능 최적화가 필요한 경우에는 지연로딩을 고려해야 한다.기본적으로는 지연로딩을 사용하고, 성능 문제나 데이터 접근 패턴에 따라 필요할 때 즉시로딩으로 변경하는 것이 바람직하다.변경 감지트랜잭션 내에서 엔티티의 상태 변경을 감지하여 자동으로 데이터베이스와 동기화한다.트랜잭션 내에서 엔티티의 수정이 이루어져야 변경 감지가 동작합니다. 트랜잭션이 커밋될 때 변경 사항이 데이터베이스에 반영된다.트랜잭션이 커밋되기 전까지는 데이터베이스에 변경 사항이 반영되지 않는다.    @PersistenceContext    private EntityManager entityManager;    public void updateProduct(Long productId, String newName, double newPrice) {        // 엔티티 조회        Product product = entityManager.find(Product.class, productId);        // 엔티티 수정        product.setName(newName);        product.setPrice(newPrice);        // 변경 감지가 발생하여 자동으로 데이터베이스에 반영됨    }}별도의 save 메서드 호출이 필요하지 않다.트랜잭션 범위영속성 컨텍스트는 트랜잭션 범위 내에서 엔티티를 관리하므로, 트랜잭션이 커밋되거나 롤백되기 전까엔티티의 변경 사항을 추적하고 커밋할 때 최종적으로 데이터베이스에 반영한다."
  },
  
  {
    "title": "JPA란",
    "url": "/posts/jpa-jpa/",
    "categories": "JPA",
    "tags": "",
    "date": "2024-07-01 00:00:00 +0800",
    





    
    "snippet": "JPA자바 애플리케이션에서 관계형 데이터베이스를 관리하고 조작할 수 있도록 도와주는 표준 API자바 객체를 데이터베이스 테이블에 매핑하여 객체지향 프로그래밍과 관계형 데이터베이스 간의 불일치를 해결한다.JPA를 사용하면 SQL쿼리를 직접 작성하지 않고도 데이터베이스 작업을 수행할 수 있다.등장 배경??JPA 가 등장하기 전에는 객체지향 프로그래밍 언어...",
    "content": "JPA자바 애플리케이션에서 관계형 데이터베이스를 관리하고 조작할 수 있도록 도와주는 표준 API자바 객체를 데이터베이스 테이블에 매핑하여 객체지향 프로그래밍과 관계형 데이터베이스 간의 불일치를 해결한다.JPA를 사용하면 SQL쿼리를 직접 작성하지 않고도 데이터베이스 작업을 수행할 수 있다.등장 배경??JPA 가 등장하기 전에는 객체지향 프로그래밍 언어와 관계형 데이터베이스 간의 매핑을 직접 구현했다.주로 JDBC를 이용하여 데이터베이스와 연결하여 쿼리를 실행하고 결과를 가져왔다.Connection 으로 데이터베이스를 연결을 설정하고 관리하였고, 개발자는 쿼리를 직접 작성하여 데이터베이스에 보낸 후반환된 결과를 받아 자바 객체로 매핑하는 작업을 수동을 해주었다.추가적으로 SQL 실행 중 발생할 수 있는 예외를 처리해야 한다.SQL을 사용하여 데이터베이스와 상호작용하고, 반복적인 코드작성이 생겼다.쿼리를 직접 다루기 때문에 발생할 수 있는 오류가 많고 유지보수가 어렵다.또한, 객체 지향 언어의 클래스와 객체를 관계형 데이터베이스의 테이블과 매핑하는 과정에서 일관성을 유지하기가 어렵다.따라서 이러한 문제를 해결하기 위해 나온 것이 ORM 이다.ORM 프레임워크객체와 데이터베이스 매핑 자동화  ORM 프레임워크는 객체와 데이터베이스 간의 매핑을 자동으로 처리해줍니다.CRUD 작업의 객체지향적 처리  CRUD(Create, Read, Update, Delete) 작업을 객체지향적으로 처리할 수 있습니다.표준화된 인터페이스 제공  JPA와 같은 ORM 프레임워크는 표준화된 인터페이스를 제공하여, 다양한 데이터베이스와도 쉽게 연동할 수 있습니다.성능 최적화 및 편의성 제공  내부적으로 캐싱, 지연로딩 등의 기법을 사용하여 성능을 최적화하고, 개발자가 데이터베이스와의 상호작용을 편리하게 처리할 수 있습니다.JPA는 개발자가 객체지향적으로 데이터를 다루면서 이것을 관계형 데이터베이스에 저장하고 조회할 수 있도록 준다.객체와 테이블 간의 매핑 규칙을 정의하고 이를 바탕으로 JPA 구현체가 SQL을 생성하여 데이터베이스와 상호작용한다.ORM을 통해 객체와 데이터베이스 간의 매핑을 자동화하기 때문에 개발자는 객체지향적인 코드를 집중적으로 작성할 수 있다.데이터베이스 스키마의 변경이 발생해도 JPA가 자동으로 SQL을 생성하여 매핑을 처리해주기 때문에 유지보수가 편리하다.개념  엔티티          영속성을 가진 객체      데이터베이스 테이블에 매핑되는 자바 클래스로 각 인스턴스는 테이블의 행을 나타낸다.        엔티티 매니저          엔티티의 생명주기를 관리하고 데이터베이스와 상호작용한다.      엔티티를 저장, 삭제, 조회하는 등의 작업을 수행한다.        영속성 컨텍스트          엔티티 객체를 관리하는 메모리상의 공간      데이터베이스와의 상호작용을 중재하는 역할을 한다.        JPQL          엔티티 객체를 대상으로 쿼리를 작성한다.      영속성(Persistence)이란?  데이터를 일시적인 저장소가 아닌 영구적인 저장소에 저장하는 것을 의미한다.영속성을 통해 프로그램이 종료되더라도 데이터가 손실되지 않고 유지될 수 있으며 시스템의 오류나 충돌이 발생했을 때데이터를 복구할 수 있다.여러 프로그램이나 사용자가 동일한 데이터를 사용할 수 있으며 트랜잭션을 통해 데이터의 일관성을 유지할 수 있다.ex) 데이터를 데이터베이스에 저장하여 프로그램이 종료되더라도 데이터가 유지되도록 한다.데이터를 파일에 저장하여 프로그램이 종료되더라도 데이터가 파일에 남아있도록 한다.JPA에서의 “영속성”은 엔티티 객체의 생명 주기 중 하나로, 엔티티 객체가 영속성컨텍스트에 의해 관리되는 상태를 말한다.엔티티 객체를 영속성 컨텍스트에 저장하고 이를 통해 데이터베이스와의 지속적인 동기화를 관리한다.자바에서는 JPA를 사용하여 영속성을 관리할 수 있다.이를 통해 객체를 데이터베이스 테이블에 매핑하고 CRUD 작업을 쉽게 수행할 수 있다.영속성 컨텍스트엔티티 매니저가 관리하는 엔티티 객체들의 집합영속성 컨텍스트는 엔티티 객체를 캐시로 관리하여 데이터베이스와의 상호작용을 최적화하고 객체 상태의 변경을추적한다.엔티티 객체를 메모리에 저장하고 관리하며 이를 통해 엔티티 객체가 데이터베이스와 동기화된다.엔티티 객체를 메모리에 캐싱하여, 동일한 트랜잭션 내에서 반복적인 데이터베이스 접근을 줄인다. (1차 캐시)엔티티의 상태 변화를 감지하여 트랜잭션이 커밋될 때 변경된 내용을 데이터베이스에 반영한다. (변경감지)필요한 시점에 데이터베이스에서 데이터를 로드하는 기능을 제공한다. (지연로딩)엔티티 객체의 생명 주기      비영속 (Transient)엔티티 객체가 영속성 컨텍스트에 의해 관릳되지 않은 상태로 데이터베이스와 연관이 없다.        영속 (Persistent)엔티티 객체가 영속성 컨텍스트에 의해 관리되는 상태엔티티 매니저를 통해 데이터베이스에 저장됩니다.        준영속 (Detached)한 번 영속상태 였지만 현재는 영속성 컨텍스트에 의해 관리되지 않는 상태영속성 컨텍스트가 닫히거나 detch() 메서드를 호출하여 엔티티가 분리될 때 발생한다.        삭제 (Removed)엔티티 객체가 영속성 컨텍스트에 의해 삭제된 상태데이터베이스에서 해당 엔티티가 삭제된다.  주요 어노테이션  @Entity : 클래스가 엔티티임을 선언한다.  @Table : 엔티티와 매핑되는 데이터베이스 테이블을 지정한다.  @Id : 엔티티의 기본키를 지정한다.  @GeneratedValue : 기본키 값을 자동으로 생성하는 전략을 지정한다.  @Column : 엔티티 필드와 매핑되는 데이터베이스 컬럼을 지정한다.@Entity@Table(name = \"user\")@NoArgsConstructor(access = AccessLevel.PROTECTED)@Getter @Setterpublic class User{    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    @Column(name = \"user_id\", updatable = false)    private Long id;    private String email;    private String password;    private String phone;    }JPA는 자동으로 엔티티와 데이터베이스 테이블 간의 매핑을 처리해주기때문에 개발자는 별도의 SQL 쿼리를 작성할 필요가 없다."
  },
  
  {
    "title": "Blocking vs Non-Blocking",
    "url": "/posts/java-%EB%B8%94%EB%A1%9C%ED%82%B9-%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9/",
    "categories": "Java",
    "tags": "",
    "date": "2024-07-01 00:00:00 +0800",
    





    
    "snippet": "Blocking vs Non-BlockingBlocking IO작업이 완료될 때까지 스레드가 대기하는 방식Non-Blocking IO작업이 완료되지 않더라도 대기하지 않고 다른 작업을 처리하는 방식Blocking IO의 문제입출력 작업이 완료될때 까지 다른 스레드가 대기해야하기 때문에 멀티 스레드 환경에서 대기 시간이 오래 걸릴 수 있다. 많은 클라이...",
    "content": "Blocking vs Non-BlockingBlocking IO작업이 완료될 때까지 스레드가 대기하는 방식Non-Blocking IO작업이 완료되지 않더라도 대기하지 않고 다른 작업을 처리하는 방식Blocking IO의 문제입출력 작업이 완료될때 까지 다른 스레드가 대기해야하기 때문에 멀티 스레드 환경에서 대기 시간이 오래 걸릴 수 있다. 많은 클라이언트의 요청을 동시에 처리할 수 없으며 블록 상태가 발생할 수 있다.Non-Blocking IO에서의 장단점작업이 완료될 때까지 기다리지 않고 해당 작업을 수행하는 동안 다른 작업을 수행할 수 있다.요청한 작업이 완료되면, 결과를 처리할 수 있도록 콜백 함수 등을 통해 알림을 받는다.대기 시간이 최소화되어 시스템이 더 효율적을 자원을 이용할 수 있으며 여러 작업을 동시에 처리하기 때문에 응답성이 향상된다.비교적 적은 스레드로 많은 요청을 처리할 수 있어 스케일링에 유리하다.IO 작업이 많이 발생하는 환경에 효과적이다.하지만 비동기 프로그래밍으로 동기적 프로그래밍보다 복잡하며 콜백 지옥과 같은 문제가 발생할 수 있다.또한 이벤트를 기반으로 동작하기 때문에 실행 흐름을 추적, 디버깅하는 것이 어렵다.비동기 작업이 많아질수록 메모리 사용량이 증가할 수 있다.주로 다수의 클라이언트 요청을 비동기로 처리할 때 사용되며, 또한 웹 서버에서 여러 요청을 동시에 처리하고IO 작업이 완료될 때까지 기다리지 않고 다른 요청을 처리하는데 유용하게 사용된다.대규모 데이터베이스나 파일 처리에서 비동기 IO는 시스템의 처리량을 향상 시키는데 기여할 수 있다.구현방법에는 가장 기본적인 방법으로 자바스크립트에서 콜백함수를 사용하거나 promise 를 사용하는 방법이 있다.또한 자바의 NIO 와 같은 라이브러리를 사용하여 블로킹 IO 를 비동기적으로 처리할 수 있다."
  },
  
  {
    "title": "어노테이션 RequiredArgsConstructor, AllArgsConstructor",
    "url": "/posts/spring-allargsconstructor-requiredargsconstructor/",
    "categories": "Spring",
    "tags": "",
    "date": "2024-06-27 00:00:00 +0800",
    





    
    "snippet": "프로젝트 진행 중 계속해서 의존성 주입 문제가 생겼다.@Service@RequiredArgsConstructorpublic class SmsSenderService {    private final SmsCertification smsCertification;    @Value(\"${coolsms.apikey}\")    private String ap...",
    "content": "프로젝트 진행 중 계속해서 의존성 주입 문제가 생겼다.@Service@RequiredArgsConstructorpublic class SmsSenderService {    private final SmsCertification smsCertification;    @Value(\"${coolsms.apikey}\")    private String apiKey;    @Value(\"${coolsms.apisecret}\")    private String apiSecret;    @Value(\"${coolsms.fromnumber}\")    private String fromNumber;        // 코드 생략}@RequiredArgsConstructor 와 @AllArgsConstructor 를 알아보자둘 다 Lombok 에서 제공하는 어노테이션으로 코드를 간결하게 작성할 수 있도록 도와주는 역할을 한다.@RequiredArgsConstructor클래스의 final로 선언된 필드나 @NonNull 로 표시된 필드를 기반으로 생성자를 생성한다.생성자는 이러한 필드들을 매개변수로 받아 초기화한다.@RequiredArgsConstructorpublic class User {    private final String name;  // final로 선언    private final int age;            /* 아래와 같은 생성자가 자동으로 생성됩니다.    public User(String name, int age) {      this.name = name;      this.age = age;    }     */}  즉, 초기화되지 않은 final 필드의 생성자를 생성한다.@AllArgsConstructor모든 필드를 기반으로 생성자를 생성한다.final로 선언되지 않은 필드도 포함하여 모든 필드를 매개변수로 받는 생성자를 생성한다.@AllArgsConstructorpublic class User {    private String name;    private int age;        /* 아래와 같은 생성자가 자동으로 생성됩니다.    public User(String name, int age) {      this.name = name;      this.age = age;    }     */}@Value 와 @RequiredArgsConstructor?@Value 이 뭘까?final 로 선언한 필드에 @Value를 사용하면?스프링이 빈을 생성할 때 해당 필드를 초기화할 수 없기 때문에 에러가 발생한다.@Value 을 사용할 때는 생성자 인젝션을 사용하지 않기 때문에 @RequiredArgsConstructor 를 사용하여생성자를 자동을 생성할 수 없다.@Value 와 @AllArgsConstructor?스프링은 빈을 초기화 할 때 @Value 어노테이션을 사용하여 외부 프로퍼티 파일에서 값을 주입할 수 있다.이것은 생성자 인젝션을 지원하지 않는다.따라서 @AllArgsConstructor을 사용할 때는 스프링이 @Value 어노테이션을 통해 초기화할 수 없는 필드에 대해서는 생성자를 자동으로 생성하지 않는다. 이로 인해 apiKey, apiSecret, fromNumber 필드는 @Value 어노테이션을 통해 초기화할 수 없어서 에러가 발생한다."
  },
  
  {
    "title": "index와 B-tree 그리고 Hash Index",
    "url": "/posts/db-index/",
    "categories": "DB",
    "tags": "",
    "date": "2024-06-27 00:00:00 +0800",
    





    
    "snippet": "Index  데이터베이스 테이블에서 데이터를 빠르게 검색할 수 있도록 도와주는 데이터 구조인덱스는 테이블 내의 1개 또는 여러 개의 컬럼을 이용하여 생성할 수 있다.인덱스는 데이터베이스의 테이블과 별도로 저장되며, 인덱스를 저장하기 위한 추가적인 저장공간이 필요하다.테이블의 특정 컬럼에 대해서 인덱스를 생성하면, 해당 컬럼의 데이터를 정렬한 후 별도의...",
    "content": "Index  데이터베이스 테이블에서 데이터를 빠르게 검색할 수 있도록 도와주는 데이터 구조인덱스는 테이블 내의 1개 또는 여러 개의 컬럼을 이용하여 생성할 수 있다.인덱스는 데이터베이스의 테이블과 별도로 저장되며, 인덱스를 저장하기 위한 추가적인 저장공간이 필요하다.테이블의 특정 컬럼에 대해서 인덱스를 생성하면, 해당 컬럼의 데이터를 정렬한 후 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장된다.  키 값 : 인덱스가 참조하는 컬럼 값  포인터/ 참조 : 실제 데이터가 저장된 테이블의 행을 가리키는 포인터해당 컬럼의 값을 키로 사용하기 때문에 테이블 전체를 스캔하지 않고 원하는 데이터를 찾을 수 있다.정렬된 상태로 저장이 되기 때문에 정렬된 데이터에 빠르게 접근할 수 있어, 검색 속도를 향상 시킨다.장점인덱스를 이용하면 특정 키 값을 빠르게 검색할 수 있습니다. 인덱스는 정렬된 데이터 구조이기 때문에, 비트리 인덱스와 같은 알고리즘을 사용하여 데이터를 빠르게 찾을 수 있다.인덱스를 사용하면 전체 테이블을 스캔하지 않고 원하는 데이터를 찾을 수 있다. 따라서 더 빠른 응답시간을 제공할 수 있다.정렬되지 않은 데이터의 경우 특정 키 값을 찾기 위해 데이터를 순차적으로 스캔해야 하기 때문에 선형 검색을 수행해야 한다.따라서 데이터가 많아질수록 검색 속도가 느려질 수 있다.단점인덱스는 추가적인 저장공간을 필요로 하기 때문에 데이터베이스의 크기가 증가할 수 있다.또한 데이터의 삽입, 삭제, 수정시 인덱스도 리밸런싱되어야 하기 때문에 오버헤드가 발생할 수 있다.키를 기준으로 검색하는 경우 빠른 속도를 기대할 수 있으나 다른 컬럼을 기준으로 검색하는 경우, 해당 컬럼이 인덱스로 지정되지 않은 경우성능 저하가 발생할 수 있다. 따러서 자주 사용되는 검색 조건에 대해 적절한 인덱스를 생성하고 관리하는 것이 중요하다.언제 사용하는지특정 컬럼이 자주 검색 조건으로 사용될 때 인덱스를 생성하는 것이 효율적이다.예로 주문 번호, 날짜, 사용자 ID 등 검색이 빈번한 컬럼은 인덱스를 통해 검색 성능을 향상시킬 수 있다.정렬과 같은 그룹화 작업이 자주 일어나는 컬럼에 사용하는 것도 쿼리의 성능을 향상시킬 수 있다.조인 연산에 사용되는 컬럼에 인덱스를 생성하거나, 범위 검색이나 부분 일치 검색을 수행할 때 사용할 수 있다.하지만 너무 많은 인덱스를 생성하는 것은 성능 저하를 일으킬 수 있어, 자주 사용되는 검색 조건 등 꼭 필요한 인덱스만 생성하는 것이 좋다.인덱스 구조B-tree 인덱스Balanced tree의 약자로 균형잡힌 트리 구조이다. 모든 리프노드가 동일한 깊이에 위치하여, 노드의 삽입 및 삭제 시 특정 규칙에 맞게 재정렬 되어 밸런스를 유지하는 트리이다.각 노드는 여러 개의 키와 포인터를 가지고 있으며 키는 정렬된 상태로 저장된다.검색시 루트 노드부터 시작하여 비교를 통해 적절한 리프노드에 도달한다.해시 인덱스해시 함수를 사용하여 키 값을 해시코드로 변환하고 이를 기반으로 데이터를 저장하고 검색하는 구조이다.키와 값의 구조로 되어있기 때문에 해시 인덱스의는 탐색 시간이 O(1) 로 탐색 시간이 빠르다.정확하게 일치하는 검색에 대해서는 빠르지만 범위를 검색하는 경우에는 적합하지 않다.해시 인덱스는 데이터가 해시코드에 따라 분산되어 있습니다. 그래서 데이터를 정렬된 순서로 접근하는 것이 어렵다.데이터들이 정렬되어 있지 않기 때문에 특정 기준보다 크거나 작은 값, 부등호 연에 대해 검색이 적합하지 않다."
  },
  
  {
    "title": "Encoding",
    "url": "/posts/java-encoding/",
    "categories": "Java",
    "tags": "",
    "date": "2024-06-26 00:00:00 +0800",
    





    
    "snippet": "인코딩?데이터를 특정 형식으로 변환하여 저장하거나 전송할 수 있도록 하는 과정인코딩을 통해 데이터를 안전하게 전송할 수 있으며 보다 효과적으로 저장할 수 있다.서로 다른 시스템이나 프로그램 간의 데이터 호환성을 유지하며 데이터 전송 중 보안을 강화하고 민감한 정보를 보호한다.또한 데이터를 압축하여 저장 공간을 절약하거나, 특정 형식에 맞추어 데이터를 ...",
    "content": "인코딩?데이터를 특정 형식으로 변환하여 저장하거나 전송할 수 있도록 하는 과정인코딩을 통해 데이터를 안전하게 전송할 수 있으며 보다 효과적으로 저장할 수 있다.서로 다른 시스템이나 프로그램 간의 데이터 호환성을 유지하며 데이터 전송 중 보안을 강화하고 민감한 정보를 보호한다.또한 데이터를 압축하여 저장 공간을 절약하거나, 특정 형식에 맞추어 데이터를 저장한다.데이터를 더 빠르고 안정적으로 전송할 수 있도록 최적화한다.Mysql 에서 HTML 인코딩HTML 데이터를 데이터베이스에 저장할 때 특수문자나 HTML 태그로 인해 문제가 발생할 수 있다.이러한 문제를 해결하기 위해 데이터 인코딩을 사용할 수 있다.Mysql에서 HTML 태그를 인코딩하여 데이터베이스에 저장하려면 HTML 특수 문자를 이스케이프 처리해야 한다.이를 통해 태그를 안전하게 저장하고 XSS 공격을 방지하는데 도움이 된다.방법Apache Commons Text 라이브러리 설정Apache Commons Text 라이브러리 추가 필요PreparedStatementHTML 데이터를 그대로 저장한다.Base64 인코딩바이너리 데이터를 ASCII 문자열로 변환하는 방법으로,  바이너리 텍스트 형식의 데이터베이스나텍스트 전송 프로토콜을 통해 안전하게 전송하고 저장할 수 있다.HTML 데이터를 Base64로 인코딩하면, 특수 문자를 포함하는 HTML 태그를 안전하게 데이터베이스에 저장할 수 있다.그 외 종류ASCII 인코딩 (American Standard Code for Information Interchange)가장 오래된 인코딩 방식 중 하나로, 7비트로 표현되며 영문 알파벳, 숫자, 특수 문자를 포함하며, 확장된 형태 8비트의 ASCII도 있습니다.UTF-8 (Unicode Transformation Format - 8-bit)현재 가장 일반적으로 사용되는 문자 인코딩 방식으로 유니코드(Unicode)를 위한 다양한 문자를 다룰 수 있습니다. 가변 길이 문자 인코딩 방식으로, ASCII와 호환되며 다국적 텍스트 처리에 적합합니다.UTF-16유니코드 문자를 16비트 단위로 인코딩하는 방식입니다. 주로 한글, 한자 등 다국적 문자 처리에 사용됩니다.UTF-32유니코드 문자를 32비트 단위로 인코딩하는 방식입니다. 모든 문자를 고정 길이로 표현할 수 있으며, UTF-16과 UTF-8에 비해 메모리 공간을 많이 사용합니다.URL 인코딩 (Percent Encoding)URL에 사용할 수 없는 문자나 특수 문자를 ‘%XX’와 같은 형태로 인코딩하는 방식입니다.HTML 엔티티 인코딩HTML 문서에서 사용할 수 없는 문자나 특수 기호를 대체 문자열(&amp;, &lt;, &gt;, 등)로 변환하는 방식입니다."
  },
  
  {
    "title": "컴퓨터 구조",
    "url": "/posts/os-basic/",
    "categories": "OS",
    "tags": "",
    "date": "2024-06-20 00:00:00 +0800",
    





    
    "snippet": "컴퓨터 구성 요소CPU중앙 처리 장치로 컴퓨터의 두뇌에 해당하며, 연산과 명령을 처리한다.명령어 처리 속도로 성능이 결정되며, 명령어를 빠르고 효율적으로 처리하는 것이 주 역할이다.1. 연산 장치산술 연산, 논리 연산 등을 수행한다.2. 제어 장치메모리에서 명령어를 읽어와 해석하고, 다른 구성 요소에 신호를 보내 작업을 수행하도록 제어한다.3. 레지스...",
    "content": "컴퓨터 구성 요소CPU중앙 처리 장치로 컴퓨터의 두뇌에 해당하며, 연산과 명령을 처리한다.명령어 처리 속도로 성능이 결정되며, 명령어를 빠르고 효율적으로 처리하는 것이 주 역할이다.1. 연산 장치산술 연산, 논리 연산 등을 수행한다.2. 제어 장치메모리에서 명령어를 읽어와 해석하고, 다른 구성 요소에 신호를 보내 작업을 수행하도록 제어한다.3. 레지스터메인 메모리로부터 불러온 데이터를 저장하기 위한 임시 저장공간으로 연산 중 필요한 상태를 보관하는 공간으로 사용된다. 간단한 작업을 수행하며, 레지스터가 연산할 때는 연산 장치를 거치지 않기 때문에 속도가 빠르다.주기억 장치CPU가 직접 접근할 수 있는 고속 메모리로 컴퓨터가 현재 실행 중인 프로그램과 데이터를 저장하는 휘발성 메모리1. RAM (Random Access Memory)  휘발성 메모리로 전원을 차단하면 데이터가 지워진다.  어느 주소든 동일한 속도로 접근한다.  실행 중인 프로그램과 데이터를 저장하는 주기억 장치로 CPU가 직접 접근할 수 있어 속도가 빠르다.2. ROM (Read Only Memory)  비휘발성 메모리로 전원을 차단해도 데이터가 지워지지 않는다.  Random Access 특성을 가지며, 읽기 전용으로 사용된다.  주로 컴퓨터 부팅 과정에서 필요한 기본 시스템(BIOS, POST,Bootstrap Loader)을 저장한다.특징  휘발성  CPU가 직접 접근하여 데이터를 읽고 쓸 수 있어 속도가 매우 빠르다.  현재 실행 중인 프로그램과 그에 관련된 데이터를 저장하며, 컴퓨터의 즉각적인 작업에 사용된다.  보조 기억 장치에 비해 용량이 작다.보조 기억 장치물리적인 디스크가 연결되어있는 기억 장치로 비휘발성 메모리이다.대용량 데이터를 영구적으로 저장한다.1. HDD (Hard Disk Drive)  자기 디스크를 사용하는 전통적인 저장 장치  대용량 데이터를 저렴하게 저장할 수 있다.2. SSD (Solid State Drive)장  플래시 메모리를 사용하는 저장 장치  속도가 빠르고 내구성이 뛰어나며, 전력 소모가 적다.특징  비휘발성 메모리  대용량 데이터를 영구적으로 저장하며, 다양한 데이터를 저장한다.  주기억장치보다 속도가 느리다.  주기억장치보다 비용이 저렴하다입출력장치 (Input/Output Device)사용자와 컴퓨터 간의 상호작용을 가능하게 하는 장치데이터를 컴퓨터에 전달하고, 출력 장치는 컴퓨터의 처리 결과를 사용자에게 전달1. 입력 장치  키보드, 마우스, 마이크, 스캐너 등  사용자로부터 데이터를 받아 컴퓨터로 전달.    2. 출력 장치    모니터, 프린터, 스피커 등  컴퓨터의 처리 결과를 사용자에게 반환.캐시 메모리CPU와 주기억 장치 사이의 속도 차이를 완화시키기 위한 임시 메모리CPU가 자주 사용하는 데이터를 임시로 저장하여 빠르게 접근할 수 있도록 하는 고속 메모리이다.CPU와 RAM 사이에 위치하여, CPU가 RAM에 직접 접근하는 시간을 줄여주고 전체 시스템 성능을 향상시킨다.휘발성 메모리로 전원이 꺼지면 데이터가 사라진다.일반적으로 SRAM(Static RAM)으로 구현되며, 매우 빠르다.시스템 버스컴퓨터 시스템 내에서 서로 다른 구성 요소 간 데이터 전송 담당1. 데이터 버스  실제 데이터 전송2. 주소 버스  메모리 주소를 지정하는 경로  CPU가 접근할 메모리 위치 식별3. 제어 버스  데이터 전송의 제어 신호를 전달하는 경로로 시스템의 동작을 조정"
  },
  
  {
    "title": "StringBuffer StringBuilder",
    "url": "/posts/java-StringBuffer-StringBuilder/",
    "categories": "Java",
    "tags": "",
    "date": "2024-06-18 00:00:00 +0800",
    





    
    "snippet": "StringBuffer &amp; StringBuilder둘 다 가변 길이 문자열을 처리하는 데 사용되는 클래스이다.StringBuffer동기화가 적용되어 있으며 thread-safe 로 멀티 스레드 환경에서 StringBuffer 인스턴스에 접근할 때 안전하다.여러 스레드가 동시에 문자열을 수정해야 하는 경우 사용된다.예를 들어 멀티 스레드 환경에서...",
    "content": "StringBuffer &amp; StringBuilder둘 다 가변 길이 문자열을 처리하는 데 사용되는 클래스이다.StringBuffer동기화가 적용되어 있으며 thread-safe 로 멀티 스레드 환경에서 StringBuffer 인스턴스에 접근할 때 안전하다.여러 스레드가 동시에 문자열을 수정해야 하는 경우 사용된다.예를 들어 멀티 스레드 환경에서 공유 문자열을 처리하는 경우 사용할 수 있다.StringBuilder내부적으로 동기화가 적용되어 있지 않기 때문에 멀티 스레드 환경에서 안전하지 않다.단일 스레드 환경에서 문자열을 수정할 때 사용되며 성능이 중요하고 thread-safe가 필요하지 않은 경우 사용하는 것이 좋다.  StringBuilder 가 단일 스레드 환경에서 사용하기 적합한 이유  동기화로 인한 오버헤드가 없어, 단일 스레드 환경에서 빠르다.동기화는 메서드 호출시마다 추가적인 검사와 잠금 획득 및 해제를 필요로 하여 성능을 저하시킬 수 있다.  따라서 동기화가 없는 StringBuilder가 더 빠르게 실행된다.   동기화가 앖는 만큼 StringBuilder의 메서드들은 더 간단하고 경량화되어 빠른 실행이 가능하며, StringBuffer 보다 더 적은 자원을 소모한다.불변성객체가 한 번 생성된 후로 상태를 바꿀 수 없는 성질로 여러 스레드가 동시에 읽어도 안전하며 상태가 변하지 않는다.따라서 동기화 처리가 없어도 여러 스레드가 동시에 접근할 수 있다.또한 불변 객체는 변경될 일이 없기 때문에 캐싱하여 재사용할 수 있으며, 따라서 메모리의 사용을 높일 수 있다.StringBuilder는 가변 객체로 불변 객체와 반대되는 개념이다.StringBuidler은 내부 상태를 변경할 수 있으며 그 과정에서 내부 배열을 재사용한다. 새로운 객체를 생성하지 않고 문자열 수정이 가능하다.따라서 성능 측면에서는 유리할 수 있지만 멀티 스레드 환경에서는 주의해야 한다.StringBuilder를 멀티 스레드 환경에서 안전하게 사용하기 위해서는외부에서 동기화 처리를 해주어야 한다.동기화 처리 방법에는 synchronized 와 Lock이 있으며, 내부적으로 동기화 처리가 되어있는 StringBuffer을 사용하는 방법도 있다.ReentrantLock과 Synchronized?ReentrantLock과 Synchronized 둘 다 자바에서 동기화를 제공하지만 사용법과 기능 측면에서 차이가 있다.synchronized 키워드는 블록이나 메서드 수준에서 동기화가 가능하다. 자동으로 락을 획득하고 해제한다.사용이 간단하며 가독성이 좋다.ReentrantLock 클래스는 명시적으로 락을 획득하고 해제하는 작업이 필요하다.타임아웃을 지정할 수 있으며 Condition 객체를 사용하여 보다 세밀한 스레드 제어가 가능하고 공정성을 설정할 수 있다.복잡한 동기화 요구에 적합하지만 코드가 복잡해질 수 있다.ReentrantLock의 await 와 signalReentrantLock 클래스는 Condition 객체를 통해 스레드 간에 특정한 조건을 기다리고 신호를 보내는 기능을 제공한다.await() 메서드는 현재 스레드를 일시적으로 멈추고 다른 스레드가 signal() 또는 signalAll() 을 호출할 때까지 기다린다.singnal() 메서드는 하나의 대기 중인 스레드에게만 신호를 보낸다. 일반적으로 상태가 변경되어 하나의 스레만 깨어나야 할 때 사용된다.공유 자원의 상태가 특정 조건을 만족할 때까지 대기하도록 스레드를 설정하는 경우 사용된다.StringBuffer의 동기화StringBuffer 은 내부적으로 동기화 처리가 되어있어 멀티 스레드 환경에서 안전하게 사용이 가능하다.하지만 모든 메서드가 동기화 되며 단일 스레드 환경에서도 불필요한 락을 걸고 해제하기 때문에 오버헤드가 발생할 수 있다.복잡한 스레드 상호 작용 과정에서 데드락이 발생할 수 있으며, synchronized는 블록과 메서드 수준에서만 사용이 가능하기 때문에 세밀한 제어가 어려울 수 있다."
  },
  
  {
    "title": "Statement와 PreparedStatement",
    "url": "/posts/java-PreparedStatement/",
    "categories": "Java",
    "tags": "",
    "date": "2024-06-13 00:00:00 +0800",
    





    
    "snippet": "Statement와 PreparedStatementStatement와 PreparedStatement는 둘 다 JDBC API 에서 제공하는 인터페이스이다.데이터베이스에서 쿼리를 실행할 때 쿼리를 효율적으로 실행하기 위해서 쿼리 캐싱을 시행한다.  쿼리 캐싱      쿼리를 파싱하고    최적의 실행계획을 세운 뒤    실행하는 과정  Statemen...",
    "content": "Statement와 PreparedStatementStatement와 PreparedStatement는 둘 다 JDBC API 에서 제공하는 인터페이스이다.데이터베이스에서 쿼리를 실행할 때 쿼리를 효율적으로 실행하기 위해서 쿼리 캐싱을 시행한다.  쿼리 캐싱      쿼리를 파싱하고    최적의 실행계획을 세운 뒤    실행하는 과정  Statement는 쿼리를 실행할 때마다 매번 쿼리를 파싱하고 실행계획을 세우는 과정을 반복한다.PreparedStatement는 한 번 쿼리가 실행된 후에는 실행계획을 따로 세우지 않고 이전의 실행계획에 파라미터만 변경하여 쿼리를 날린다.  따라서 처음 실행된 실행계획을 재사용함으로써 성능상에서 좋다.보안 측면에서는 Statement는 입력값을 실제 쿼리에 문자열의 형태로 이어 붙이다.만약 패스워드를 검색하는 쿼리가 있다고 가정을 했을 때, 유저가 패스워드 값을 입력한 후 이어서 세미콜론을 붙이고따라서 SQL injection 문제가 발생할 위험이 있다.PreparedStatement는 입력값을 파라미터로 넘긴다. 파라미터로 넘어가는 부분을 ? 로 표시하여 바인딩해서 처리한다.PreparedStatement를 사용할 때 ?(플레이스 홀)를 사용하면, 사용자 입력값이 쿼리에 직접 삽입되지 않고JDBC 드라이버가 자동으로 매개변수 값을 이스케이프 처리한다.위와 같은 방식(“; select * from User;”)으로 값을 넘기게 되면 SQL injection을 했을 때 문법 에러가 발생한다.이렇게 쿼리와 입력 값을 분리해서 처리하기 때문에 입력값은 쿼리의 데이터로만 사용되며 쿼리 구문으로 해석되지 않는다.이는 SQL 인젝션 공격을 방지하는 데 매우 효과적이다.PreparedStatement를 사용 시 주의사항PreparedStatement 는 AutoCloseable를 확장하고 있다.따라서, 사용 후에는 리소스를 닫아주어야 한다.또한 실행 전에 컴파일되기 때문에 sql 문법 오류가 있는 경우 컴파일 시점에 예외가 발생한다.PreparedStatement를 사용 시 발생할 수 있는 성능 이슈캐싱을 이용하기 때문에 동일한 쿼리를 여러 번 실행할 때 성능을 최적화할 수 있다.하지만 Mysql의 경우, 쿼리는 정상적으로 오류없이 동작 하지만 내부적으로 캐싱하는 동작을 하지않는다.따라서 캐싱을 하기위해서는 useServerPrepStmts 와 cachePrepStmts 옵션을 설정해야 캐싱을 활용할 수 있다.또한 매개변수 바인딩시 적절한 데이터 타입(setString, setInt)을 사용하여 성능을 최적화할 수 있으며,대랑의 데이터 처리시 addBatch 와 executeBatch 메서드를 사용하여 배치 처리함으로써 성능을 높일 수 있다.동일한 Sql 템플릿을 재사용하기 때문에 컴파일 비용을 줄이고 성능을 최적화한다.SQL Injection 공격을 예방하는 방법SQL injection 공격을 막기 위해서는 매개변수를 이용해 쿼리에 값을 넣어야 한다.PreparedStatement를 사용하면 드라이버가 자동으로 매개변수 값을 이스케이프 처리하여 SQL Injection 공격을 방지한다.PreparedStatement에서 Batch 처리를 사용하는 경우 장점과 주의할 점Batch의 장점은 대량의 데이터를 한 번에 처리할 수 있다.이로써 네트워크 비용을 줄이고 연산 횟수를 감소시킴으로써 성능을 향상 시킬 수 있다.또한 여러 SQL 문을 하나의 트랜잭션으로 묶어서 실행하기 때문에 데이터의 일관성이 유지된다.하지만, 대량의 데이터를 처리하기 때문에 메모리 부족 현상이 발생할 수 있어, 적절한 배치 크기를 설정해야 한다.executeBatch() 는 쿼리의 실행 결과를 반환하지 않기 때문에 각 쿼리의 행 수 등의 정보를 확인하려면 추가적인 처리가 필요하다."
  },
  
  {
    "title": "try-catch와 try-with-resources",
    "url": "/posts/java-try-catch-%EC%99%80-try-with-resources/",
    "categories": "Java",
    "tags": "",
    "date": "2024-06-10 00:00:00 +0800",
    





    
    "snippet": "try-catch-finallytry-catch-finally 문은 자바7 이전에 나온 예외 처리 구문으로 모든 객체를 포함할 수 있다.사횽 후 반납을 해주어야 하는 자원들은 Closeable 인터페이스를 구현하고 있으며 사용 후 close 메서드를 직접 호출하여 반납해야 한다.자원 반납이 이루어지지 않는 경우 메모리 누수가 생길 수 있으며 다른 프로...",
    "content": "try-catch-finallytry-catch-finally 문은 자바7 이전에 나온 예외 처리 구문으로 모든 객체를 포함할 수 있다.사횽 후 반납을 해주어야 하는 자원들은 Closeable 인터페이스를 구현하고 있으며 사용 후 close 메서드를 직접 호출하여 반납해야 한다.자원 반납이 이루어지지 않는 경우 메모리 누수가 생길 수 있으며 다른 프로세스, 스레드에 영향을 줄 수 있습니다. 따라서 finally 블록 내에서 자원을 해제해야 한다.자원을 반납하는 추가적인 코드가 필요하며 실수나 에러로 자원을 반납하지 못하는 경우가 생길 수 있다.이러한 문제를 해결하기 위해 자바 7 부터 자원을 자동으로 반납해주는 try-with-resources 문법이 도입되었다.try-with-resourcestry-with-resources 는 Java7 부터 도입된 자원 관리를 위한 구문이다.AutoClosable 인터페이스를 구현하고 있는 자원을, 사용 후 자동으로 반납해주는 기능을 제공한다.이를 사용함으로써 가독성이 좋아지고 예외 발생 시 자원이 안전하게 해제될 수 있다.try (/*자원 초기화*/) {  // 자원을 사용하는 코드} catch (예외 타입 변수) {  // 예외 처리 코드}AutoCloseable 인터페이스를 구현한 객체만 try 블록 내에서 리소스로 사용할 수 있다.주로 파일, 소켓, 데이터베이스 연결 등에 사용됩니다. Connection.javaCloseable과 AutoCloseable의 관계기존의 Closeable 에 부모 인터페이스 AutoCloseable 를 추가한 형태입니다.Closeable은 AutoCloseable을 확장한 하위 인터페이스입니다. 따라서 Closeable은 AutoCloseable이 제공하는 모든 기능을 포함합니다. 이러한 구조로 기존에 구현된 자원 클래스 모두 try-with-resources 를 사용할 수 있습니다.      try-catch 문에서는 예외가 발생할 수 있는 모든 코드가 포함될 수 있으며, 특정 객체 타입에 제한되지 않습니다.        try-with-resources 문에서는 AutoCloseable 를 구현한 객체만을 사용할 수 있으며, 구문을 사용하면 리소스 누수를 방지할 수 있어 자원 관리에 매우 유용합니다.  "
  },
  
  {
    "title": "static",
    "url": "/posts/java-static/",
    "categories": "Java",
    "tags": "",
    "date": "2024-06-10 00:00:00 +0800",
    





    
    "snippet": "static 변수변수나 메서드를 정의할때 사용하는 키워드로, 프로그램의 시작과 동시에 메모리에 로드되어, 모든 인스턴스가 공유할 수 있는 변수이다.모든 객체마다 존재하는 인스턴스 변수와는 다르게 클래스 당 한 개만 존재한다.인스턴스 변수는 객체마다 개별적인 값을 갖지만 정적 변수는 모든 객체가 동일한 값을 공유한다.클래스에 종속되어 있으며 객체의 생성...",
    "content": "static 변수변수나 메서드를 정의할때 사용하는 키워드로, 프로그램의 시작과 동시에 메모리에 로드되어, 모든 인스턴스가 공유할 수 있는 변수이다.모든 객체마다 존재하는 인스턴스 변수와는 다르게 클래스 당 한 개만 존재한다.인스턴스 변수는 객체마다 개별적인 값을 갖지만 정적 변수는 모든 객체가 동일한 값을 공유한다.클래스에 종속되어 있으며 객체의 생성과는 무관하게 클래스가 로드될 때 딱 한 번 메모리에 할당된다.동일한 데이터를 여러 인스턴스에 저장할 필요가 없기 때문에 메모리 사용의 중복을 줄일 수 있다.JVM의 클래스 영역(Method Area, Metaspace)에 저장된다.Static 변수는 클래스가 처음 로드될 때 한 번만 초기화되며, 프로그램 종료 시까지 유지되기 때문에 메모리 할당과 해제에 따른 오버헤드를 줄인다.정적 메서드클래스 수준에서 호출할 수 있는 메서드해당 클래스의 모든 객체들에 의해서 공유되는 메서드로 객체를 생성하지 않고 클래스 이름으로 직접 호출 한다.또한 정적 메서드는 정적 변수만 사용할 수 있다.그리고 정적 메서드는 특정 객체에 속해있지 않기 때문에 this 키워드를 사용할 수 없는 특징이 있다.정적 메서드는 클래스 레벨에서 정의되므로, 메서드 호출 시 객체의 타입이 아닌 클래스의 타입에 따라 호출이 결정된다.또한 정적 메서드는 오버라이딩 되지 않는다.일반적으로 Math 함수와 같이 유틸리티 함수나 독립적인 작업을 수행하는 메서드에서 사용된다.static으로 인한 메모리 낭비static는 클래스로드 시점부터 메모리에 로드된다.따라서 큰 객체를 저장하는 경우 해당 객체가 사용되지 않을 때도 메모리를 차지한다.이로 인해 메모리 낭비가 발생할 수 있다.모든 인스턴스에서 공유되기 때문에 여러 스레드에서 동시에 접근할 수 있다.동시성 문제가 발생할 수 있기 때문에 스레듣 간에 동기화를 보장하기 위한 추가적인 처리가 필요하다.Static 변수는 프로그램 종료 시까지 메모리에 유지되기 때문에 불필요한 Static 변수 사용은 메모리 사용량을 증가시킬 수 있다.또한 상태를 공유하기 때문에 단위 테스트 시 테스트 간 의존성이 생길 수 있다.따라서 Static 변수의 상태를 테스트 전후에 초기화하거나 가능한 사용을 자제해야 한다.  동시성 문제 해결 방법  동시성 문제를 해결하는 방법으로는 동기화와 불변성이 있다.동기화는 여러 스레드가 동시에 스태틱 변수를 읽고 쓰는 것을 방지하기 위해 사용한다.synchronized 키워드를 사용해서 임계영역을 설정하는 방법이 있으며, 한 번에 하나의 스레드만임계영역에 접근할 수 있도록 한다.  불변성은 스태틱 변수를 변경할 수 없도록 만드는 것이다.   변수를 final 로 선언하고 불변 객체를 할당한다.이렇게 되면 동시에 여러 스레드가 해당 변수를 읽을 수는 있지만 변경할 수는 없다.static 변수의 사용을 최소화하기 위해 고려해야 할 것의존성 주입을 통하여 외부에서 필요한 객체를 주입 받도록 설계할 수 있다. 외부 의존성을 mock 객체로 대체 하여, 클래스 간의 결합도를 낮추어 유연한 테스트 케이스를 작성할 수 있다.또한 하나의 인스턴스를 생성하여 사용하는 싱글톤 패턴을 사용할 수 있다. 이를 통해 static 변수 사용을 최소화하고필요한 경우에만 인스턴스를 생성하여 메모리를 절약할 수 있다.그리고 스프링과 같은 의존성 주입 프레임워크를 사용하여 의존 관계를 관리하고 필요한 객체를 주입 받는 방법이 있다."
  },
  
  {
    "title": "JDBC와 커넥션",
    "url": "/posts/java-JDBC/",
    "categories": "Java",
    "tags": "",
    "date": "2024-06-10 00:00:00 +0800",
    





    
    "snippet": "JDBC (Java Database Connectivity)자바 애플리케이션과 데이터베이스 사이의 통신을 가능하게 하는 API자바 애플리케이션에서 데이터베이스에 접근하기 위해 JDBC API를 이용해서 데이터베이스에 접근하고,JDBC API는 JDBC 드라이버를 거쳐 데이터베이스와 통신한다.특징      플랫폼에 독립적입니다. Java 언어가 실행될 ...",
    "content": "JDBC (Java Database Connectivity)자바 애플리케이션과 데이터베이스 사이의 통신을 가능하게 하는 API자바 애플리케이션에서 데이터베이스에 접근하기 위해 JDBC API를 이용해서 데이터베이스에 접근하고,JDBC API는 JDBC 드라이버를 거쳐 데이터베이스와 통신한다.특징      플랫폼에 독립적입니다. Java 언어가 실행될 수 있는 모든 플랫폼에서동일한 방식으로 데이터베이스를 접속하고 관리할 수 있다.        데이터베이스 연결, 쿼리 실행, 결과 처리의 과정을 통합적으로 지원하여, 접속 과정을 단순화할 수 있다.        다양한 DBMS와 호환된다.        SQL을 사용해서 데이터베이스와 상호작용한다.        트랜잭션을 지원하여 데이터베이스 작업의 일관성을 유지할 수 있으며 하나의 트랜잭션으로 묶어 실행하거나 롤백할 수 있다.  JDBC가 생긴 이유?Java 애플리케이션이 다양한 데이터베이스와 상호작용할 수 있도록 표준화된 방법을 제공하기 위해 생겼다.데이터베이스 연결, 쿼리 실행, 결과 처리 등의 과정을 통일된 API로 간편하게 처리할 수 있게 하여, 데이터베이스의 독립성과 통합된 접근 방식을 제공한다.JDBC 드라이버1) DBMS와 통신을 담당하는 자바 클래스2) DBMS별로 알맞는 JDBC 드라이버가 필요하다3) 로딩 코드 : Class.forName(“JDBC드라이버 이름”);  오라클 : oracle.jdbc.driver.OracleDriver  Mysql : com.mysql.cj.jdbc.DriverJDBC URL1) DBMS와 연결을 위한 식별 값2) JDBC 드라이버에 따라 형식이 다르다3) 구성 : jdbc:[DBMS]:[데이터베이스식별자]Class.forName() 동작 원리주로 JDBC에서 데이터베이스 드라이버를 동적으로 로드하기 위해 사용한다.이 메서드를 통해 특정 클래스를 JVM의 클래스 로더에 로드한다.Class.forName() 메소드에 Driver 클래스 위치를 넘겨줄 뿐, 리턴 값을 받는 등의 아무런 동작이 없다.Class.forName()을 호출해 드라이버 클래스를 로드하면, 해당 클래스는 자신을 DriverManager에 등록한다.하지만, 이 시점에서 데이터베이스와의 연결은 일어나지 않는다.이후 DriverManager.getConnection()을 호출하면, 실제로 데이터베이스와의 연결을 생성한다.getConnection() 메소드는 등록된 JDBC 드라이버들 중에서 적절한 드라이버를 찾아 데이터베이스 연결을 시도한다.이후 DriverManager.getConnection()을 하면 해당 연결 객체를 넘겨주는 이유Class.forName()은 단순히 드라이버 클래스를 JVM에 로드하는 역할을 하고, 데이터베이스와의 연결을 생성하는 것은 DriverManager.getConnection() 이 합니다.JDBC 사용법  Class.forName() : 드라이버를 로드한다.  DriverManager : 로드된 드라이버를 통해서 Connection을 활성화해주는 객체  Connection : 데이터베이스와의 연결  Statement : SQL을 실행하는 객체  ResultSet : SQL문 실행 후 데이터를 받는 객체  close() : 자원 반환은 반드시 이루어져야한다.자바에서는 JDBC를 사용하게되면 DBMS 벤더에 의존하지 않는 독립적인 시스템 개발을 할 수 있다.이를 통해, DBMS의 종류에 따라 다르게 코딩하지 않고, 어떤 DBMS든지 동일하게 데이터베이스의 CRUD를 구현할 수 있다.커넥션 풀데이터 베이스를 연결하려면 네트워크 연결, 인증, 권한 확인 등여러 단계를 거쳐야 하기 때문에 상당히 많은 리소스를 소모합니다.이러한 문제를 해결하기 위해 커넥션 풀이 사용됩니다.커넥션 풀은 미리 일정 수의 연결을 생성해두고 필요할 때마다 연결을 재사용하는 방식입니다.이를 통해서 연결을 생성하는데 드는 비용을 절감하고 애플리케이션의 성능을 향상시킬 수 있습니다.커넥션 객체를 생성하는 과정1. JDBC 드라이버를 메모리에 로드합니다.Class.forName(\"com.mysql.cj.jdbc.Driver\");2. 데이터베이스와의 연결을 위한 URL을 정의합니다.String url = \"jdbc:mysql://localhost:3306/database\";3. 데이터베이스에 접속할 사용자 이름과 비밀번호를 설정합니다.String user = \"username\";String pasasword = \"password\";4. getConnection을 통해 데이터베이스와 연결을 생성하고 연결 과정에서 발생할 수 있는 예외를 처리합니다.Connection connection = DriverManager.getConnection(url, user, password);5. 연결을 사용한 후 close() 메서드 호출을 통해 연결을 종료합니다.finally {    if (connection != null) {        try {            connection.close();        } catch (SQLException e) {            e.printStackTrace();        }    }}-&gt; DB에 연결할 때마다 Connection 객체를 새로 만드는 것은 비용이 많이 들며, 비효율적이다.이 문제를 해결하기 위해 커넥션 풀이 등장동작프로그램이 시작하는 시점에서 연결이 미리 생성이 된다.이 연겯을 풀에 저장해두고 연결이 필요할 때마다 커넥션 풀에 미리 생성해둔 연결을 가져와서 사용한다.사용이 끝난 연결은 다시 풀에 반환되어 재사용한다.이 과정에서 데이터베이스 연결의 생성과 소멸이 최소화되기 때문에, 비용을 절감할 수 있으며 효율적이다.풀의 크기가 너무 작은 경우 사용 가능한 연결이 부족해 성능 저하가 발생할 수 있으며, 반대로 풀의 크기가 너무 큰 경우불필요하게 많은 리소스를 소모한다.커넥션 풀의 구현 방법커넥션  라이브러리 : Apache DBCP, C3P0, HikariCP 등이 있으며, 스프링 부트 2.3 이상에서는 기본 커넥션 풀로 HikariCP가 설정되어 있습니다.HikariConfig config = new HikariConfig();config.setJdbcUrl(\"jdbc:mysql://localhost:3306/mydb\");config.setUsername(\"user\");config.setPassword(\"password\");config.setMaximumPoolSize(10);HikariDataSource dataSource = new HikariDataSource(config);커넥션 풀 라이브러리를 사용하여 개발자는 데이터베이스 연결 관리의 복잡성을 줄이고 애플리케이션 성능을 향상시킬 수 있다.커넥션 풀 라이브러리는 풀의 상태를 모니터링할 수 있는 기능을 제공하며, 이를 통해 풀의 사용률, 연결 대기시간, 활성 연결 수 등 다양한지표를 실시간으로 확인할 수 있다.또한 요구 상황과 리소스 상황에 맞춰 커넥션 풀의 설정을 조정함으로써 최적의 성능을 달성할 수 있다.단점으로는 DB에서 정보를 가지고 올 때마다 DB Connection Disconnection을 해야하고, 서버 과부하 및 속도 저하의 문제가 있다."
  },
  
  {
    "title": "JDBC 구현",
    "url": "/posts/java-JDBC-%EA%B5%AC%ED%98%84/",
    "categories": "Java",
    "tags": "",
    "date": "2024-06-10 00:00:00 +0800",
    





    
    "snippet": "JDBCManager  JDBC를 사용해 Mysql 데이터베이스와의 연결을 관리하는 매니저 클래스Mysql 데이터베이스 접속에 필요한 정보(사용자이름, 암호, URL) 를 상수로 정의    private static final String USERNAME = \"root\";  // 데이터베이스 사용자 이름    private static final St...",
    "content": "JDBCManager  JDBC를 사용해 Mysql 데이터베이스와의 연결을 관리하는 매니저 클래스Mysql 데이터베이스 접속에 필요한 정보(사용자이름, 암호, URL) 를 상수로 정의    private static final String USERNAME = \"root\";  // 데이터베이스 사용자 이름    private static final String PASSWORD = \"XXXXXXXX\";  // 데이터베이스 암호    private static final String URL = \"jdbc:mysql://localhost/XXX?useSSL=false\";  JDBC URL: localhost에 설치된 MySQL 서버의 XXX데이터베이스에 접속  useSSL=false : SSL 을 사용하지 않음  이외 추가 접속 옵션 설정클래스가 로드될 때 JDBC 드라이버 로드static {    // 클래스가 로드될때 드라이버가 항상 로드되도록 보장하기 위해 정적으로 설정함(필수X)    try {        // Mysql JDBC 드라이버 클래스 로드        Class.forName(\"com.mysql.cj.jdbc.Driver\");    } catch (ClassNotFoundException e) {        e.printStackTrace();        throw new RuntimeException(\"Failed to load JDBC driver\");    }}데이터베이스 연결  public static Connection getConnection() throws SQLException {    return DriverManager.getConnection(URL, USERNAME, PASSWORD);  }  getConnection() 메서드 : 데이터베이스 연결을 생성하고 반환  DriverManager.getConnection(URL, USERNAME, PASSWORD)접속정보를 이용해 데이터베이스 연결 요청을 하고 이를 Connection 객체로 반환한다.JdbcManager.java 전체코드연결을 했으니까 이제 SQL 쿼리를 실행하는 Java 코드 보겠습니다.예시로 주문을 insert 하는 쿼리insertOrder메서드public class ItemDao {  public int insertOrder(String itemId, int quantity, Order order) {    String sql = \"INSERT INTO orders (order_id, item_id, stock_count) VALUES (?, ?, ?)\";    try (Connection conn = JdbcManager.getConnection();         PreparedStatement pstmt = conn.prepareStatement(sql)) {      // Order 객체에서 필요한 정보를 가져와서 SQL 문에 설정합니다.      // 주문 insert      pstmt.setString(1, order.getOrderId());      pstmt.setString(2, itemId);      pstmt.setInt(3, quantity);      int count = pstmt.executeUpdate();      // 코드 생략    } catch (SQLException e) {      e.printStackTrace();      // 예외 처리 및 롤백 로직이 필요할 수 있음    }    return 0;  }}      쿼리문 작성 : String sql = “~~~”?은 PreparedStatement의 매개변수 위치 지정자이다.        Connection conn = JdbcManager.getConnection(); JdbcManager 클래스의 getConnection() 메서드를 사용하여 데이터베이스와 연결한다.        PreparedStatement pstPreparedStatement pstmt = conn.prepareStatement(sql)  준비된 문장을 사용하여 SQL 쿼리를 실행할 PreparedStatement 객체를 생성한다.        pstmt.setString(1, order.getOrderId());Sql 쿼리의 첫 번째 매개변수에 값을 바인딩한다.        pstmt.executeUpdate()sql 쿼리를 실행하고 데이터베이스에 데이터를 삽입한다.  executeUpdate()와 executeQuery()하나 기억할 점은 각각 데이터 조작 및 조회 작업에 맞게 sql문 실행 메서드를 사용해야 한다.executeUpdate() 메서드는 insert, update, delete 와 같은 DML 쿼리를 실행할 때 사용된다.반환값으로 영향을 받은 레코드, 행의 개수를 반환한다.executeQuery() 메서드는 select 쿼리와 같이 데이터베이스 에서 데이터를 조회할 때 사용한다.ResultSet 객체를 반환하며, ResultSet 는 쿼리에 대한 결과 집합을 나타낸다.?하지만 이런 형식으로 select, insert, update 메서드를 구현한다며?커넥션을 획득하고, 매개변수를 매핑하고, 쿼리를 실행하는 동작들이 중복될 것이다.중복이 너무 많다~~~public abstract class BaseDao&lt;T&gt; {    public &lt;T&gt; T execute(String sql,                          ResultSetHandler&lt;T&gt; handler,                          Object...params) {        try (Connection conn = JdbcManager.getConnection();             PreparedStatement pstmt = conn.prepareStatement(sql)) {            for (int i=0; i&lt;params.length; i++) {                pstmt.setObject(i+1, params[i]);            }            ResultSet rs = pstmt.executeQuery();                        return handler.handle(rs);                } catch (SQLException e) {            e.printStackTrace();        }        return null;    }}제네릭 타입 T를 받는 추상 클래스로 다양한 유형의 데이터를 처리할 수 있다.  execute() 는 제네릭 메서드로 데이터베이스 쿼리를 실행하고 그 결과를 처리기 위한 메서드          sql : 실행할 쿼리문      handler : ResultSet 을 처리할 ResultSetHandler 인터페이스 구현체      params : 쿼리에 바인딩할 매개변수.      사용 예시public class ItemDao extends BaseDao {  public Item selectOne(String id) {    String sql = \"SELECT * FROM item WHERE item_id = ?\";    return (Item) execute(sql, rs -&gt; {      if (rs.next()) {        Item item = new Item();        item.setId(rs.getString(\"item_id\"));        item.setName(rs.getString(\"item_nm\"));        item.setPrice(rs.getInt(\"price\"));        item.setStockCount(rs.getInt(\"stock_count\"));        return item;              } else {        return null;              }    }, id);  }}@FunctionalInterfacepublic interface ResultSetHandler&lt;T&gt; {    T handle(ResultSet rs) throws SQLException;;}"
  },
  
  {
    "title": "ArrayList와 LinkedList",
    "url": "/posts/algorithm-arrayList/",
    "categories": "Algorithm",
    "tags": "",
    "date": "2024-06-10 00:00:00 +0800",
    





    
    "snippet": "Array동일한 타입의 데이터들이 순차적으로 메모리에 저장되는 자료구조인덱스를 통한 직접 접근이 가능하여, 탐색 속도가 빠르다.하지만 크기가 고정되어 있으며 동적으로 변경할 수 없다.변경이 필요한 경우 배열을 새로 생성한 후 기존의 요소들을 복사하여야 한다.ArrayList동적 배열 기반의 리스트 자료구조내부적으로 배열을 사용하여 요소를 저장하며, 요...",
    "content": "Array동일한 타입의 데이터들이 순차적으로 메모리에 저장되는 자료구조인덱스를 통한 직접 접근이 가능하여, 탐색 속도가 빠르다.하지만 크기가 고정되어 있으며 동적으로 변경할 수 없다.변경이 필요한 경우 배열을 새로 생성한 후 기존의 요소들을 복사하여야 한다.ArrayList동적 배열 기반의 리스트 자료구조내부적으로 배열을 사용하여 요소를 저장하며, 요소의 추가나 삭제에 의해 크기를 동적으로 조정한다.ArrayList는 생성할 때 초기 용량을 설정할 수 있으며 기본으로 10 으로 설정된다.내부 배열의 용량이 초과되면 ArrayList는 자동으로 배열의 크기를 증가시킨다.이 과정에서  더 큰 새로운 배열을 생성하고, 기존 배열의 요소를 새로운 배열로 복사한다.(새로운 배열의 크기는 기존 배열 크기의 1.5 또는 2 배)초기 용량을 적절히 설정하면 배열의 크기를 동적으로 늘리는 작업을 줄일 수 있다.배열을 늘리는 작업은 새로운 배열을 생성하고 기존 배열의 요소를 복사해야하기 때문에 비용이 많이 든다.너무 크게 설정하면 메모리 공간을 낭비하게 되고,너무 작게 설정하게 되면 크기 조정 작업이 빈번하게 발생하여 오버헤드가 발생할 수 있다.배열을 기반으로 하기 때문에 인덱스를 통한 직접 접근이 가능하다.LinkedList양방향 연결리스트 기반의 자료구조노드로 구성이 되며 배열에 비해 삽입 삭제가 유연하다.각 노드는 데이터 요소와 두 개의 참조(이전 노드, 다음 노드를 가리키는 포인터)로 이루어져 있다.이러한 노드들이 서로 연결되어 있어서 양방향 연결 리스트(doubly linked list) 구조를 형성한다.ArrayList와 LinkedList의 요소 추가 및 삭제 성능 차이ArrayList는 요소를 끝에 추가하는 작업이 빈번한 경우 유리하다.하지만, 요소를 중간에 추가하거나 삭제하는 경우 비효율적일 수 있다.LinkedList는 요소를 추가하거나 삭제하는 작업이 빈번한 경우에 유리하다.하지만 인덱스를 기반으로 요소에 접근하는 작업에는 비효율적입니다.특정 인덱스의 요소에 접근하려면 처음부터 해당 인덱스까지 찾아가야 한다.ArrayList와 LinkedList의 탐색 속도ArrayList는 인덱스를 기반으로 요소에 직접 접근하기 때문에 요소에 대한 빠른 접근이 가능하다.따라서 요소를 탐색하는데 있어 O(1)의 시간이 소요된다.LinkedList 특정 인덱스의 요소에 접근하기 위해서는 처음부터 해당 인덱스까지 찾아가야 한다.  따라서 요소를 탐색하는 데에는 평균적으로 O(n/2)의 시간이 소요된다.최악의 경우 O(n)의 시간이 소요될 수 있다.따라서 요소의 탐색이 빈번한 경우에는 ArrayList를 사용하는 것이 효율적이며,요소의 추가 및 삭제가 자주 일어나는 경우에는 LinkedList를 사용하는 것이 효율적이다."
  },
  
  {
    "title": "Time API",
    "url": "/posts/java-time_api/",
    "categories": "Java",
    "tags": "",
    "date": "2024-06-06 00:00:00 +0800",
    





    
    "snippet": "Time API날짜와 시간을 다루기 위한 API로 자바 8에서 도입되었다.주요 클래스      LocalDate: 날짜를 표현하는 클래스 (예: 2024-08-11)        LocalTime: 시간(시, 분, 초)을 표현하는 클래스 (예: 14:30:00)        LocalDateTime: 날짜와 시간을 모두 표현하는 클래스 (예: 2024...",
    "content": "Time API날짜와 시간을 다루기 위한 API로 자바 8에서 도입되었다.주요 클래스      LocalDate: 날짜를 표현하는 클래스 (예: 2024-08-11)        LocalTime: 시간(시, 분, 초)을 표현하는 클래스 (예: 14:30:00)        LocalDateTime: 날짜와 시간을 모두 표현하는 클래스 (예: 2024-08-11T14:30:00)        ZonedDateTime: 시간대 정보를 포함하는 날짜와 시간 클래스        Duration: 두 시점 간의 시간 차이를 표현하는 클래스        Period: 두 날짜 간의 차이를 연, 월, 일 단위로 표현하는 클래스        DateTimeFormatter: 날짜와 시간을 문자열로 포맷하거나 문자열을 날짜와 시간으로 파싱하는 클래스  public class TimeApiExample {    public static void main(String[] args) {        // 현재 날짜        LocalDate today = LocalDate.now();        System.out.println(\"오늘 날짜: \" + today);        // 현재 시간        LocalTime now = LocalTime.now();        System.out.println(\"현재 시간: \" + now);        // 현재 날짜와 시간        LocalDateTime dateTime = LocalDateTime.now();        System.out.println(\"현재 날짜와 시간: \" + dateTime);                // 날짜 연산        LocalDate today = LocalDate.now();        LocalDate futureDate = today.plus(Period.ofDays(10));        System.out.println(\"10일 후 날짜: \" + futureDate);        // 시간 연산        LocalDateTime now = LocalDateTime.now();        LocalDateTime later = now.plus(Duration.ofHours(5));        System.out.println(\"5시간 후 시간: \" + later);                // 날짜와 시간 포맷팅        LocalDateTime now = LocalDateTime.now();        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");        String formattedDateTime = now.format(formatter);        System.out.println(\"포맷팅된 날짜와 시간: \" + formattedDateTime);        // 문자열을 날짜와 시간으로 파싱        String dateTimeString = \"2024-08-11 15:30:00\";        LocalDateTime parsedDateTime = LocalDateTime.parse(dateTimeString, formatter);        System.out.println(\"파싱된 날짜와 시간: \" + parsedDateTime);        }}LocalDate 클래스날짜 정보를 표현하며, 시간 정보는 포함되지 않는다.      now(): 현재 날짜 반환        of(int year, int month, int dayOfMonth): 특정 날짜 생성        plusDays(long daysToAdd): 날짜 + 일수        minusMonths(long monthsToSubtract): 날짜 - 월수        getDayOfWeek(): 요일 반환        parse(CharSequence text): 문자열을 LocalDate 로 변환        format(DateTimeFormatter formatter): LocalDate를 지정한 형식으로 포맷팅하여 문자열로 반환        with(TemporalField field, long newValue): 특정 필드의 값을 변경한 새로운 LocalDate 객체를 반환        isBefore(LocalDate otherDate) &amp; isAfter(LocalDate otherDate): 두 날짜를 비교하여 현재 날짜가 다른 날짜보다 이전 또는 이후인지 확인        getDayOfYear(): 해당 연도에서 몇 번째 날인지 반환        **lengthOfMonth() &amp; lengthOfYear(): 해당 월 또는 연도의 일 수 반환  LocalDate date = LocalDate.of(2024, 8, 11); // 2024년 8월 11일LocalDate tomorrow = date.plusDays(1); // 2024년 8월 12일LocalDate date = LocalDate.parse(\"2024-08-11\");String formattedDate = date.format(DateTimeFormatter.ofPattern(\"dd/MM/yyyy\"));LocalDate firstDayOfMonth = date.with(ChronoField.DAY_OF_MONTH, 1);boolean isBefore = date.isBefore(LocalDate.now());int dayOfYear = date.getDayOfYear();int daysInMonth = date.lengthOfMonth();LocalTime 클래스시간 정보를 표현하며, 날짜 정보는 포함되지 않는다.      now(): 현재 시간 반환        of(int hour, int minute, int second): 특정 시간 생성        plusHours(long hoursToAdd): 시간 + 시간        minusMinutes(long minutesToSubtract): 시간 - 분        getHour(): 시 반환        toSecondOfDay() &amp; toNanoOfDay(): 하루의 시작부터 경과된 초 또는 나노초 반환  LocalTime time = LocalTime.of(15, 30); // 15시 30분LocalTime later = time.plusMinutes(15); // 15시 45분// 두 시간을 비교하여 현재 시간이 다른 시간보다 이전 또는 이후인지 확인합니다boolean isAfter = time.isAfter(LocalTime.NOON);int secondsOfDay = time.toSecondOfDay();LocalDateTime 클래스날짜와 시간 정보를 모두 표현한다.      now(): 현재 날짜와 시간 반환        of(int year, int month, int dayOfMonth, int hour, int minute, int second): 특정 날짜와 시간 생성        plusDays(long daysToAdd): 날짜 + 일수        minusHours(long hoursToSubtract): 시간 - 시간수        getDate(), getTime(): 날짜와 시간을 분리하여 반환  LocalDateTime dateTime = LocalDateTime.of(2024, 8, 11, 15, 30); // 2024년 8월 11일 15시 30분LocalDateTime futureDateTime = dateTime.plusHours(1); // 2024년 8월 11일 16시 30분LocalDate date = dateTime.toLocalDate();LocalTime time = dateTime.toLocalTime();"
  },
  
  {
    "title": "System.out.println()",
    "url": "/posts/java-systemoutprintln/",
    "categories": "Java",
    "tags": "",
    "date": "2024-06-04 00:00:00 +0800",
    





    
    "snippet": "System.out.println()Java 에서 콘솔에 출력할 때 사용되는 메서드로 주로 디버깅 목적으로 사용한다.콘솔로 출력하기 위해 디스크에 I/O 작업을 수행한다. 디스크 I/O 는 메모리 작업보다 상대적으로 느리며, 이 작업이 빈번하게 발생하는 경우 성능 저하를 초래할 수 있다.I/O 작업은 블로킹 성격으로, 출력 작업이 완료될 때까지 현재 ...",
    "content": "System.out.println()Java 에서 콘솔에 출력할 때 사용되는 메서드로 주로 디버깅 목적으로 사용한다.콘솔로 출력하기 위해 디스크에 I/O 작업을 수행한다. 디스크 I/O 는 메모리 작업보다 상대적으로 느리며, 이 작업이 빈번하게 발생하는 경우 성능 저하를 초래할 수 있다.I/O 작업은 블로킹 성격으로, 출력 작업이 완료될 때까지 현재 스레드는 대기해야 하기 때문에 스레드의 실행이 지연될 수 있다.또한 내부적으로 출력 버퍼링을 사용한다. 작은 양의 데이터를 출력할 때도 버퍼를 채우고 비워야 하기 때문에 일정 시간이 소요되어, 오버헤드가 발생할 수 있다.객체를 문자열로 변환하여 출력하기 때문에 추가적인 문자열 작업이 필요하다.그리고 멀티 스레드 환경에서 동기화 방식으로 출력을 처리하기 때문에, 여러 스레드가 동시에 호출하는 경우, 동기화로 인해 스레드 간에 경쟁이 발생하고 이로 인해 성능 저하가 발생할 수 있다.해결 방안log4j, SLF4J, java.util.logging 등과 같은 로깅 프레임워크를 사용하면 로그 레벨을 조절하고, 파일에 로그를 저장하거나 비동기적으로 로그를 처리할 수 있다. 이는 콘솔 출력보다 효율적인 로깅을 제공한다.로깅 시스템을 통해 출력을 관리하고, 디버깅과 모니터링이 가능하다.문자열을 효율적으로 처리하기 위해 StringBuilder, String.format을 사용할 수 있다. 반복적인 문자열의 결합이 필요한 경우 성능 향상에 도움이 되며, 가변 크기의 문자열을 처리할 수 있고, 문자열을 효율적으로 조작할 수 있다.출력 버퍼링을 활용하여 여러 작은 출력을 모아서 한 번에 출력하여 I/O의 작업 횟수를 줄이고, 오버헤드를 감소시킬 수 있다.출력 빈도를 최소화하여 성능을 개선하는 방식반복적인 출력을 피하기 위해 데이터를 한 번에 모아서 출력하거나, 조건을 걸어서 출력이 필요한 경우에만 출력할 수도 있다.   또는 로그 레벨을 설정하여 특정 레벨 이상의 로그만 출력하도록 할 수 있다.출력 버퍼링을 사용할 경우, 적절한 버퍼의 크기를 선택해야 한다. 작은 크기는 자주 비워져야하기 때문에 입출력이 자주 발생할 수 있음며, 반대로 너무 큰 버퍼는 메모리를 많이 차지한다.또한 멀티 스레드 환경에서 여러 스레드가 동시에 출력 버퍼에 접근할 수 있기 때문에 동기화 작업이 필요하다. 동기화를 통해 스레드간의 충돌을 방지한다.그리고 출력 중에 발생할 수 있는 예외를 처리하는 방법이 필요하다.멀티 스레드 환경에서 동기화를 통한 출력 버퍼 접근 방식접근방식에는 synchronized 메서드나 블록을 사용하여 한 번에 하나의 스레드만 접근할 수 있도록 한다.다른 방법은 ReentrantLock를 사용하여 락을 획득하고 해제하는 방법이 있다.  충돌을 방지하려면?  동기화를 구현하여 한 스레드가 공유 자원을 사용중일 때 다른 스레드에서 접근할 수 없도록 한다.  출력 중에 발생한 예외를 처리하려면  try-catch블록을 이용하여 예외를 처리할 수 있습니다. 출력하는 동안 발생할 수있는 예외를 해당 블록으로 감싸서 처리한다.  다른 방법은 메서드 내에서 예외를 직접 처리하지 않고 호출자에게 예외를 던지도록 할 수 있다. 예외 발생시 로그를 남김으로써 문제를 쉽게 발견할 수 있으며 예외 발생 시 이전 상태로 돌리는 방법을 고려해야 한다.catch 블록에서 예외를 로그로 기록하고, 상태를 복구하기 위해 어떻게 로깅을 해야하는지catch 블록에 예외 로그를 기록할 때 로그 레벨과 예외 메시지를 포함하여 기록한다.상태를 복구하기 위해서는 상태 복구 메서드를 직접 생성하여 호출할 수 있다.예로 데이터베이스 트랜잭션에서 예외 발생 시 이전 상태로 롤백하는 작업을 수행한다."
  },
  
  {
    "title": "Serialization",
    "url": "/posts/java-serialization/",
    "categories": "Java",
    "tags": "",
    "date": "2024-06-04 00:00:00 +0800",
    





    
    "snippet": "Serialization객체를 바이트 스트림으로 변환하여 저장하거나 전송할 수 있게 하는 과정Java 시스템 내부에서 사용되는 데이터를 외부의 Java 시스템에서 사용할 수 있도록 바이트 형태로 변환하는 것을 의미한다.구현 방식public interface Serializable() {    }자바에서 직렬화를 구현하기 위해서는 java.io.Seri...",
    "content": "Serialization객체를 바이트 스트림으로 변환하여 저장하거나 전송할 수 있게 하는 과정Java 시스템 내부에서 사용되는 데이터를 외부의 Java 시스템에서 사용할 수 있도록 바이트 형태로 변환하는 것을 의미한다.구현 방식public interface Serializable() {    }자바에서 직렬화를 구현하기 위해서는 java.io.Serializable 인터페이스를 구현해야 한다. 클래스의 필드 중에 직렬화하지 말아야 할 필드는 transient 키워드를 사용하여 표시한다.import java.io.Serializable;public class User implements Serializable {    private static final long serialVersionUID = 1L; // 클래스 버전 관리용    private String username;    private transient String password; // 직렬화에서 제외}1. Serializable 인터페이스 구현직렬화할 클래스는 java.io.Serializable 인터페이스를 구현한다.2. transient 키워드 사용객체를 직렬화할 때, 직렬화하지 않을 필드는 transient 키워드를 사용하여 표시한다. 예를 들어, 암호와 같은 민감한 정보를 직렬화에서 제외하려면 transient를 사용한다.3. 직렬화 및 역직렬화ObjectOutputStream과 ObjectInputStream 클래스를 사용하여 객체를 파일에 저장하거나 읽어올 수 있다.  직렬화: 객체를 파일에 저장할때 ObjectOutputStream을 사용한다.  역직렬화: 저장된 파일에서 객체를 읽어올때 ObjectInputStream을 사용한다.JSON, CSV가 아닌 자바 직렬화를 사용하는 이유자바 직렬화는 자바 시스템 개발에 최적화되어 있으며, 자바 환경 내에서 객체의 상태를 보존, 저장, 전송할 때 유용하다.JSON은 언어와 플랫폼에 독립적인 데이터 포맷을 제공하지만, 자바 직렬화는 자바에 최적화되어 있다.무엇보다 데이터 타입이 자동으로 맞춰지기 때문에, 역직렬화시 바로 기존 객체처럼 사용이 가능하다.무조건 자바 직렬화를 사용하는 것이 아닌 때에 따라서 맞게 사용해야 한다.언제 사용하는지객체 데이터를 영속화하고 전송할 수 있는 특성으로 여러 곳에서 사용된다.서블릿 세션:사용자의 상태 정보를 유지하기 위해 세션을 사용하며, 세션 데이터를 DB나 파일에 저장할 때 자바 직렬화를 통해 외부 저장소에 저장한다.캐시:Redis 같은 캐시 시스템에서 데이터를 저장할 때, 자바 객체를 직렬화하여 바이트 스트림으로 변환한 후 저장한다.자바 RMI:원격 메소드 호출 시, 메소드 인자와 반환값을 직렬화하여 원격 시스템 간에 데이터를 전송하고, 수신 측에서 이를 역직렬화한다.import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;public class SerializationExample {    public static void main(String[] args) {        User user = new User(\"john_doe\", \"password123\");        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"user.ser\"))) {            oos.writeObject(user); // 객체를 파일에 직렬화        } catch (IOException e) {            e.printStackTrace();        }    }}ObjectInputStream의 readObject()readObject() 메서드는 직렬화된 파일에서 객체를 읽어올 때 사용한다.이 메서드는 직렬화된 데이터를 역직렬화하여 원래의 객체로 복원한다.Object 타입을 반환하기 때문에, 읽어온 객체를 원래의 클래스 타입으로 형 변환해야 한다.역질렬화할 때 해당 클래스가 클래스패스에 없는 경우 ClassNotFoundException이 발생할 수 있다.또한 클래스의 구조나 패키지 이름이 변경된 경우에도 발생할 수 있다.  직렬화된 객체가 다른 JVM 버전이나 다른 시스템에서 직렬화된 경우, 특정 클래스에 의존할 때도 예외가 발생할 수 있다.  SerialVersionUID  직렬화된 객체의 버전을 식별하는 고유 식별자  클래스에 새로운 필드가 추가, 제거등 변경 사항이 있을 때, 재정의하지 않으면 InvalidClassException 예외가 발생할 수 있다.여러 버전의 클래스가 존재할 수 있는 경우 SerialVersionUID를 사용하여 호환성을 유지할 수 있기 때문에 직렬화시 버전 불일치의 문제를 방지할 수 있다.  Externalizable 인터페이스  Externalizable 인터페이스를 구현하면, 직렬화 및 역질렬화 과정에서, 사용자가 직접 writeExternal()과 readExternal() 메서드를 구현해야 한다.또한 직렬화할 필드와 방법을 명시적으로 제어할 수 있어 불필요한 데이터를 직렬화하지 않을 수 있다.이 과정에서 성능 최적화가 가능하며 직렬화된 데이터의 구조를 명확하게 정의할 수 있다.transienttransient로 선언된 필드는 ObjectOutputStream을 사용하여 객체를 직렬화할 때 데이터 스트림에 저장되지 않는다.역직렬화 과정에서는 transient로 선언된 필드는 기본값으로 초기화된다. int 타입의 transient 필드는 0으로, boolean 타입의 transient 필드는 false로 초기화된다.직렬화가 필요한 데이터와 필요하지 않은 데이터를 구분할 때 유용하다.  transient의 동작  transient 키워드가 적용된 필드가 사용자 정의 객체나 참조형 변수를 가지면, 직렬화 시 해당 필드의 값은 저장되지 않으며, 역직렬화 후에는 null이 되거나 기본값으로 초기화된다.  민감한 정보나, 직렬화가 필요 없는 데이터에 사용한다. 하지만, transient로 지정된 필드는 역직렬화 후 제대로 복원되지 않기 때문에, 필요한 경우 readObject메서드에서 직접 복원 로직을 구현해야 한다.  readObject 메서드를 구현하여 transient 필드를 복원할 때 주의할 점  readObject에서 복원 로직을 정확하게 구현해야 한다. 직렬화되지 않기 때문에 복원시 적절한 값을 설정해야 하며, 직렬화와 역직렬화시 필드의 순서가 맞아야 한다.그리고 복원과정에서 발생할 수 있는 예외를 적절히 처리해야 한다.  Serializable 인터페이스 내부의 writeObject 메서드  writeObject() 메서드에서 transient 필드는 직렬화되지 않기 때문에,이 메서드에서는 transient 필드를 저장하지 않아야 한다."
  },
  
  {
    "title": "synchroinzed 와 DeadLock",
    "url": "/posts/java-synchronized/",
    "categories": "Network",
    "tags": "",
    "date": "2024-06-02 00:00:00 +0800",
    





    
    "snippet": "synchroinzed멀티스레드 환경에서 동기화를 제공하기 위해 사용특정한 블록이나 메서드를 여러 스레드가 동신에 접근하지 못하도록 제어한다.메서드 선언시 사용하면 해당 메서드는 해당 객체의 락을 획득하고, 메서드 실행이 완료될 때 락을 해제한다.다른 스레드가 동일 객체에 접근하려면 락이 해제될 때까지 대기해야 한다.특정 코드 블록에 사용할 수 있다....",
    "content": "synchroinzed멀티스레드 환경에서 동기화를 제공하기 위해 사용특정한 블록이나 메서드를 여러 스레드가 동신에 접근하지 못하도록 제어한다.메서드 선언시 사용하면 해당 메서드는 해당 객체의 락을 획득하고, 메서드 실행이 완료될 때 락을 해제한다.다른 스레드가 동일 객체에 접근하려면 락이 해제될 때까지 대기해야 한다.특정 코드 블록에 사용할 수 있다.DeadLock멀티 스레드 환경에서 여러 개의 스레드가 서로 자원을 기다리면서 발생하는 무한 대기 상태데드락 발생 조건1. 상호 배제자원은 한 번에 하나의 스레드만 사용할 수 있어야 한다.만약 자원을 여러 스레드가 동시에 사용할 수 있다면, 자원을 얻기 위해 대기할 필요가 없어 데드락이 발생하지 않는다.2. 점유 및 대기최소한 하나의 자원을 점유하고 있으면서 다른 자원을 추가로 얻기 위해 대기하는 상태가 있어야 한다.자원을 요청할 때 다른 자원을 보유하고 있지 않은 경우, 데드락이 발생하지 않는다.3. 비선점이미 할당된 자원을 강제로 빼앗을 수 없습니다.  즉, 자원을 점유한 스레드는 그 자원을 자발적으로 해제하기 전까지 해당 자원을 계속 사용한다.  자원을 강제로 해제할 수 있는 경우, 데드락이 발생하지 않는다.4. 순환대기두 개 이상의 스레드가 순환적으로 자원을 대기하고 있어야 한다.  예를 들어, 스레드 A가 자원 X를 가지고 있고, 스레드 B는 자원 Y를 가지고 있으며 자원 X를 기다리는 경우이다.이 경우 순환 대기가 해결되지 않으면 데드락이 발생한다.이 네 가지 조건을 모두 충족하는 경우 데드락이 발생한다.synchronized 키워드를 사용하여 데드락 예방synchronized 를 사용하면 코드 블록이나 메서드를 한 번에 하나의 스레드만 실행할 수 있도록 한다.스레드 간의 동기화를 쉽게 할 수 있지만, 잘못 사용하는 경우 데드락이 발생할 수 있다.1. 자원 획득 순서 정하기여러 스레드가 여러 자원을 필요로 할 때, 자원을 획득하는 순서를 모든 스레드가 동일하게 정하면 데드락을 방지할 수 있다.  예를 들어, 스레드들이 자원 A와 B를 사용해야 한다면, 항상 A를 먼저 요청하고, 그 후에 B를 요청하도록 순서를 정한다.synchronized(resourceA) {    synchronized(resourceB) {        // 필요한 로직        }    }2. 중접퇸 synchronized 블록 피하기중첩된 synchronized 블록은 데드락이 발생할 가능성이 높다.  가능한 경우, 중첩된 synchronized 블록을 피하거나, 중첩된 블록을 단일 블록으로 합쳐서 처리하는 것이 좋다.  중첩된 synchronized 블록을 사용할 수 있는 경우      자원 잠금 순서가 통일된 경우여러 스레드가 동일한 자원들을 잠글 때, 항상 같은 순서로 잠금이 이루어지면 데드락이 발생할 가능성이 줄어든다.    자원이 한 방향으로만 잠금되는 경우자원이 한 번 잠금된 이후 다시 잠금되지 않도록 코드를 설계함면 데드락이 발생할 가능성이 줄어든다.    타임 아웃 설정타임 아웃을 설정하면, 설정한 시간이 지나면 다른 작업을 시도하거나 오류를 처리할 수 있어 데드락을 예방할 수 있다.  3. 최소한의 범위에 사용synchronized 블록의 범위를 최소화하여, 가능한 한 자원을 빨리 해제하는 것이 교착 상태의 가능성을 줄이고, 성능을 향상시킨다.synchronized 블록의 범위를 작게 설정하려면synchronized 블록 내에 꼭 필요한 코드만 포함시켜야 한다.불필요한 작업이나 오래 걸리는 작업이 포함되는 경우, 다른 스레드가 불필요하게 대기하기 되어 데드락이 발생할 수 있다.자원을 사용하는 경우만 synchronized를 사용해 보호하고, 이후 복잡한 계산이나 작업은 synchronized 블록 밖에서 처리하는 것이 좋다.그리고 자원 접근을 한 곳에서 일관되게 관리하는 것이 데드락을 예방할 수 있다.여러 곳에서 자원을 관리하면, 자원의 접근 순서가 섞이기 때문에 데드락이 발생할 수 있다.ReentrantLock과 synchronized의 차이synchronizedsynchronized 는 자바 키워드로 간단하게 동기화 블록과 메서드를 구현할 수 있다.자동으로 재진입이 가능하기 때문에 같은 스레드가 동일한 락을 여러 번 획득할 수 있다. 예외 발생 시 락이 자동으로 해제된다.ReentrantLockjava.util.concurrent.locks 패키지의 클래스로 타임아웃 설정, tryLock, condition 등을 이용하여, 세밀한 제어가 가능하다.명시적으로 락을 획득하고 해제하는 과정이 필요하며, 예외 발생시에 unlock()를 반드시 호출해서 락을 해제해야 한다.타임 아웃을 설정하여 지정된 시간동안 락을 시도하며 성공시 true, 실패시 false를 반환한다.if (lock.tryLock(10, TimeUnit.SECONDS)) {   // 락 획득시 true 반환    try {        // 자원 사용    } finally {        lock.unlock();    }} else { // 락 획득 실패시 false 반환    // 타임아웃 처리}ReentrantLock에서 unlock()을 호출하지 않는다면락이 영구적으로 유지된다.락을 해제하지 않으면 다른 스레드가 이 락을 획득할 수 없다.따라서 해당 자원에 대한 접근이 불가능하게 되어 프로그램이 멈추거나 성능이 저하될 수 있다. 이로 인해 데드락이 발생할 수 있다.자원 누수락이 해제되지 않으면 해당 자원은 계속해서 점유된 상태로 남는다.이로 인해 자원 누수가 발생할 수 있다.락 재진입 제한ReentrantLock은 재진입이 가능한 락이기 때문에 같은 스레드가 여러 번 락을 획들할 수 있다.하지만 unlock를 호출하지 않으면 재진입 카운터가 감소하지 않아 다른 작업에서 이 락을 사용할 수 없다.ReentrantLock의 tryLock() 메서드tryLock()은 인수없이 호출 된다.락을 즉시 시도하며, 락을 획득하면 true, 그렇지 않으면 false를 반환한다.tryLock(long timeout, TimeUnit unit) 의 경우 지정된 시간 동안 락을 시도한다.특정 시간 동안만 락을 시도하기 때문에 데드락 발생 가능성을 줄일 수 있다.  락을 오래 기다리지 않기 때문에, 락을 시도한 후 다른 작업을 수행할 수 있다.락 경쟁이 치열한 상황에서 trylock()를 사용해 락을 시도한 후 다른 작업을 수행할 수 있어 유용하다.또한 주기적으로 특정 자원에 대한 접근이 필요한 경우 유용하다.tryLock()을 사용하면 스레드가 오래 기다리지 않고, 락 획득 실패 시 다른 작업을 수행할 수 있어 효율적인 자원 관리와 데드락 예방에 도움이 된다.tryLock()이 실패하는 경우 다른 작업을 수행하도록 설계할 수 있으며, 일정 시간 후 다시 호출하는 방식으로 재시도 로직을 구현할 수도 있다.스핀 락을 이용해 반복해서 락을 시도할 수 있다.스레드가 락을 계속해서 시도하는 경우, CPU 리소스를 낭비할 수 있다.이로 인해 시스템의 성능이 저하될 수 있다.여러 스레드가 서로 다른 우선 순위로 락을 재시도하는 경우, 우선 순위가 낮은 스레드가 락을 먼저 획들하고, 우선순위가 높은 스레드가 락을 획득하지 못해 대기하는 상황이 발생할 수 있다.이로 인해 우선 순위가 역전되거나, 더 나아가 교착상태가 발생할 수 있으며, 락 경쟁이 심화되어 시스템의 성능이 저하될 수 있다.또한 특정 스레드가 자원을 거의 사용하지 못하는 경우가 발생할 수 있는데 이는 기아 상태로 빠질 수 있다.tryLock(long timeout, TimeUnit unit)을 효율적으로 사용하려면tryLock(long timeout, TimeUnit unit)을 사용할 때 효율적으로 활용하기 위해서는,우선 해당 락을 얼마 동안 기다릴지 설정하는 것이 중요하다.이 값을 너무 짧게 설정하면 락을 얻지 못하는 경우가 빈번해질 수 있고, 너무 길게 설정하면 대기 시간이 길어진다.timeout의 값은 시스템 환경과 동작하는 스레드의 특성에 따라 조정해야 한다. 예를 들어, 빠르게 응답해야 하는 상황이라면 짧은 timeout 값을 선택하는 것이 좋다.또한 unit으로 락을 대기하는 간격을 적절하게 조절할 수 있다. 일반적으로 TimeUnit.MILLISECONDS나 TimeUnit.SECONDS를 주로 사용하며, 상황에 따라 TimeUnit.MINUTES 등을 선택할 수도 있다."
  },
  
  {
    "title": "Generic 제네릭",
    "url": "/posts/java-generic/",
    "categories": "Java",
    "tags": "",
    "date": "2024-05-30 00:00:00 +0800",
    





    
    "snippet": "Generic데이터 타입을 일반화하여 클래스, 인터페이스, 메서드를 정의할 때 사용하는 기능클래스나 메서드를 선언할 때 타입을 명시적으로 지정하지 않고, 사용하는 시점에 실제 타입을 지정할 수 있다.제네릭을 이용하여 특정 타입에 의존하지 않고 데이터 구조나 알고리즘을 정의할 수 있으며, 코드의 재사용성과 타입 안정성을 향상 시킬 수 있다.컴파일 타임에...",
    "content": "Generic데이터 타입을 일반화하여 클래스, 인터페이스, 메서드를 정의할 때 사용하는 기능클래스나 메서드를 선언할 때 타입을 명시적으로 지정하지 않고, 사용하는 시점에 실제 타입을 지정할 수 있다.제네릭을 이용하여 특정 타입에 의존하지 않고 데이터 구조나 알고리즘을 정의할 수 있으며, 코드의 재사용성과 타입 안정성을 향상 시킬 수 있다.컴파일 타임에 타입을 체크할 수 있어 런타임에 발생할 수 있는 오류를 예방할 수 있으며 형 변환의 번거로움을 줄일 수 있다.T(Type), E(Element), K(Key), V(Value)동작방식은 우선 클래스나 메서드 선언시 타입 매개변수를 선언한다. 선언된 제네릭 클래스를 사용할 때는 타입 인자를 지정하여 구체적인 타입을 명시한다.그 후 컴파일러가 타입 안정성을 보장하기 위해 타입 체크를 수행하여 잘못된 타입에 대한 경고나 오류를 찾는다.제네릭을 사용하면 타입 변환을 자동으로 처리할 수 있어 코드가 간결해지고 가독성이 높아지며, 잘못된 타입 변화로 인한 런타임 오류를 줄일 수 있다.동일한 코드를 참조 타입에 대해 재사용할 수 있는 장점이 있다. 또한 타입 캐스팅을 줄여 코드 가독성과 유지보수성을 높일 수 있다. 원시타입에 대해서는 사용할 수 없다.하지만 다소 복잡하고, 컴파일 후 타입 소거로 인해 런타임에는 제네릭 타입 정보가 소실된다. (실행시점에는 Object 타입으로 다뤄짐)제네릭에서 와일드카드를 사용하는 경우에는 어떤 상황에서 어떻게 사용하는지와일드카드는 제네릭 타입의 유연성을 높여주며, 특정 타입에 구애받지 않고 여러 타입을 처리할 수 있게 해준다.제네릭 타입을 구체적으로 알 필요 없이 데이터를 처리하거나, 상위, 하위 타입을 제한하고자 할 때 사용할 수 있다.extends는 데이터를 읽기 전용으로 사용하는 상황에 적합하다.super는 쓰기 전용 작업이 필요한 경우에 적합하다.와일드카드의 종류1. 무제한 와일드카드: &lt;?&gt;  아무 타입이나 올 수 있을 때 사용한다.  List&lt;?&gt; 의 경우 어떤 타입의 리스트도 받을 수 있다.  타입에 상관없이 메서드에서 모든 타입의 제네릭을 처리할 때 사용.    2. 상한 제한 와일드카드: &lt;? extends T&gt;    T타입과 그 하위 타입들을 나타낼 수 있습니다.  List&lt;? extends Number&gt;는 Number 타입과 그 하위 타입들을 모두 받을 수 있습니다.3. 하한 제한 와일드카드: &lt;? super T&gt;  T 타입과 그 상위 타입들을 나타냅니다.  List&lt;? super Integer&gt;은 Integer타입과 그 상위타입들을 받을 수 있습니다.하한 제한 와일드카드는 특정 타입 T 와 그 타입의 상위 클래스만 허용하는 제네릭이다.주로 메서드의 매개변수 타입으로 사용되어 메서드가 여러 관련 타입을 처리할 수 있다.상한 제한 와일드카드는 특정 타입의 하위 타입만 허용하는 경우에 사용되며, 주로 컬렉션에서 요소를 읽을 때 유용하다.와일드 카드는 매개변수로만 사용될 수 있으며, 제네릭 클래스나 제네릭 메서드의 반환 타입으로는 사용할 수 없다.와일드 카드를 사용하면 컬렉션의 요소를 읽는 것은 가능하지만 쓰는것은 불가능합니다. List&lt;?&gt; 에는 null 만 추가 가능하다.사용상황메서드에서 특정 제네릭 타입을 받아들이지만 실제 타입에 대해 정확히 알 필요가 없는 경우 사용한다.클래스의 일부 멤버 변수가 제네릭 타입일 때 다양한 타입의 객체를 다룰 수 있도록 하기 위해 사용한다.            특징      &lt;? super T&gt;      &lt;? extends T&gt;                  허용타입      T와 T의 상위 타입      T와 T의 하위 타입              쓰기가능      T와 T의 하위 타입 추가 가능      추가 불가능              읽기가능      Object 타입으로 읽기      T 타입으로 읽기      와일드카드를 사용 시 주의할 부분와일드카드 타입은 읽기 전용으로 요소를 추가하려면 null 만 추가할 수 있다.따라서 컬렉션에 요소를 추가하는 용도로는 사용할 수 없다.또한 와일드 카드를 사용하면 특정한 타입을 명시하지 않고 다양한 타입을 처리할 수 있다.하지만, 그 범위는 명확하지 않아 정확한 타입을 추론하거나 타입을 확인하는 작업이 어렵다.예를 들어 List&lt;?&gt;는 모든 타입을 처리할 수 있지만, 이 리스트에 어떤 타입의 요소가 들어있는지 정확히 알 수 없다.따라서, 직접 타입 변환이 필요할 수 있다.또한 컬렉션의 타입에 따라 사용할 수 있는 메서드에 제한이 생긴다.List&lt;? extends Number&gt;에서는 값을 읽는 것은 가능하지만, 값을 추가하는 작업은 불가능한다.반대로, ? super T를 사용한 컬렉션에서는 값을 추가할 수 있지만, 타입 안정성을 위해 읽기 작업이 제하된다. (주로 Object 타입으로 읽어야 한다).또한 와일드카드를 반환하는 메서드를 사용할 때도 주의해야 한다.와일드카드를 사용하지 않고 어떻게 대체할 수 있는지대체하는 방법에는 타입 매개변수를 사용하는 것입니다. 이 방법을 통해 정확한 타입 지정과 메서드 호출이 가능하며 코드의 가독성과 유지보수성을 높일 수 있다.이로써, 컴파일러가 타입을 추론할 수 있고 실제로 해당 타입과 관련된 메서드를 호출할 수 있다.또한 와일드 카드의 범위가 너무 넓은 경우 상위 타입을 지정하여 구체화할 수 있다.와일드카드와 타입 매개변수를 사용하는 것 간에 차이타입 매개변수를 사용한 제네릭 메서드는 해당 타입에 대해 정확한 메서드 호출이 가능하다.또한 타입 매개변수를 사용하는 경우, 메서드 호출 시 컴파일러가 타입을 추론할 수 있다. 반면, 와일드카드는 추론이 어려울 수 있다.또한 타입 매개변수는 구체적인 타입을 지정할 수 있어 컴파일러가 타입 체크를 수행하고 필요한 경우 캐스팅 없이 안전하게 요소를 사용할 수 있다. 반면 와일드 카드는 런타임에 타입이 정확히 무엇인지 알 수 없으며 이로 인해 타입 안정성이 보장되지 않을 수 있다."
  },
  
  {
    "title": "상속과 다형성",
    "url": "/posts/java-inherited/",
    "categories": "Java",
    "tags": "",
    "date": "2024-05-24 00:00:00 +0800",
    





    
    "snippet": "상속상위 클래스의 기능을 하위클래스로 확장하는 것하위 클래스는 상위 클래스의 속성과 메서드를 사용할 수 있고 확장하거나 변경하여 사용할 수 있다.다형성부모 클래스나 인터페이스 타입의 참조 변수를 통해 여러 자식 클래스의 객체를 다룰 수 있는 특징메서드 오버라이딩을 통해 구현되며 실제 메서드 호출은 실행 시간에 결정된다.컴파일 시간의 다형성과 런타임 다...",
    "content": "상속상위 클래스의 기능을 하위클래스로 확장하는 것하위 클래스는 상위 클래스의 속성과 메서드를 사용할 수 있고 확장하거나 변경하여 사용할 수 있다.다형성부모 클래스나 인터페이스 타입의 참조 변수를 통해 여러 자식 클래스의 객체를 다룰 수 있는 특징메서드 오버라이딩을 통해 구현되며 실제 메서드 호출은 실행 시간에 결정된다.컴파일 시간의 다형성과 런타임 다형성이 있다.컴파일 다형성메서드 오버로딩을 통해, 컴파일 시점에 호출될 메서드가 결정된다.런타임 다형성메서드 오버라이딩을 통해, 실행 시점에 실제 객체의 타입에 따라 호출될 메서드가 결정된다.즉, 부모 클래스의 참조 변수가 자식 클래스의 객체를 참조할 때, 실제 객체의 타입에 따라 메서드가 호출된다.참조변수 타입참조 변수의 타입은 Animal 부모 클래스일 수 있지만, 실제로 가리키는 객체는 자식 클래스 Dog, Cat이므로,런타임에 자식 클래스에서 오버라이딩된 메서드가 실행된다.이로 인해 코드가 더 유연하고 확장 가능하며, 새로운 객체나 기능을 쉽게 추가할 수 있다.실제 객체 타입myDog 와 myCat는 각각 Dog 와 Cat 객체를 참조하므로 런타임시 Dog 와 Cat 클래스의 makeSound 메서드가 호출된다.참조 변수의 타입이 아닌 실제 객체의 타입에 따라, 메서드가 실행되는 것이 바로 다형성의 본질이다.이러한 다형성 덕분에 같은 타입의 참조 변수를 사용하여 다양한 객체를 다룰 수 있다.이것은 코드를 더 유연하고 확장이 가능하게 한다.예를 들어 여러 종류의 동물들이 있고 이들을 하나의 Animal 타입으로 처리할 수 있게 되면, 동물 종류가 추가되더라도 기존 코드를 거의 수정하지 않고 새로운 동물 종류를 추가할 수 있다.class Animal {    void makeSound() {        System.out.println(\"Some sound\");    }}class Dog extends Animal {    void makeSound() {        System.out.println(\"Bark\");    }}class Cat extends Animal {    void makeSound() {        System.out.println(\"Meow\");    }}public class Main {    public static void main(String[] args) {        Animal myDog = new Dog();        Animal myCat = new Cat();        makeAnimalSound(myDog);        makeAnimalSound(myCat);    }    static void makeAnimalSound(Animal animal) {        animal.makeSound();    }}makeAnimalSound 메서드는 Animal 타입의 매개변수를 받아서 호출이 되기 때문에, 다양한 동물 객체를 동일한 방식으로 처리할 수 있다.이렇게 하면 동물의 종류가 늘어나더라도 makeAnimalSound 메서드는 수정할 필요가 없다.사용 이유다형성을 통해서 다양한 객체를 동일한 방식으로 처리할 수 있다. 예를 들어 여러 종류의 동물을 처리하는 메서드를 작성할 때 각 동물 별로 별도의 메서드를 작성할 필요없이 Animal 타입의 매개변수를 받아서 처리할 수 있어 보다 유연하다.또한 동일한 코드 블록이 여러 타입의 객체에 대해 동작할 수 있어 코드의 중복을 줄이고 유지보수를 용이하게 한다.새로운 클래스가 추가되더라도 기존의 코드를 수정할 필요 없이, 새로운 클래스의 객체를 처리할 수 있다. (확장성)"
  },
  
  {
    "title": "Exception 예외?",
    "url": "/posts/java-exception/",
    "categories": "Java",
    "tags": "",
    "date": "2024-05-19 00:00:00 +0800",
    





    
    "snippet": "Exception은 프로그램 실행 중 발생하는 예외 상황으로Checked exception과 Unchecked exception 이 있다.Checked Exception컴파일 시점에 발생하며 컴파일러가 예외처리를 강제한다.처리 방법에는 두 가지가 있다.  try-catch 블록을 사용  throws 키워드를 사용예외가 발생할 수 있는 코드를 try로 ...",
    "content": "Exception은 프로그램 실행 중 발생하는 예외 상황으로Checked exception과 Unchecked exception 이 있다.Checked Exception컴파일 시점에 발생하며 컴파일러가 예외처리를 강제한다.처리 방법에는 두 가지가 있다.  try-catch 블록을 사용  throws 키워드를 사용예외가 발생할 수 있는 코드를 try로 감싸고 예외가 발생하는 경우 catch 블록에서 처리한다.throws 키워드는 메서드의 선언부에 사용되어 해당 메서드에서 발생할 수 있는 예외를 호출하는 쪽으로 넘기는 역할을 한다.Unchecked Exception런타임 시점에 발생하는 예외이다.예외 처리를 강제하지 않으며 선택적으로 할 수 있다. 주로 프로그래밍 오류로 발생하며,예로 NullpointerException, ArrayIndexOutOfBoundsException 등이 있다.이를 방지하기 위해서는 사전에 널 체크를 하거나 로깅을 통해서 예외를 추적하거나 디버깅 할 수 있다.예외를 처리하는 방법에는 try catch 문 블럭과 finally 블록을 사용하거나 thwos 키워드를 사용하는 방식, exception을 상속하여 사용자 정의 예외 클래스를 만들어 사용하는 방법들이 있다.사용자 정의 예외 클래스의 장점사용자 정의 예외 클래스를 만들어 사용하는 경우 자바에서 예외처리를 더 유연하고 효율적으로 할 수 있다.디버깅 및 오류 해결에 있어 용이하며, 또한 예외가 발생한 원인을 명확하게 파악할 수 있도록 도와준다. 따라서 코드의 가독성과 유지보수가 용이하다.또한 특정 예외 상황을 처리할 수 있으며 자세한 정보를 추가함으로써 더 유연하게 사용할 수 있다.실제 프로젝트에서는 비즈니스 규칙을 위반하는 경우 사용자 정의 예외 클래스를 생성해 예외로 처리할 수 있다.이처럼 특정 상황에서 프로그램의 흐름을 제어하기 위해 사용자 정의 예외클래스를 만들어 사용할 수 있으며, 이를 통해 예외상황을 파악하고 처리하여 안정성을 높일 수 있다.사용자 정의 예외 클래스를 만들 때 주의할 점?사용자 정의 예외클래스를 생성할 때는 발생한 예외의 종류를 명확하게 나타내는 이름을 설정해야 한다.또한 예외의 특성에 따라 RuntimeException 또는 CheckedException  하나를 상속 받아야 한다.그리고 예외 객체를 생성할 때 의미 있는 예외 메시지를 함께 전달해야하며, 예외 발생 시점을 확인하여 항상 일관되게 처리해야 한다.자바에서 기본적으로 제공하는 예외 클래스와의 차이점사용자 정의 예외 클래스는 사용자가 직접 원하는 예외의 이름과 예외 메시지를 정의할 수 있다.또한 기본으로 제공되는 예외클래스는 표준의 예외 상황을 다루지만, 사용자 정의 예외 클래스는 특정한 상황, 도메인에 대한 예외를 처리하는데 사용된다.그렇기 때문에 사용자 정의 예외 클래스는 프로젝트의 특정 요구사항이나 비즈니스 규칙을 반영하여 만들 수 있다."
  },
  
  {
    "title": "Thread 구현 동기화와 Lock",
    "url": "/posts/java-thread-synchronized/",
    "categories": "Java",
    "tags": "",
    "date": "2024-05-17 00:00:00 +0800",
    





    
    "snippet": "스레드 구현 방법1. 스레드를 확장해서 run() 메서드를 오버라이드한 후 사용public class ThreadExtends extends Thread {    private String message;    public ThreadExtends(String message) {        this.message = message;    }    @...",
    "content": "스레드 구현 방법1. 스레드를 확장해서 run() 메서드를 오버라이드한 후 사용public class ThreadExtends extends Thread {    private String message;    public ThreadExtends(String message) {        this.message = message;    }    @Override    public void run() {        System.out.println(\"Thread started: \" + message);        try {            Thread.sleep(2000);        } catch (InterruptedException e) {            System.out.println(\"Thread interrupted: \" + message);        }        System.out.println(\"Thread ended: \" + message);    }    public static void main(String[] args) {        ThreadExtends thread1 = new ThreadExtends(\"Hello\");        ThreadExtends thread2 = new ThreadExtends(\"World\");        // 스레드 시작        thread1.start();        thread2.start();    }}2. Runnable 인터페이스를 구현해서 스레드의 파라미터로 넘기는 방법public class ThreadRunnable implements Runnable {    private String message;    public ThreadRunnable(String message) {        this.message = message;    }    @Override    public void run() {        System.out.println(\"Thread started: \" + message);        try {            Thread.sleep(2000);        } catch (InterruptedException e) {            System.out.println(\"Thread interrupted: \" + message);        }        System.out.println(\"Thread ended : \" + message);    }    public static void main(String[] args) {        ThreadRunnable runnable1 = new ThreadRunnable(\"Hello\");        ThreadRunnable runnable2 = new ThreadRunnable(\"World\");        Thread thread1 = new Thread(runnable1);        Thread thread2 = new Thread(runnable2);        thread1.start();        thread2.start();    }}Thread 와 임계영역스레드가 동시에 임계 구역에 접근하는 경우 데이터의 일관성을 보장하기 위해 상호 배제 개념을 사용한다.  임계영역이란?  다중 스레드 환경에서 공유 자원에 접근하는 코드 영역  여러 스레드가 동시에 임계 영역에 접근하게 되면 데이터의 일관성이 깨질 수 있다.이러한 문제를 방지하기 위한 방법으로 상호 배제와 동기화 기법이 있다.상호 배제 (Mutual Exclusion)하나의 스레드만 임계 영역에 진입할 수 있도록 한다.즉, 하나의 스레드가 임계영역에 들어가 있으면, 다른 스레드는 그 스레드가 나올 때까지 기다려야 한다.이를 통해 공유 자원에 대한 접근을 순차적으로 제어한다.동기화 (Synchronization)동기화는 스레드들이 공유 자원에 접근하는 순서를 제어하는 방법이다.이를 통해 작업 간 충돌을 방지하고, 작업 완료 전에 다른 스레드가 임계 영역에 들어가는 것을 막는다.상호배제를 구현하기 위한 동기화 방법1. synchronized 키워드특정 메서드나 블록을 해당 키워드로 지정하여 한 번에 하나의 스레드만 블록에 접근할 수 있도록 합니다.public synchronized void add1(int v) {\tthis.count += v;}// 한 번에 하나의 스레드만 이 메소드를 실행할 수 있다.// 공유자원인 count 변수에 대한 동시 접근을 방지한다.public void add2(int v) {    synchronized(this) {        this.count += v;    }}// 블록을 사용하여 특정 객체에 대해 동기화 수행// 메서드 전체를 동기화하는 것보다 세밀한 제어 가능// this 객체에 대해 동기화블록을 사용하여 count 변수 값 변경2. lock 인터페이스더 정교한 제어를 위해 java.util.concurrent.locks.Lock 인터페이스를 사용할 수 있다.ReentrantLock 이 대표적인 구현체로명시적으로 락을 획득하고 해제할 수 있으며, try-lock, 타임아웃을 이용한 잠금 등 다양한 방법으로 동기화 제어가 가능하다.private final Lock lock = new ReentrantLock();public void add(int v) {\tlock.lock();\ttry {\t\tthis.count += value;\t} finally {\t\tlock.unlock();\t}}// lock() 메서드로 잠금을 획득하고 finally 블록에서 unlock() 메서드로 잠금 해제// synchronized 보다 유연한 동기화 제어가 가능합니다.// tryLock() 메서드를 제공하여 잠금을 시도할 수 있습니다.// tryLock() : 잠금을 획들할 수 있으면 true, 아닌 경우 false 반환// 이를 통해 잠금획득에 실패했을 때 대기하지 않고 다른 작업을 수행할 수 있습니다.3. 세마포어세마포어는 특정 개수의 스레드가 임계영역에 접근할 수 있도록 허용하는 방법이다.세마포어의 값이 1 이면 뮤텍스와 동일한 역할을 한다.임계영역을 적절히 관리하여 병행성 문제를 해결하고 데이터 일관성을 유지할 수 있다.하지만 잘못 사용하게 되면, 성능 저하와 데드락 문제가 생길 수 있다."
  },
  
  {
    "title": "Process 와 Tread",
    "url": "/posts/java-process-thread/",
    "categories": "Java",
    "tags": "",
    "date": "2024-05-17 00:00:00 +0800",
    





    
    "snippet": "Process운영체제에 의해서 메모리에 올라가 실행 중인 프로그램각각의 프로세스마다 독립적인 메모리 공간을 가지며, 다른 프로세스의 메모리 공간에 접근할 수 없다.운영체제에 의해 메모리, 입출력 장치 등의 자원을 할당받으며 상태를 갖는다.프로세스는 최소 하나의 스레드를 갖는다.  멀티 프로세스  여러 개의 프로세스가 동시에 실행되는 것각 프로세스가 독...",
    "content": "Process운영체제에 의해서 메모리에 올라가 실행 중인 프로그램각각의 프로세스마다 독립적인 메모리 공간을 가지며, 다른 프로세스의 메모리 공간에 접근할 수 없다.운영체제에 의해 메모리, 입출력 장치 등의 자원을 할당받으며 상태를 갖는다.프로세스는 최소 하나의 스레드를 갖는다.  멀티 프로세스  여러 개의 프로세스가 동시에 실행되는 것각 프로세스가 독립적인 메모리 공간을 갖기 때문에 하나의 프로세스가 죽어도 다른 프로셋스에 영향을 끼치지 않는다.하지만 독립적인 공간을 갖기 때문에 메모리 사용량이 많고 프로세스 간의 통신이 복잡하다.Thread프로세스 내에서 동시에 실행되는 작업의 단위프로세스 내에서 스택 영역만 따로 할당 받고 그 외의 코드, 데이터, 힙 영역은 공유한다.프로세스 내에 존재하며 프로세스가 할당받은 자원을 이용하여 실행된다.  멀티 스레드  하나의 프로세스 안에서 여러 개의 스레드가 병렬적으로 실행되는 방식  CPU 자원을 효율적으로 사용할 수 있고, 응용 프로그램의 성능을 향상시킬 수 있다.여러 스레드가 하나의 프로세스 내에서 실행되기 때문에, 각 스레드는 별도의 메모리 공간을 할당받지 않고, 프로세스의 자원을 공유한다.프로세스 간 문맥 전환에 비해, 스레드 간 문맥 전환이 빨라 성능이 좋다.하지만, 하나의 스레드에 문제가 발생하면 전체 스레드가 영향을 받는 동기화 문제가 발생할 수 있다.  멀티 스레드 환경에서의 주의사항  다수의 스레드가 공유 자원에 동시에 접근하게 되는 경우, 동시성 문제가 발생할 수 있다. 이를 해결하기 위해 동기화 메커니즘을 사용하여 자원의 일관성을 보장해야 한다.두 개 이상의 스레드가 서로 자원을 점유한 상태에서 다른 스레드가 사용 중인 자원을 무한정으로 대기하는 데드락에 빠질 수 있다.데드락을 방지하기 위해서는 자원 획득 순서나 락을 걸어야 한다.멀티 스레드의 동시성과 병렬성동시성은 싱글 코어에서 멀티 작업을 위해 여러 개의 스레드를 실행하는 것이다.동시에 여러 개의 스레드를 실행하는 것으로 보이지만 실제로는 시분할로 빠르게 번갈아 가면서 실행된다.스레드가 교대로 공유 자원에 접근하게 되는데, 이로 인해 데이터의 일관성 문제가 발생할 수 있다.1. 작업 교대의 불예측성스레드 스케줄링을 예측할 수 없고, 언제든지 다른 스레드로 작업이 교체될 수 있다.이로 인해서 스레드가 공유자원에 접근하고 있는 도중에, 다른 스레드가 그 자원에 접근하게 되면, 데이터의 일관성이 깨질 수 있다.2. 중간상태의 노출한 스레드가 공유 자원을 업데이트하는 동안 다른 스레드가 그 자원을 읽거나 수정할 수 있다.만약 첫 번째 스레드가 아직 작업을 완료하지 않은 상태에서 두 번째 스레드가 자원에 접근하면, 두 번째 스레드는 불완전한 중간 상태의 데이터에 접근하게 된다.3. 경쟁 상태경쟁상태는 여러 스레드가 동시에 공유자원에 접근하여 그 자원을 변경하려고 할 때 발생한다.두 스레드가 동시에 변수를 증가시키려고 하면 각각의 스레드가 읽고 수정하는 과정에서 서로의 작업을 덮어쓰기할 수 있다.병렬성은 멀티 코어에서 다중 작업을 처리하기 위해 여러 개의 스레드를 동시에 실행하는 것이다.  즉, 여러 코어가 독립적으로 스레드를 실행하기 때문에, 각 스레드는 물리적으로 동시에 실행된다.  동시성은 주로 작업을 교대로 실행하는 것에 중점을 두고, 병렬성은 실제로 동시에 실행되는 점에서 차이가 있다."
  },
  
  {
    "title": "String 객체를 선언하는 방법",
    "url": "/posts/java-string/",
    "categories": "Java",
    "tags": "",
    "date": "2024-05-15 00:00:00 +0800",
    





    
    "snippet": "String 을 선언하는 방법에는 두 가지 방법이 있습니다.두 방식은 저장 공간(메모리)에 차이가 있습니다.리터럴로 선언리터럴로 선언하는 경우 문자열을 String Constant pool에 저장한다.따라서 메모리의 효율이 좋다.리터럴을 사용하여 생성할 때 상수 풀에 같은 값이 존재하면 객체는 이미 존재하는 값을 참조한다.따라 동일한 문자열을 리터럴로...",
    "content": "String 을 선언하는 방법에는 두 가지 방법이 있습니다.두 방식은 저장 공간(메모리)에 차이가 있습니다.리터럴로 선언리터럴로 선언하는 경우 문자열을 String Constant pool에 저장한다.따라서 메모리의 효율이 좋다.리터럴을 사용하여 생성할 때 상수 풀에 같은 값이 존재하면 객체는 이미 존재하는 값을 참조한다.따라 동일한 문자열을 리터럴로 선언한 변수는 모두 같은 객체를 참조한다.new 키워드 사용new 키워드를 이용하여 선언하는 경우 객체가 힙 메모리에 저장된다.항상 새로운 객체가 생성되기 때문에 항상 새로운 인스턴스가 필요한 경우 사용한다.또한 동일한 문자열의 내용이라도 다른 객체를 참조한다.String a = new String(\"hello\");String b = new String(\"hello\");System.out.println(a == b); // false (두 변수는 다른 객체를 참조)System.out.println(a.equals(b)); // true (두 변수의 문자열 내용은 같음)"
  },
  
  {
    "title": "동등성과 동일성",
    "url": "/posts/java-%EB%8F%99%EB%93%B1%EC%84%B1%EA%B3%BC%EB%8F%99%EC%9D%BC%EC%84%B1/",
    "categories": "Java",
    "tags": "",
    "date": "2024-05-13 00:00:00 +0800",
    





    
    "snippet": "동일성  Identity  메모리 주소가 같음  주소 값이 같기 때문에 두 변수가 같은 객체를 가리킨다.  ==동등성  Equality  값이 같음  두 개의 객체가 같은 정보를 갖는다  객체의 주소가 다르더라도 내용이 같으면 동등~~  equals기본 타입의 변수는 값을 직접 저장하기 때문에 같은 값을 가지는 여러 변수가 있어도각각 독립적으로 메모리...",
    "content": "동일성  Identity  메모리 주소가 같음  주소 값이 같기 때문에 두 변수가 같은 객체를 가리킨다.  ==동등성  Equality  값이 같음  두 개의 객체가 같은 정보를 갖는다  객체의 주소가 다르더라도 내용이 같으면 동등~~  equals기본 타입의 변수는 값을 직접 저장하기 때문에 같은 값을 가지는 여러 변수가 있어도각각 독립적으로 메모리에 존재한다.기본 타입은 == 연산자를 이용해 값의 동일 여부를 비교하며, 두 변수가 같은 값을 가지면 true를 반환한다.참조 타입은 == 연산자로 메모리 주소를 비교하고, equals를 이용하여 값을 비교한다.  참조 타입 변수 중 new 키워드를 사용하여 생성된 객체는 서로 다른 변수를 나타낸다..String c = new String(\"hello\");String d = new String(\"hello\");System.out.println(c == d); // falseSystem.out.println(c.equals(d)); // true하지만 리터럴로 선언하는 경우 동일한 객체를 가리킨다.String a = \"hello\";String b = \"hello\";System.out.println(a == b); // trueSystem.out.println(a.equals(b)); // true"
  },
  
  {
    "title": "Primitive 타입과 Reference 타입",
    "url": "/posts/java-primitive-referencee/",
    "categories": "Java",
    "tags": "",
    "date": "2024-05-07 00:00:00 +0800",
    





    
    "snippet": "Primitive Type기본 데이터 타입으로 정수, 실수, 불리언 등의 실제 데이터 값을 저장하는 타입  int, long, double, float, booleanReference Type객체 참조 타입으로 객체의 주소를 저장하는 타입  배열, 클래스, 인터페이스차이두 타입의 차이는 메모리 저장 위치와 데이터 처리 방식에 있다.메모리 저장 위치pr...",
    "content": "Primitive Type기본 데이터 타입으로 정수, 실수, 불리언 등의 실제 데이터 값을 저장하는 타입  int, long, double, float, booleanReference Type객체 참조 타입으로 객체의 주소를 저장하는 타입  배열, 클래스, 인터페이스차이두 타입의 차이는 메모리 저장 위치와 데이터 처리 방식에 있다.메모리 저장 위치primitive Type  메모리의 스택 영역에 저장하기 때문에 메소드 호출이 종료되면 자동으로 사라진다.  실제 데이터를 스택 영역에 저장하고 그 값은 직접 갖는다.  스택 영역에 저장된 변수들은 값에 직접 접근이 가능하기 때문에, 메모리 절약 및 속도가 중요한 경우에 사용한다.reference Type  객체의 주소를 스택 영역에 저장하고 실제 데이터는 힙 영역에 저장한다.  값을 변경하거나 읽기 위해서는 객체의 주소를 통해서 가능하다.  힙 메모리 특성상 큰 데이터를 처리할 수 있고 생명주기가 길어 레퍼런스 타입은 복잡한 데이터 구조와 대규모 처리에 유용하다.  레퍼런스 타입의 변수는 힙 영역에 저장된 객체를 가리키는 역할을 한다.데이터 처리 방식primitive Type값 자체가 변수에 직접 저장되므로 값에 의해 데이터가 처리된다.reference Type참조 주소를 통해 데이터가 처리된다.프리미티브 타입은 간단한 값 처리에 효율적이고, 레퍼런스는 복잡한 데이터 구조를 다루며 객체 지향 프로그래밍이 가능하게 한다.레퍼런스 타입의 변수가 힙 영역에 저장된 객체를 가리킬 때 주의할 점여러 개의 레퍼런스 변수가 동일한 객체를 참조할 수 있다.이런 경우 하나의 변수를 통해서 객체의 상태가 변경 될 수 있기 때문에, 다른 변수에도 그 상태가 반영이 되어 예상치 못한 결과를 가져올 수 있다.그리고 객체가 더 이상 사용되지 않는 경우 가비지 컬렉션이 객체를 자동으로 제거하는데, 만약 객체가 변수에 의해 참조되고 있으면 가비지 컬렉션이 메모리를 회수할 수 없다. 따라서 메모리 누수가 발생할 수 있다."
  },
  
  {
    "title": "enum",
    "url": "/posts/java-enum/",
    "categories": "Java",
    "tags": "",
    "date": "2024-05-07 00:00:00 +0800",
    





    
    "snippet": "자바에서 관련된 상수의 집합을 정의하는 클래스상수 값을 그룹화하고 타입을 안전하게 보장한다.요일, 월 등 고정된 값 집합을 표현하거나 상태 머신에서 특정한 상태를 나타낼 때 사용하며 코드의 가독성과 유지보수성을 높일 수 있다.내부 메서드를 사용하면 상수의 특성에 따라 각각 다른 동작을 수행할 수 있고, 각 상수의 동작을 구현하거나 해당 상수의 속성을 ...",
    "content": "자바에서 관련된 상수의 집합을 정의하는 클래스상수 값을 그룹화하고 타입을 안전하게 보장한다.요일, 월 등 고정된 값 집합을 표현하거나 상태 머신에서 특정한 상태를 나타낼 때 사용하며 코드의 가독성과 유지보수성을 높일 수 있다.내부 메서드를 사용하면 상수의 특성에 따라 각각 다른 동작을 수행할 수 있고, 각 상수의 동작을 구현하거나 해당 상수의 속성을 반환할 수 있다.enum과 전략 패턴전략 패턴을 사용하여 각 상수마다 별도의 전략을 정의하고 이것을 enum 내부의 메드에서 사용하여 다양한 동작을 수행할 수 있다.전략 패턴을 사용함으로써 각 상수의 동작을 쉽게 확장하고 유연하게 변경할 수 있다.다른 인터페이스를 구현하거나 다른 클래스와 상호작용하는 경우 해당 인터페이스나 클래스를 전략 패턴에 포함하여 각 상수의 동작을 정의할 수 있다.  전략 패턴  행위를 클래스로 캡슐화하고, 동적으로 행위를 바꾸는 디자인 패턴  각각의 클래스(전략)로 캡슐화하여, 특정 클래스의 행위를 유연하게 바꿀 수 있다. 코드의 재사용성과 확장성을 높이는 데 유용"
  },
  
  {
    "title": "오버로딩과 오버라이딩",
    "url": "/posts/java-overroading/",
    "categories": "Java",
    "tags": "",
    "date": "2024-05-04 00:00:00 +0800",
    





    
    "snippet": "오버로딩 ️Overloading같은 이름의 메소드나 생성자를 여러 개 정의하는 것으로 매개변수의 타입 또는 개수가 달라야 한다.예시  println() 메서드          System.out 객체의 메소드로 여러 형태로 오버로딩 되어있다.      정수형, 실수형, 문자열 등 다양한 타입의 매개 변수를 받는 메서드를 오버로딩하여 제공한다.     ...",
    "content": "오버로딩 ️Overloading같은 이름의 메소드나 생성자를 여러 개 정의하는 것으로 매개변수의 타입 또는 개수가 달라야 한다.예시  println() 메서드          System.out 객체의 메소드로 여러 형태로 오버로딩 되어있다.      정수형, 실수형, 문자열 등 다양한 타입의 매개 변수를 받는 메서드를 오버로딩하여 제공한다.      클래스의 생성자를 여러 개로 정의하여 다양한 초기화 방법을 제공할 수 있다.오버라이딩 ️Overriding부모 클래스에서 정의된 메서드를 자식 클래스에서 재정의하는 것자식 클래스에서 재정의된 메소드는 부모 클래스의 메소드와 이름, 매개변수타입, 반환 타입이 동일하다.오버라이딩을 했을 때 부모 클래스 메서드의 동작자식 클래스에서 정의된 메소드가 호출이 되면 부모 클래스의 메서드는 가려진다.부모 클래스의 메소드 내용은 무시되고 자식 클래스에서 정의된 메서드가 실행된다.만약 자식 클래스에서 부모 클래스의 메서드를 호출하고 싶으면 super키워드를 사용한다.super부모 클래스로부터 상속받은 필드나 메서드를 자식 클래스에서 참조하는데 사용하는 참조 변수자식 클래스의 생성자에서 super() 메소드를 호출하면 부모 클래스의 기본 생성자가 된다.만약 super(매개변수)로 호출하면 부모 클래스에서 매개변수를 받는 생성자를 호출한다.  주의해야 할 부분!  super()은 부모 클래스의 생성자는 자식 클래스의 생성자보다 먼저 실행되어야 한다.그래서 생성자 첫 줄에 super() 을 호출해야하며, 그렇지 않으면 컴파일 에러가 발생한다.  또한 자식 클래스에 생성자가 여러 개 있으면 모든 생성자에서 super()을 사용해야한다. 그렇지 않으면 사용되지 않는 생성자에서는 부모 클래스의 생성자 호출이 누락되어 오류가 생길 수 있다.  자식 클래스에서 super()을 사용하지 않으면 부모 클래스의 기본 생성자가 호출이 되는데부모 클래스에 매개변수를 받는 생성자는 존재하나, 기본 생성자가 없는 경우 명시적으로 부모 클래스에 기본 생성자를 생성해 주어야 한다.자식 클래스의 생성자에서 super()를 호출하지 않은 경우 발생하는 컴파일 에러자식 클래스에서 super()을 호출하지 않으면 “implicitly super constructor is undefined”컴파일 에러가 발생한다.  해결하기 위해서는 부모 클래스에 기본 생성자를 생성하거나, 부모 클래스에 다른 매개변수를 받는생성자를 super()을 사용해서 호출해야 한다."
  },
  
  {
    "title": "TCP/ UDP",
    "url": "/posts/network-tcp-udp/",
    "categories": "Network",
    "tags": "",
    "date": "2024-04-29 00:00:00 +0800",
    





    
    "snippet": "전송 계층에서 사용하는 두 가지 주요 프로토콜TCP (Transmission Control Protocol)키워드 : 연결 설정, 신뢰성, 전송제어, 속도조절, 패킷순서, 재전송  연결 지향적 프로토콜로 통신 전에 연결을 설정하고 통신이 완료되면 연결을 해제합니다. (3way handshake)  데이터를 순서대로 조립해서 보내며 데이터를 유실한 경우...",
    "content": "전송 계층에서 사용하는 두 가지 주요 프로토콜TCP (Transmission Control Protocol)키워드 : 연결 설정, 신뢰성, 전송제어, 속도조절, 패킷순서, 재전송  연결 지향적 프로토콜로 통신 전에 연결을 설정하고 통신이 완료되면 연결을 해제합니다. (3way handshake)  데이터를 순서대로 조립해서 보내며 데이터를 유실한 경우 재전송합니다.  네트워크에 트래픽이 몰리는 경우 전송 속도를 조절하여 혼잡을 제어합니다.      일단 데이터가 왔다고 하면 그 데이터는 온전한 데이터임을 보장합니다.    하는 일이 많다보니 부하가 크고 속도가 상대적으로 느립니다.  웹 서비스, 파일 전송, 파일 다운로드 등 신뢰성과 순서 보장이 필요한 응용 프로그램에 적합합니다.UDP (User Datagram Protocol)키워드 : 비신뢰성, 비연결성, 속도  비연결 지향적 프로토콜로 송신자와 수신자의 연결을 확립하지 않고 데이터를 전송합니다.  한 번 전송한 후, 확인하지 않습니다. (재전송 X)  순서와 중복, 데이터의 손실에 대해 전송을 보장하지 않습니다.  실시간 데이터 같은 경우 많은 트래픽을 계속해서 보내기 때문에 TCP로 하기에는 부하가 큽니다.  부하가 적어 빠른 속도로 데이터를 전송할 수 있다  게임, 실시간 스트리밍 서비스 등 속도가 중요하고 약간의 데이터 손실이 허용되는 실시간 응용 프로그램에 적합합니다."
  },
  
  {
    "title": "TCP 3-way handshake, 4-way handshake 동작 방식",
    "url": "/posts/network-handshake/",
    "categories": "Network",
    "tags": "",
    "date": "2024-04-29 00:00:00 +0800",
    





    
    "snippet": "3-way handshake ?TCP 연결을 설정하는 과정(TCP/IP 프로토콜을 이용해서) 통신을 하는 응용 프로그램이데이터를 전송하기 전에 정확한 전송을 보장하기 위해 상대방 컴퓨터와의 세션을 수립하는 과정  Control bits      SYN : 연결 설정    ACK : 응답 확인, 패킷을 받았다는 것 의미 (Acknowledgement N...",
    "content": "3-way handshake ?TCP 연결을 설정하는 과정(TCP/IP 프로토콜을 이용해서) 통신을 하는 응용 프로그램이데이터를 전송하기 전에 정확한 전송을 보장하기 위해 상대방 컴퓨터와의 세션을 수립하는 과정  Control bits      SYN : 연결 설정    ACK : 응답 확인, 패킷을 받았다는 것 의미 (Acknowledgement Number)    FIN : 연결 해제, 세션 종료, 더 이상 전송할 데이터 없음  동작방식[Step1] Client -SYN-&gt; Server**나 너한테 접속할건데 괜찮니?  Client가 Server에게 접속을 요청한다. (SYN 비트 설정)[Step2] Client &lt;-SYN + ACK- Server웅 괜찮아!  서버는 클라이언트의 요청을 수락하고, 동시에 클라이언트에 자신의 연결 요청을 보낸다.  SYN(연결요청) + ACK(응답) 전송 (LISTEN -&gt; SYN_RECV)  그 후 Server는 다시 대기 상태[Step3] Client -ACK-&gt; Server오케이 -&gt; 연결 성립 (Establised)  Client는 서버의 요청을 확인하고 ACK 로 응답한다.이 과정을 통해 TCP 세션이 수립되고, 이후 데이터를 주고받을 수 있는 안정적인 통신상태가 된다.4-way handshake ?TCP 연결을 종료하는 과정연결 종료는 양쪽 호스트 모두 먼저 시도 가능  클라이언트 : 연결을 먼저 요청하는 Host  서버 : 연결을 요청받는 Host  클라이언트-클라이언트의 형태  Control bits      ACK최초 연결의 첫 번째 세그먼트를 제외한 모든 Segment의 ACK 비트는 1로 설정 최초 연결의 첫 번째 Handshake 과정에서는 응답할 요청이 없음    RST(Reset) : TCP 연결을 강제로 종료할 때 사용    Port 상태 정보      ESTAB 포트가 연결된 상태    CLOSE-WAIT 상대방의 FIN(종료 요청)을 받은 상태 상대방 FIN에 대한 ACK를 보내고 애플리케이션에 종료를 알린다    LAST-ACKCLOSE-WAIT 상태를 처리 후 자신의 FIN요청을 보낸 후 FIN에 대한 ACK를 기다리는 상태    FIN-WAIT-1자신이 보낸 FIN에 대한 ACK를 기다리거나 상대방의 FIN을 기다린다.    FIN-WAIT-2자신이 보낸 FIN에 대한 ACK를 받았고 상대방의 FIN을 기다린다.    CLOSING상대방의 FIN에 ACK를 보냈지만 자신의 FIN에 대한 ACK를 못받은 상태    TIME-WAIT모든 FIN에 대한 ACK를 받고 연결 종료가 완료된 상태 새 연결과 겹치지 않도록 일정 시간 동안 기다린 후 CLOSED로 전이한다.    CLOSED연결 수립을 시작하기 전의 기본 상태 (연결 없음)  동작방식[STEP1] 클라이언트 -FIN-&gt; 서버연결종료 가능하니?  클라이언트가 서버에 연결 종료를 요청하는 FIN 패킷을 전송한다.FIN 비트 : 1  이때 FIN 패킷에는 실질적으로 ACK도 포함  클라이언트는 FIN-WAIT-1 상태로 전환되며 ACK를 기다린다.[STEP2] 클라이언트 &lt;-ACK- 서버우웅! 잠만! 확인해볼게!  서버는 FIN을 받고 확인했다는 ACK를 클라이언트에 보낸 후 자신의 통신이 끝날때까지 기다림  남은 데이터가 있는 경우 이를 처리한 후 close() 호출  클라이언트는 ACK를 받은 후 서버가 남은 데이터 처리를 끝내고 FIN 패킷을 보낼 때까지 기다림  클라이언트는 FIN_WAIT_2 상태로 전환[STEP3] 클라이언트 &lt;-FIN- 서버종료하자!  서버는 남은 데이터를 모두 전송한 후, 연결 종료를 요청한다.  FIN 패킷을 클라이언트에 전송  서버는 LAST_ACK 상태로 전환  이후 클라이언트의 ACK 응답을 기다린다.[STEP4] 클라이언트 -ACK-&gt; 서버우웅! 아직 안 온 거 있을 수 있으니까 좀만 기다렸다가 종료해야지  클라이언트는 FIN 을 받고, 응답 ACK 를 서버에 전송  클라이언트는 아직 서버로 부터 받지 못한 데이터가 있을 수 있으므로 TIME_WAIT 를 통해 기다린다.[AFTER]  서버는 ACK 를 받은 이후 즉시 연결을 종료한다.      TIME_WAIT 시간이 끝나면 클라이언트도 소켓을 Closed    TIME_WAIT : 의도치 않은 에러로 인해 데드락으로 빠지는 것을 방지, 클라이언트는 마지막 ACK를 보낸 후, 일정 시간 동안 연결을 유지하며, 지연된 패킷이 도착할 가능성을 대비3-way-handshake와 차이가 나는 이유?클라이언트가 데이터를 전송을 마쳤다고 하더라도 서버는 아직 보낼 데이터가 남아있을 수 있기 때문이다.FIN 에 대한 ACK를 보낸 후, 남은 데이터를 모두 전송한 후에 자신도 FIN 메시지를 전송한다.서버는 마지막 FIN 을 보내기 전 아직 전송하지 못한 데이터를 전송한다.그러나 데이터가 유실되어 재전송하거나 지연되어 FIN 보다 늦게 도착할 수 있다.따라서 클라이언트는 FIN을 받은  TIME_WAIT 를 통해 혹시 모를 패킷 수신을 기다린다Abrupt Connection Release(갑작스런 연결 해제)RST(TCP reset) :  RST 비트가 설정된 세그먼트를 전송하면, 연결이 즉시 종료된다.  ACK 과정 없이, 송신자와 수신자는 바로 연결을 종료한다.  정상적으로 닫기 위한 데이터 전송을 기다리지 않고 강제로 세션을 종료한다.  RST 비트를 1로 설정한 세그먼트를 전송한다.          송신자는 패킷을 보내고 바로 연결 종료      수신자는 패킷을 받으면 바로 연결 종료      RST를 사용해 연결을 종료하는 경우  보안 위반의 경우          악성 코드 또는 의심스러운 트래픽이 탐지되면, 즉시 연결을 종료하여 시스템을 보호한다.            시스템 자원 부족으로 새로운 연결을 유지할 수 없을 때, RST를 사용해 빠르게 자원을 해제하고 다른 연결을 처리한다.    TCP 연결에 장애가 발생했거나, 비 정상적인 세션이 감지되면, 즉시 연결을 끊고 새로운 연결을 시도한다.RST의 특징  연결 종료 과정에서의 절차적 보장이 없다는 점에서, 일반적인 FIN 플로우와 차이가 있다.  빠른 종료가 필요할 때 유용하지만, 연결 중인 데이터를 잃을 위험이 있다."
  },
  
  {
    "title": "URL (Uniform Resource Locator)",
    "url": "/posts/network-url/",
    "categories": "Network",
    "tags": "",
    "date": "2024-04-28 00:00:00 +0800",
    





    
    "snippet": "URI (Uniform Resource Indentifier)리소스를 식별할 수 있는 문자열URL은 URI의 한 부분으로, URI는 더 광범위한 개념  URL (Locator) : 리소스의 위치  URN (Name) : 리소스의 이름, 위치와 무관하게 리소스를 유일하게 식별모든 URL은 URI 이지만, 모든 URI가 URL인 것은 아니다.URL(Uni...",
    "content": "URI (Uniform Resource Indentifier)리소스를 식별할 수 있는 문자열URL은 URI의 한 부분으로, URI는 더 광범위한 개념  URL (Locator) : 리소스의 위치  URN (Name) : 리소스의 이름, 위치와 무관하게 리소스를 유일하게 식별모든 URL은 URI 이지만, 모든 URI가 URL인 것은 아니다.URL(Uniform Resource Locator)웹 상의 리소스의 위치, 주소어디에서 해당 리소스를 찾을 수 있는지 나타낸다.  특정 책의 선반 위치  https:www.example.com/pageURN(Uniform Resource NAME)리소스의 이름리소스의 위치과 관계없이 리소스를 유일하게 식별한다.  책의 고유한 ISBN  urn:isbn:0451450523  URI : 주소 체계 전체URL : 어디에 있는지URN : 무엇인지https://www.naver.com:443/?1. https  Hypertext Transfer Protocol Secure  HTTPS는 HTTP의 보안 버전  데이터 전송 시 보안을 강화하여 사용자 개인정보 보호 및 데이터 무결성을 유지한다.  TLS, SSL을 사용하여 암호화된 연결을 설정한다.2. www  호스트 명으로 웹 서버를 식별하는 데 사용된다.  이 외 다양한 호스트명이 있다.3. naver.com  도메인 네임으로 IP 주소 대신 사용된다.  인터넷에서 특정 웹 사이트 식별  읽기 쉬운 형태의 주소4. 443  포트 번호  클라이언트가 특정 서비스에 연결할 수 있도록 한다.  여러 서비스가 실행되는 서버에서는 포트 번호를 통해 해당 서비스에 직접 연결할 수 있다.  서버는 여러 서비스를 동시에 제공할 수 있도록 포트 번호를 사용한다.  웹 브라우저는 URL에서 포트 번호를 확인하여, 해당 포트로 연결을 시도하고 서버와 통신을 시작한다.  일반적으로 HTTPS를 사용하는 경우 443 포트 이용한다.  단일 IP 주소에서 여러 서비스가 동시에 실행될 수 있도록한다.  명확성 구분하나의 서버에서 다양한 서비스를 제공하는 경우각 서비스는 다른 포트 번호를 사용한다.예를 들어, 웹 서비스는 80 또는 443 포트를, FTP는 21 포트를, SMTP는 25 포트를 사용한다.  포트 번호를 통해 클라이언트가 특정 서비스를 연결하고 있다는 것을 명확하게 알 수 있다.이것은 여러 서비스가 동시에 운영되는 환경에서 매우 중요하다.  또한 서버에서 기본 포트가 아닌 비표준 포트를 사용할 수 있다.예를 들어, 웹 서비스가 8080 포트에서 운영될 수 있다.이 경우 http://naver.com:8080와 같이 명시적으로 포트를 지정해야 한다.HTTP5. 리소스 경로 (/)  /는 서버의 루트 디렉토리 (홈페이지/ 메인페이지)  서버의 특정 파일이나 디렉토리에 접근할 수 있도록 한다.  추가적인 경로가 포함될 수 있으며, 예를 들어 /about와 같은 형태로 특정 페이지에 접근할 수 있다.도메인과 서브 도메인  도메인을 산다 -&gt; naver.com 와 같은 도메인 이름을 등록하고 사용할 권리를 갖는 것이다.  도메인을 구입한 후, 그 앞에 www 라는 웹 서버를 설정할 수 있다.  도메인 이름은 전 세계에서 유일하다.  서브 도메인인 www 는 naver.com 도메인 하에서 운영되는 특정 웹 서비스를 나타낸다.  서브 도메인은 특정 서비스나 서버를 분리하고 식별하는 데 사용한다.  www : 웹 서비스ftp : 파일 전송 서비스mail : 이메일 서비스일반적으로 웹 서비스를 담당하는 호스트는 www를 사용하는 것이 관례이다  사용자는 웹 브라우저에 https://www.naver.com:443/를 입력한다.  브라우저는 naver.com 도메인을 DNS를 통해 IP 주소로 변환한다.  브라우저는 HTTPS 프로토콜을 사용하여 443 포트로 웹 서버에 연결을(TCP) 시도한다.          연결이 수립되면, 서버는 포트 번호를 바탕으로 어떤 서비스에 해당하는지 판단한다.      그리고 요청을 서비스로 전달한다.        서버는 웹 페이지 데이터를 암호화하여 브라우저로 전송한다.  브라우저는 수신한 데이터를 렌더링하여 사용자가 볼 수 있는 웹 페이지를 표시한다.naver.com 이라는 도메인을 가진 www 서버에 443 포트로https 프로토콜을 이용해서 이 홈페이지로 접속해라"
  },
  
  {
    "title": "OSI 7 계층과 주소창에 naver.com을 치면 일어나는 일",
    "url": "/posts/network-osi7/",
    "categories": "Network",
    "tags": "",
    "date": "2024-04-28 00:00:00 +0800",
    





    
    "snippet": "OSI 7 계층  물리 계층          물리적인 연결을 담당하며, 물리적 매체를 통해 데이터를 전송한다.      이더넷 케이블, 광섬유, 전송 매체의 전기적/ 광학적 특성        데이터 링크 계층          데이터의 오류를 감지하고 수정하며, 물리 계층을 통해 전송되는 데이터를 프레임으로 변환하여 전달한다. 네트워크 내에서 노드간의 ...",
    "content": "OSI 7 계층  물리 계층          물리적인 연결을 담당하며, 물리적 매체를 통해 데이터를 전송한다.      이더넷 케이블, 광섬유, 전송 매체의 전기적/ 광학적 특성        데이터 링크 계층          데이터의 오류를 감지하고 수정하며, 물리 계층을 통해 전송되는 데이터를 프레임으로 변환하여 전달한다. 네트워크 내에서 노드간의 데이터 전송을 담당한다.      MAC 주소, 스위치, 이더넷        네트워크 계층          라우터를 이용하여 최적의 경로를 설정하여 데이터를 전달하고 라우팅하는 과정을 수행한다.      트래픽 관리 및 패킷 분할을 수행한다.      IP 주소, 라우터, IP 프로토콜        전송 계층          신뢰성 있는 데이터의 전송을 보장한다.      데이터 전송을 수행한다.      TCP, UDP        세션 계층          세션을 연결하고 유지한다.      애플리케이션 간의 통신 세션을 관리하고, 데이터 교환의 동기화를 제공한다.        표현 계층          데이터의 표현 방식을 관리한다.      암호화 알고리즘등을 암호화 및 압축을 수행한다.      데이터 압축, 암호화, 인코딩        응용 계층          사용자와 애플리케이션 간의 인터페이스를 제공한다.      웹 브라우저, FTP      주소창에 naver.com을 치면 일어나는 일1. URL 입력 및 DNS 조회사용자가 웹 브라우저에 naver.com을 입력한다.브라우저는 먼저 DNS 서버에 도메인 네임(naver.com)의 IP 주소를 요청한다.   이 과정을 통해 도메인 네임을 IP 주소로 변환한다.  DNS  도메인 네임에 매핑되는 IP 주소를 알려준다.2. 데이터 링크 계층DNS 쿼리로 받은 IP 주소를 가지고 개인의 컴퓨터를 빠져나와 스위치에 패킷을 전송한다.스위치에서 ARP 테이블을 통해서 IP 주소에 해당하는 MAC 주소를 찾는다.해당 네트워크 내에 있는 장치 중 이 MAC 주소를 가진 장치가 있는지 확인한다.   ARP 요청을 브로드캐스트하여 MAC 주소를 알아내고, 그 정보를 ARP 테이블에 저장한다.  ARP 테이블과 동작 원리      ARP 테이블은 각 네트워크 장치가 IP 주소와 MAC 주소의 매핑 정보를 저장하는 테이블이다.    각 장치는 네트워크 내에서 통신할 때, 테이블을 통해 IP에 대응하는 MAC주소를 확인할 수 있다.    [ARP 요청]장치 A는 장치 B의 MAC 주소를 알아내기 위해 네트워크 전체에 브로드캐스트로 ARP 요청을 전송한다.  “해당 IP 주소를 가진 장치의 MAC 주소를 알려줘~”  네트워크 내의 모든 장치가 브로드캐스트를 수신한다.  [ARP 응답]해당 IP 주소를 가진 장치 B는 자신의 MAC 주소를 ARP응답 패킷에 담아 장치 A에 유니캐스트로 응답한다.장치 A는 B에게 받은 MAC주소를 자신의 ARP 테이블에 저장한다.향후 다시 B에게 패킷을 전송할 때 ARP테이블에 저장된 MAC주소를 이용한다.  브로드캐스트 과정  컴퓨터를 켜면 스위치에 신호가 들어간다 나 : 스위치야 ~ 나 켜졌으니까 IP 주소를 주겠니? 스위치 : 자 ~ 이거 너 IP야~~이런식으로 스위치가 IP를 알려준다  -&gt; 그 후, 스위치는 다른 장치들에 “이런 IP 주소에 이런 MAC 주소를 갖는 아이가 들어왔어~~”라며 브로드캐스트를 한다  그렇게되면 이제 스위치에 연결된 모든 컴퓨터와 네트워크는 ARP 테이블에 해당 정보를 하나 추가한다.  랜? 이더넷? arp?토큰링  만약 스위치에 1000대의 컴퓨터가 연결되어있다면!!1000대의 컴퓨터가 켜졌다/꺼졌다 할 텐데 그럴때마다 모든 컴퓨터에게브로드캐스트를 날려서 ARP테이블을 업데이트 시켜야한다.  그렇게 되면 그 1000대의 컴퓨터는 불필요하나 작업을 계속하게 된다.  그러면 부담이 생기기 때문에 브로드캐스트가 되는 범위를 좁혀줘야한다. 그리고 이 범위를 구분하기 위한 것이 넷 마스크이다.  즉, 넷 마스크는 네트워크를 구분하기 위한 것이다.  OSI 관점에서 IP와 넷마스크 주소가 동일한 애들은 같은 네트워크로 본다 (AND 연산)같은 네트워크에 있는 컴퓨터는 브로드캐스트와 arp를 공유하게 되고 네트워크가 다르면영향을 받지 않는다  스위치      네트워크 내에서 여러 장치 간에 데이터를 전송하는 장치    주로 로컬 네트워크(LAN)에서 사용된다.    MAC 주소를 사용하여 패킷을 네트워크 내에서 전송한다.    여러 포트를 가지고 있으며, 각 포트는 개별적인 네트워크 장치에 연결된다.    포트 간에 데이터를 전송, 관리하며 네트워크 트래픽을 효율적으로 관리한다.    패킷이 동일 네트워크 내의 장치가 아닌 경우, 패킷 공유기(라우터)로 전달한다.    이때, 패킷의 목적지로 가는 최적의 경로는 공유기(라우터)가 처리한다.    2~4 계층 까지 처리할 수 있는 장비이지만 주로 2계층 처리한다.    스위치와 공유기로 보는 데이터 이동 과정  네트워크 구성에서는 스위치와 공유기가 함께 사용된다.  1. 내부 네트워크 (LAN):  네트워크 내에 연결된 장치(컴퓨터, 서버, 프린터)는 모두 스위치에 연결된다.   내부 네트워크에서 통신하는 경우 스위치를 통해 데이터가 전달된다 (집 : 나 &lt;-&gt; 아빠   ex) 컴퓨터 A에서 컴퓨터 B로 데이터를 보낼 때,   스위치는 컴퓨터 B의 MAC 주소를 찾아 해당 포트로 데이터를 전송한다.  2. 라우터(공유기)를 통한 외부 네트워크 (인터넷) 연결:  공유기는 내부 네트워크와 외부 네트워크(인터넷)를 연결하는 역할을 한다  외부 네트워크와의 통신을 관리하고 내부 네트워크의 장치들이 인터넷에 접속할 수 있도록 한다. 내부 네트워크에 연결된 모든 장치는 공유기에 연결되어 있으며, 데이터가 외부 네트워크로 전송될 때는 공유기를 통해 전송된다  따라서 데이터가 내부 네트워크에서 스위치를 통해 이동한 후, 외부 네트워크로 전송될 때는 공유기를 통해 이동한다.  IP 주소와 MAC 주소  ◾️ IP 주소?  IP 주소는 LAN 카드에 연결되어 있는 회선(랜선)의 주소로, 고정되지 않고, 인터넷 망에 접속할 때마다 달라진다  라우팅 기법은 패킷에 포함된 IP주소를 추적하여 최단 경로를 선택한다.IP 주소는 논리적인 주소로, 라우터들은 이 IP 주소를 추적해 목표 네트워크까지 패킷을 전달한다.목표 네트워크에 도착한 패킷은 IP 주소를 기반으로 해당 장치의 MAC 주소로 변환되며,그 MAC 주소를 사용하여 최종적으로 해당 컴퓨터로 패킷이 전송된다.  ◾️ MAC 주소는?  네트워크 상에서 서로를 구분하기 위해 장치마다 할당된 물리적인 주소로,   인터넷이 가능한 장비들이 가지고 있는 고정된 값이다.  집에서 naver.com의 웹 서버를 찾는다고 가정했을때,  라우터는 IP 주소를 사용해 목적지 서버까지의 최적의 경로를 찾아서 전달한다. 반면, MAC 주소는 같은 네트워크 내에서 사용되며,IP주소와 MAC 주소 간 변환은 각 네트워크의 마지막 단계에서 이루어진다.  IP는 최적의 경로를 찾아주는 라우팅을 하기 위한 주소이고, 실질적인 통신은 MAC 주소로 한다!3-1. 해당 네트워크에 MAC 주소가 있는 경우MAC 주소를 찾은 후 스위치는 해당 MAC 주소를 갖는 컴퓨터로 패킷을 전달한다. 이 과정에서 데이터 링크 계층의 프레임을 사용한다.3-2. 해당 네트워크에 MAC 주소가 없는 경우 -&gt; 라우터를 통한 네트워크 계층네트워크 내에 MAC 주소가 없으면 스위치에서 라우터(공유기)를 통해 다른 네트워크로 이동한다.네트워크 계층에서는 네트워크 간의 통신이 일어난다.naver.com의 IP 주소를 확인하고, 이를 바탕으로 라우팅 테이블을 참조하여 다음 라우터를 결정한다.출발 장치는 다음 라우터로 네이버의 IP 주소가 포함된 패킷을 전송한다.패킷이 출발 장치에서 생성될 때, 출발 장치의 네트워크 카드는 자신의 MAC 주소를 패킷의 출발지 주소로 설정하고, 패킷의 목적지 주소는 해당 패킷을 처리할 라우터의 MAC 주소로 설정됩니다라우터를 거치면서 각 라우터는 서로 정보를 공유하고, 라우팅 테이블을 업데이트하여 최적의 경로를 제공한다.출발지 장치의 네트워크 카드를 식별하는 이유  네트워크에서 효율적인 통신을 가능하게 하기 위함      패킷 라우팅: 네트워크에서 패킷을 보낼 때, 출발지 장치의 네트워크 카드는 패킷의 출발지를 식별하는데 사용된다. 이를 통해 목적지로 패킷을 전송할 때 어디에서 왔는지 알 수 있다.        네트워크 보안: 네트워크 보안에서 출발지 장치의 네트워크 카드는 인증 및 접근 제어에 사용된다.네트워크에 접근하려는 디바이스가 실제로 인가된 디바이스인지 확인하기 위해 네트워크 카드의 고유 식별 정보가 사용된다.        네트워크 장애 해결: 네트워크에서 문제가 발생할 때, 네트워크 카드의 식별 정보를 사용하여 문제를 해결할 수 있다.각 장치의 네트워크 카드는 고유한 식별자를 가지고 있어, 문제가 발생한 장치를 식별하고 추적하는 데 사용될 수 있다.    라우터?      네트워크 계층에서 동작하며, 패킷을 서로 다른 네트워크 간에 데이터 패킷을 전달하는 장치    라우팅 과정을 통해 목적지 네트워크에 도착하면, 해당 네트워크의 스위치가 패킷을 처리합니다.    이 스위치는 다시 ARP 요청을 통해 최종 목적지 MAC 주소를 찾고, 패킷을 최종 장치로 전달합니다.    공유기는 방화벽, DHCP 서버, 포트 포워딩 등의 기능을 제공    ISP (Internet Service Provider)  LAN은 집 안 사람들 간에 정보는 전달할 수 있짐만,  외부의 웹사아트(네이버)에 접속하거나, 멀리 있는 사람과 연락하는 것은 불가능하다. 이때, 필요한 것이 ISP이다.  여기에 우리가 잘 알고있는 SK, KT, U+ 가 있다.  이 회사 들이 우리나라 전역에 인터넷 케이블을 설치하였다. 우리는 돈을 지불하고 이 케이블을 사용한다.  이렇게 ISP가 제공하는 보다 광범위한 네트워크를 WAN이라고 한다.  이렇게 집 안 컴퓨터들은 공유기나 ISP가 제공하는 장비를 통해 WAN에 연결된다.   WAN은 여러 LAN(집, 회사, 건물)으로 구성된 네트워크를 서로 연결해준다.4. 패킷 전달패킷은 이러한 과정을 반복하여 네이버 서버에 도착한다.5. 전송 계층네이버 서버가 패킷을 수신한 후, TCP, UDP 프로토콜을 이용하여 클라이언트와 서버 간 연결을 설정한다.연결이 정상적으로 이루어지면, 서버는 소켓을 생성하고 열어 데이터를 주고 받을 준비를 한다.peer 2 peer ( host to host )택배 배송 과정으로 비유하면, 그 전까지의 과정은 택배기사가 문 앞까지 배송해 준 과정입니다. 반면, 전송계층(4)은 내가 택배의 주인인 집 구성원에게 직접 가져다 주는 과정을 의미한다.TCP, UDP의 공통점인 포트 번호의 필요성      클라이언트 프로그램이 네트워크 상의 특정 프로그램을 지정할 때 사용한다.    서버에 접속할 때, 어느 서비스에 연결할지 포트번호를 통해 지정한다.    각 포트 번호는 특정 프로그램이나 서비스에 할당되어 있어, 어떤 프로그램이 해당 서비스를 담당하는지 알 수 있도록 한다.    만약 우리 컴퓨터에 여러 개의 프로그램(브라우저, 워드, 파워포인트)이 동시에 실행되고 있는 경우, 모두가 네트워크를 필요로 할 때,  어떤 프로그램이 요청했는지 알 수 없다.    따라서, 각 프로그램이 요청한 패킷을 올바른 서비스로 전달하기 위해 포트 번호가 필요하다.    https : 443, http : 80  소켓?  데이터 통신을 위한 읽기 및 쓰기 작업을 수행할 수 있는 하나의 통로이다.  4 계층에서 처리된 데이터를 5 계층으로 전달한다.6. 세션 계층5계층에서 세션이 설정되면 실제 데이터 교환이 이루어진다.세션은 클라이언트와 서버 간의 연결을 유지하기 위한 상태 관리 기능을 제공한다. 데이터의 흐름을 관리하며, 연결된 상태를 유지하여 안정적인 통신을 가능하게 한다.  세션  키워드 : 상태유지      사용자의 로그인 상태 및 서비스 이용 정보를 유지하기 위해 사용된다.    naver.com 에 접속을 한 이후에 재접속할 때, 서버는 사용자의 정보를 저장하고 세션ID를 발급한다.    사용자가 이 session Id를 가지고 다시 접속하면, 서버는 해당 ID를 통해 사용자를 식별할 수 있다.    즉, 세션은 사용자가 로그인하거나 서비스를 이용하는 동안 상태를 지속적으로 유지하는 것을 의미한다.  7. 표현 계층6계층에서 데이터가 네이버 서버에서 클라이언트로 전달되기 전,표현 계층은 필요한 인코딩, 암호화 등을 처리한다.실제 서비스를 사용하는 것과 유사하게, 표현 계층은 데이터를 포장해서 물건을 확인하는 과정에 비유할 수 있다.우리가 살 수 있는 다양한 물건이 존재하는 것처럼, 7계층에는 다양한 서비스가 존재한다.8. 응용계층데이터 형식이 변환된 후, 7계층에서 브라우저는 웹 페이지를 렌더링한다.이 과정에서 사용자가 웹사이트와 상호작용할 수 있도록 필요한 기능을 제공한다.   사용자와 직접적으로 연결되는 계층으로, 다양한 네트워크 서비스를 제공하여 최종 사용자가 원하는 정보를 손쉽게 접근할 수 있도록 한다.  그 중 HTTP는 뭘까 ?      문자열을 전송하는 프로토콜로 클라이언트와 서버 간 데이터 교환을 담당한다.    텍스트 기반의 통신 규약 : 문자열을 전송할때 문자열의 엔터, 대행문자, 특수문자 등을 처리하기 위해어떻게 처리하고 몇 개를 쪼개는 등 이러한 부분에 있어서 사전에 정해진 규칙을 따른다. 데이터를 쪼개거나 포맷팅하는 작업을 포함한다.    연결을 유지하지 않는 비 연결성 프로토콜로 Session 과 Cookie 가 등장했다.    주로 웹 서비스에서 사용되어, 사용자가 웹 페이지를 요청하고 응답받는 과정에서 필수적인 역할을 한다.  웹 서비스와 HTTP 프로토콜인터넷 기반이 대표 서비스 중 하나            이름      프로토콜      포트      기능                  WWW      HTTP      80      웹서비스              Email      SMTP/POP3/IMAP      25/110/114      이메일 서비스              FTP      FTP      21      파일 전송 서비스              DNS      TCP/UDP      53      네임 서비스              NEWS      NNTP      119      인터넷 뉴스 서비스        웹 서비스: 인터넷을 통해 제공되는 서비스  사용자가 웹 브라우저를 통해 접근하고 이용할 수 있는 다양한 기능을 포함한다.  웹 브라우저: 사용자가 웹 페이지를 요청하고, 그에 대한 응답을 받아서 표시하는 도구이러한 웹 서비스는 웹 브라우저를 통해 사용된다.  HTTP 프로토콜: 웹에서 정보를 주고받기 위한 규약  웹 서비스는 HTTP 프로토콜을 사용하여 데이터를 전송한.클라이언트(사용자)와 서버(웹사이트) 간의 통신을 관리한다.  웹 서비스의 도구:     따라서 웹 서비스는 HTTP 프로토콜을 통해 기능을 수행하며, 사용자는 이를 통해 인터넷에서 원하는 정보나 서비스를 쉽게 이용할 수 있다."
  }
  
]

