


[ { "title" : "Redis란?", "category" : "", "tags" : " ", "url" : "/db/2024/08/06/redis.html", "date" : "August 6, 2024", "excerpt" : "Redis (Remote dictionary server) 란?오픈 소스 인메모리 데이터 구조의 저장소로, 주로 데이터베이스, 캐시, 메시지 브로커로 사용됩니다.빠른 접근 속도와 다양한 데이터 구조를 지원합니다.데이터를 메모리에 저장하여 빠른 접근 속도를 제공합니다. 데이터를 메모리에 저장함면 디스크 I/O 를 줄이고, 높은 성능을 유지할 수 있습니다.키와 값의 구조로 저장되며 비정형 데이터를 저장, 관리합니다.인메모리?특징 인 메모리 ...", "content" : "Redis (Remote dictionary server) 란?오픈 소스 인메모리 데이터 구조의 저장소로, 주로 데이터베이스, 캐시, 메시지 브로커로 사용됩니다.빠른 접근 속도와 다양한 데이터 구조를 지원합니다.데이터를 메모리에 저장하여 빠른 접근 속도를 제공합니다. 데이터를 메모리에 저장함면 디스크 I/O 를 줄이고, 높은 성능을 유지할 수 있습니다.키와 값의 구조로 저장되며 비정형 데이터를 저장, 관리합니다.인메모리?특징 인 메모리 저장소 데이터를 디스크가 아닌 RAM 에 저장하여 빠르게 접근하고 처리하는 방법입니다.빠른 접근 속도를 제공하기 때문에 지연이 적고 응답시간이 빠릅니다.데이터가 서버의 메모리에 유지되기 때문에 서버가 재부팅되거나 종료되면 데이터가 사라질 수 있습니다.이를 보완하기 위해 스냅샷, 로그 등 영속성 옵션을 사용할 수 있습니다. 다양한 데이터 구조문자열(Strings), 리스트(Lists), 집합(Sets), 정렬된 집합(Sorted Sets), 해시(Hashes), 비트맵(Bitmaps), 하이퍼로그로그(HyperLogLogs), 지오스페이셜 인덱스(Geospatial Indexes) 등 다양한 데이터 구조 지원하여,데이터의 저장과 접근을 유연하게 합니다. 영속성기본적으로 인메모리 데이터 저장소이지만, 데이터의 영속성을 보장할 수 있는 옵션을 제공합니다.데이터 스냅샷을 디스크에 저장하거나(RDB), 변경 사항을 로그에 기록하여(AOF) 데이터 복구를 지원합니다. 고급 기능Pub/Sub : 메시지 브로커 기능을 제공하여 메시지 전달 및 구독 시스템을 구현할 수 있습니다.트랜잭션 : 여러 명령어를 원자적으로 실행할 수 있는 기능을 제공합니다.Lua 스크립팅 : Lua 스크립트를 사용하여 서버 측에서 복잡한 작업을 수행할 수 있습니다. 분산 및 클러스터링 지원레디스는 클러스터 모드와 샤딩 기능을 통해 데이터를 분산 저장하고, 대규모 데이터 처리와 고가용성을 지원합니다.데이터를 샤딩하여 여러 노드에 분산 저장합니다. 클러스터링을 통해 고가용성과 수평적 확장을 지원합니다.마스터-슬레이브 복제를 지원하여, 데이터를 여러 슬레이브 노드에 복제합니다. 복제를 통해 읽기 성능을 향상시키고 데이터의 고가용성을 보장합니다. 높은 성능과 확장성단일 노드에서 수백만 개의 요청 처리사용 캐시 자주 조회되는 데이터나 결과를 메모리에 저장하여 데이터베이스의 부하를 줄이고 응답 속도를 빠르게 합니다. 세션 스토리지 웹 애플리케이션에서 사용자 세션 정보를 저장하고 관리합니다. 실시간 데이터 처리 실시간으로 데이터를 처리하고 분석하는 데 사용됩니다. 실시간 채팅 애플리케이션에서 메시지를 처리하거나 실시간 분석 대시보드에서 데이터를 스트리밍합니다. 큐 시스템 작업 큐나 메시지 큐를 구현하여 비동기 작업을 처리합니다. 순위 시스템 정렬된 집합을 사용하여 순위 시스템을 구현하고, 순위 기반의 데이터를 관리합니다." }, { "title" : "CI/CD", "category" : "", "tags" : " ", "url" : "/db/2024/08/06/CI-CD.html", "date" : "August 6, 2024", "excerpt" : "CI/CD 는 코드 변경 사항을 자동으로 빌드, 테스트, 배포하여소프트웨어 개발과 배포 과정을 효율적이고 안정적으로 만드는 자동화 프로세스입니다.CI (Continuous Integration) 란?지속적인 통합이라는 의미로 개발자들이 각자의 작업을 자주 병합하여 통합하는 프로세스 입니다.병합할 때마다 자동화된 빌드와 테스트가 실행됩니다.개발자들이 작업한 코드를 자주 메인 브랜치에 병합하거나, 각 코드 변경이 올바르게 작동하는지 확인할 때...", "content" : "CI/CD 는 코드 변경 사항을 자동으로 빌드, 테스트, 배포하여소프트웨어 개발과 배포 과정을 효율적이고 안정적으로 만드는 자동화 프로세스입니다.CI (Continuous Integration) 란?지속적인 통합이라는 의미로 개발자들이 각자의 작업을 자주 병합하여 통합하는 프로세스 입니다.병합할 때마다 자동화된 빌드와 테스트가 실행됩니다.개발자들이 작업한 코드를 자주 메인 브랜치에 병합하거나, 각 코드 변경이 올바르게 작동하는지 확인할 때 사용합니다.정기적인 통합을 통해 버그를 조기에 발견한고 수정할 수 있으며, 통합 빈도가 높아지면 통합의 복잡성과 충돌이 줄어듭니다.CD (Continuous Delivery/ Deployment) 란?Continuous Delivery지속적인 배포는 코드가 변경될 때마다 자동으로 프로덕션 환경에 배포하는 프로세스입니다.모든 변경 사항이 자동으로 배포되며, 개발자의 개입 없이 자동화된 테스트를 통과하면 바로 배포됩니다.배포를 자동화하여 변경 사항이 가능한 빨리 사용자에겍 전달되도록 하는 것입니다.빈번하게 배포가 이루어지는 상황이나, 자동화된 테스트를 통과하면 바로 배포할 수 있는 경우 사용합니다.변경 사항이 프로덕션 환경에 빠르게 반영되기 때문에 사용자의 피드백을 필요로하고 신속하게 반영해야 하는 경우 사용합니다.모든 변경 사항이 자동으로 배포되기 때문에 엄격한 자동화된 테스트와 모니터링이 필요합니다.시나리오 코드 커밋 CI 서버가 코드를 빌드하고 자동화된 테스트 실행 테스트 통과시 자동으로 프로덕션 환경에 배포 지속적 전달 은 CI 단계에서 통합된 코드를 언제든 프로덕션 환경에 배포될 수 있도록 준비하는 프로세스입니다.코드 변경 사항은 자동화된 테스트를 통과하고, 프로덕션 환경에 배포되기 전에 수동 검토 또는 승인 단계를 거칩니다.따라서 배포 시점에 대한 제어가 가능합니다.항상 배포 가능 상태를 유지하여, 필요한 경우 즉시 배포할 수 있어야 합니다.자동화된 테스트를 통과한 후 프로덕션에 배포할 준비가 되어있지만, 최종 배포는 수동으로 이루어질 수 있습니다.시나리오 코드 커밋 CI 서버가 코드를 빌드하고 자동화된 테스트 실행 테스트 통과시 배포 가능한 상태로 준비 배포 담당자나 승인자가 최종 검토 후 배포 승인 프로덕션 환경에 배포 통합과 배포 시간을 줄임으로서 효율성을 높일 수 있으며 코드의 품질을 높이고 안정성을 유지할 수 있습니다.CI/ CD 종류 Jenkins : 오픈 소스 자동화 서버로, 다양한 플러그인을 통해 CI/CD 파이프라인 구축 가능 CircleCI : 클라우드 기반 CI/CD 서비스 TravisCI : 오픈 소스 프로젝트에 많이 사용되는 클라우드 기반 CI 서비스 GitLab CI : GitLab에 내장된 CI/CD 도구로, GitLab 프로젝트와 통합하여 사용 AWS CodePipeline : AWS 서비스와 통합된 CI/CD 서비스, AWS 환경에서의 배포를 자동화위의 도구들은 코드의 변경 사항을 감지하고, 자동으로 빌드 및 테스트를 수행합니다.성공적으로 테스트를 통과한 코드를 프로덕션 환경에 배포하는 과정을 지원합니다." }, { "title" : "LIKE 와 full-scan", "category" : "", "tags" : " ", "url" : "/db/2024/07/22/mysql-index.html", "date" : "July 22, 2024", "excerpt" : "LIKELIKE 는 SQL에서 문자열 패턴 매칭을 위해서 사용합니다.주로 where절에서 특정 패턴과 일치하는 문자열을 검색하는데 사용할 수 있습니다.하지만 데이터가 많아지는 경우 문제가 생길 수 있습니다.어떤 문제가 생길까??LIKE 연산자는 와일드 카드를 사용하여 패턴 매칭을 합니다.와일드 카드가 패턴의 시작 부분에 위치하면 Mysql의 인덱스를 효과적으로 사용할 수 없습니다.예를 들어 LIKE ‘%123’ 과 같은 패턴으로 사용하는 ...", "content" : "LIKELIKE 는 SQL에서 문자열 패턴 매칭을 위해서 사용합니다.주로 where절에서 특정 패턴과 일치하는 문자열을 검색하는데 사용할 수 있습니다.하지만 데이터가 많아지는 경우 문제가 생길 수 있습니다.어떤 문제가 생길까??LIKE 연산자는 와일드 카드를 사용하여 패턴 매칭을 합니다.와일드 카드가 패턴의 시작 부분에 위치하면 Mysql의 인덱스를 효과적으로 사용할 수 없습니다.예를 들어 LIKE ‘%123’ 과 같은 패턴으로 사용하는 경우 인덱스를 사용할 수 없어 성능이 떨어질 있습니다.왜 LIKE ‘%abc’ 패턴은 인덱스를 사용할 수 없을까?인덱스는 데이터가 정렬된 순서대로 값을 찾을 수 있도록 합니다.인덱스를 사용하여 검색할 때 왼쪽에서 부터 일치하는 값을 찾습니다.예를 들어 ‘abc%’와 같은 패턴은 인덱스를 사용할 수 있으나 ‘%abc’ 의 패턴의 경우 시작점이 명화하지 않기 때문에 인덱스를 사용할 수 없습니다.이와 같은 패턴을 사용하는 경우 패턴 매칭을 위해 모든 데이터를 순차적으로 스캔해야 하기 때문에full table scan이 발생합니다.데이터의 양이 많을수록 성능에 영향을 미치며, I/O 비용이 많이 발생합니다.’=’ 으로 완전일치 검색하는 경우인덱스를 사용하여 검색하는 것을 확인할 수 있다.LIKE를 이용해서 검색하는 경우% 으로 시작하는 문자열을 검색하는 경우 인덱스를 사용하지 않는 것을 확인할 수 있다. %가 위에 있는 문자열을 검색하는 경우 인덱스를 사용하는 것을 확인할 수 있다. 이제 속도 측면에서 확인해보자’=’을 사용한 경우LIKE을 사용한 경우 %를 시작 부분에서 사용하는 경우 %를 마지막 부분에서 사용하는 경우 % 가 앞에 나오는 경우가 속도가 떨어지는 것을 볼 수 있다." }, { "title" : "Transaction 격리수준", "category" : "", "tags" : " ", "url" : "/spring/2024/07/18/transaction-%EA%B2%A9%EB%A6%AC%EC%88%98%EC%A4%80.html", "date" : "July 18, 2024", "excerpt" : "", "content" : "" }, { "title" : "Transactional과 Proxy", "category" : "", "tags" : " ", "url" : "/spring/2024/07/17/transactional-proxy.html", "date" : "July 17, 2024", "excerpt" : "좌석을 선택하고 결제하는 api를 구현하는데 트랜잭션에 대하여 이해가 떨어져서 공부하게 되었다.개념은 익히 들어서 알고 있지만 온전히 내 것으로 만들지는 못했다.트랜잭션?일련의 작업들을 하나로 묶어서 처리하는 단위.트랜잭션이 성공적으로 완료되면 모든 작업이 영구적으로 반영되고, 하나라도 실패하면 모든 작업이 취소됩니다.데이터의 일관성과 결성을 유지하는 중요한 개념입니다.트랜잭션의 개념은 많이 들어서 알고 있었지만 내가 완전하게 이해하기는 ...", "content" : "좌석을 선택하고 결제하는 api를 구현하는데 트랜잭션에 대하여 이해가 떨어져서 공부하게 되었다.개념은 익히 들어서 알고 있지만 온전히 내 것으로 만들지는 못했다.트랜잭션?일련의 작업들을 하나로 묶어서 처리하는 단위.트랜잭션이 성공적으로 완료되면 모든 작업이 영구적으로 반영되고, 하나라도 실패하면 모든 작업이 취소됩니다.데이터의 일관성과 결성을 유지하는 중요한 개념입니다.트랜잭션의 개념은 많이 들어서 알고 있었지만 내가 완전하게 이해하기는 어려웠다.콘서트 티켓 예매를 예로 들어보자상품을 구매하려면 어떻게 해야할까? 상품의 재고를 확인한 후 장바구니에 추가합니다. 상품을 결제합니다. 결제가 성공하면 주문을 생성하고 재고를 업데이트합니다.이 과정에서 트랜잭션을 사용하지 않는다고 하면 어떤 문제가 발생할까?재고가 부족한 상황에서 동시에 여러 사용자가 같은 상품을 구매하려고 하면 재고가 음수가 될 수 있습니다.또한 결제가 성공했지만 주문 생성이 실패하거나 재고 업데이트가 실패하면 데이터의 일관성이 깨질 수 있습니다.그리고 결제에는 성공했지만 재고가 부족한 상황에서 주문생성에 실패하면, 사용자는 돈을 지불했지만 주문이 완료되지 않을 수 있습니다.상품 구매 시스템에서 트랜잭션을 사용하면 여러 단계의 구매 과정을 하나의 단위로 묶어서 처리할 수 있습니다.모든 단계가 성공적으로 완료됙거나, 도중에 실패하는 경우 모든 변경 사항이 롤백되어 데이터의 무결성과 일관성을 보장할 수 있습니다.스프링에서는 @Transactional 어노테이션을 사용하여 트랜잭션을 관리할 수 있습니다.Java@Servicepublic class OrderService { // 코드 생략 @Transactional public void orderProcess(Long productId, int quantity, PaymentInfo paymentInfo) { Product product = productRepository.findById(productId).orElseThrow(() -&amp;gt; new RuntimeException(&quot;Product not found&quot;)); // 재고 확인 if (product.getStock() &amp;lt; quantity) { throw new RuntimeException(&quot;Not enough stock&quot;); } // 결제 처리 paymentService.processPayment(paymentInfo); // 재고 감소 product.setStock(product.getStock() - quantity); productRepository.save(product); // 주문 생성 Order order = new Order(); order.setProduct(product); order.setQuantity(quantity); order.setTotalPrice(product.getPrice() * quantity); orderRepository.save(order); }}클래스나 메서드에 붙여 해당 범위 내 메서드가 트랜잭션이 되도록 보장합니다.직접 객체를 생성할 필요없이 선언만으로 관리가 가능합니다.@Transactional은 어떻게 동작할까?메서드의 실행이 시작될 때 트랜잭션이 시작되고, 메서드가 정상적으로 종료되면 트랜잭션이 커밋되며,예외가 발생하면 트랜잭션이 롤백됩니다. 스프링은 @Transactional 어노테이션이 적용된 빈을 프록시 객체로 감쌉니다. 이 프록시는 실제 빈의 메서드를 호출하기 전에 트랜잭션 관련 로직을 처리합니다. 프록시는 메서드 호출 전에 트랜잭션을 시작합니다. 이 과정에서 트랜잭션 매니저가 트랜잭션 경계를 설정합니다. 실제 메서드가 실행됩니다. 메서드가 정상적으로 종료되면 트랜잭션이 커밋되고, 예외가 발생하면 트랜잭션이 롤백됩니다. 그러면 프록시란 무엇일까?Proxy프록시는 다른 객체의 대리자로서 동작하는 객체로 실제 객체를 감싸서 부가 기능을 제공합니다. 스프링은 주로 AOP를 통해 트랜잭션 관리를 위해 프록시를 사용합니다.프록시의 역할프록시는 실제 객체의 호출 전후에 부가 기능을 추가할 수 있습니다. 예를 들어, 트랜잭션 시작과 종료, 예외 발생 시 롤백 등을 처리합니다. public interface MyService { void performTransaction(); } @Service public class MyServiceImpl implements MyService { @Transactional public void performTransaction() { // 트랜잭션 내에서 수행할 작업 } } // 프록시 객체 생성 및 사용 MyService myService = (MyService) context.getBean(&quot;myService&quot;); myService.performTransaction();프록시 객체는 실제 MyServiceImpl 객체를 감싸서 트랜잭션 관리를 추가합니다. 클라이언트는 프록시 객체를 통해 트랜잭션이 적용된 메서드를 호출합니다.프록시 생성 방식 인터페이스 기반 프록시: 기본적으로 스프링은 JDK 동적 프록시를 사용하여 인터페이스를 구현하는 프록시 객체를 생성합니다. 클래스 기반 프록시 (CGLIB): 만약 빈이 인터페이스를 구현하지 않았다면, 스프링은 CGLIB를 사용하여 클래스 기반 프록시를 생성합니다. 트랜잭션 경계 설정 트랜잭션 시작: 프록시는 메서드 실행 전에 PlatformTransactionManager를 사용하여 트랜잭션을 시작합니다. 트랜잭션 커밋: 메서드가 정상적으로 완료되면 TransactionManager는 트랜잭션을 커밋합니다. 트랜잭션 롤백: 메서드 실행 중에 체크드 예외 이외의 예외(런타임 예외, 오류)가 발생하면 트랜잭션이 롤백됩니다.트랜잭션 속성@Transactional 어노테이션은 다양한 속성을 통해 트랜잭션의 동작 방식을 조정할 수 있습니다. propagation: 트랜잭션 전파 방식 (예: REQUIRED, REQUIRES_NEW 등) isolation: 트랜잭션 격리 수준 (예: READ_COMMITTED, SERIALIZABLE 등) timeout: 트랜잭션이 완료되어야 하는 최대 시간 readOnly: 읽기 전용 트랜잭션 여부 rollbackFor: 롤백할 예외 타입 noRollbackFor: 롤백하지 않을 예외 타입프록시는 @Transactional이 적용된 메서드 호출을 가로채서 트랜잭션 관련 처리를 수행합니다. 이를 통해 개발자는 트랜잭션 관리 로직을 직접 작성하지 않아도 됩니다.프록시는 다음과 같은 방식으로 트랜잭션을 처리합니다. 메서드 호출 가로채기: 클라이언트가 @Transactional이 적용된 메서드를 호출할 때, 프록시가 이 호출을 가로챕니다. 트랜잭션 시작: 프록시는 PlatformTransactionManager를 사용하여 트랜잭션을 시작합니다. 메서드 실행: 실제 메서드를 실행합니다. 트랜잭션 커밋/롤백: 메서드 실행이 성공하면 트랜잭션을 커밋하고, 예외가 발생하면 트랜잭션을 롤백합니다. @Servicepublic class OrderService { @Autowired private OrderRepository orderRepository; @Transactional public void placeOrder(Order order) { // 트랜잭션 시작 orderRepository.save(order); // 추가 로직 // 트랜잭션 커밋 }} 위의 OrderService 클래스에서 placeOrder 메서드는 @Transactional 애노테이션을 사용하여 트랜잭션 경계를 정의하고 있습니다.스프링은 이 클래스의 프록시를 생성하여 placeOrder 메서드 호출을 가로채고 트랜잭션을 관리합니다.프록시가 트랜잭션을 처리하는 과정 프록시 생성: 스프링이 애플리케이션 컨텍스트를 초기화할 때, OrderService 빈에 대한 프록시를 생성합니다. 메서드 호출 가로채기: 클라이언트가 placeOrder 메서드를 호출하면 프록시가 이 호출을 가로챕니다. 트랜잭션 시작: 프록시는 TransactionManager를 사용하여 트랜잭션을 시작합니다. 실제 메서드 실행: 프록시는 실제 placeOrder 메서드를 호출합니다. 트랜잭션 커밋/롤백: 메서드가 정상적으로 종료되면 프록시는 트랜잭션을 커밋하고, 예외가 발생하면 트랜잭션을 롤백합니다.트랜잭션이 하는 일을 프록시가 대신하는 이유 일관성 유지: 트랜잭션은 데이터베이스의 일관성과 무결성을 유지하는 데 중요한 역할을 합니다. 프록시를 사용하면 이러한 트랜잭션 관리 로직을 쉽게 적용할 수 있습니다. 코드 간결화: 트랜잭션 관리를 코드에서 직접 구현하지 않아도 되므로 코드가 간결해집니다. 중복 방지: 동일한 트랜잭션 관리 로직을 여러 곳에서 반복해서 작성할 필요가 없습니다. AOP 지원: 프록시는 스프링 AOP(Aspect-Oriented Programming)를 사용하여 트랜잭션 관리와 같은 횡단 관심사를 쉽게 구현할 수 있게 해줍니다.프록시는 트랜잭션을 투명하게 처리하여 개발자가 비즈니스 로직에만 집중할 수 있게 해줍니다.프록시 없이 트랜잭션을 관리하려면, 트랜잭션 시작, 커밋, 롤백을 수동으로 처리해야 합니다. 이것은 상당히 번거롭고 오류가 발생하기 쉬운 작업입니다.트랜잭션 관리 직접 구현@Servicepublic class OrderService { @Autowired private OrderRepository orderRepository; @Autowired private PlatformTransactionManager transactionManager; public void placeOrder(Order order) { TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition()); try { // 트랜잭션 시작 orderRepository.save(order); // 추가 비즈니스 로직 수행 // 트랜잭션 커밋 transactionManager.commit(status); } catch (Exception ex) { // 예외 발생 시 트랜잭션 롤백 transactionManager.rollback(status); throw ex; // 예외 재발생 } }}프록시 없이 트랜잭션 관리의 문제점 복잡성 증가: 트랜잭션을 시작하고, 커밋하거나 롤백하는 코드가 모든 트랜잭션 메서드에 반복적으로 작성되어야 합니다. 오류 가능성: 트랜잭션 시작, 커밋, 롤백 로직을 수동으로 관리하다 보면 실수로 빠뜨리거나 잘못 구현할 가능성이 높습니다. 비즈니스 로직과 트랜잭션 로직의 혼합: 비즈니스 로직과 트랜잭션 관리 로직이 같은 메서드에 섞여 있어 코드가 지저분해지고 유지보수가 어려워집니다. 재사용성 부족: 트랜잭션 관리 로직을 재사용하기 어렵고, 모든 트랜잭션이 필요한 메서드에서 중복 코드가 발생합니다.프록시를 사용할 때의 장점 코드 간결성: 트랜잭션 관리 로직을 각 메서드에 작성할 필요 없이 @Transactional 애노테이션을 사용하여 트랜잭션 경계를 지정할 수 있습니다. 오류 감소: 스프링이 트랜잭션 관리를 대신 처리하므로, 개발자가 실수로 트랜잭션 관리 로직을 잘못 구현할 가능성이 줄어듭니다. 비즈니스 로직 집중: 트랜잭션 관리 로직이 분리되어 비즈니스 로직에 집중할 수 있습니다. 재사용성 향상: 트랜잭션 관리 로직을 재사용할 수 있고, 코드 중복이 줄어듭니다. @Servicepublic class OrderService { @Autowired private OrderRepository orderRepository; @Transactional public void placeOrder(Order order) { orderRepository.save(order); // 추가 비즈니스 로직 수행 }} 스프링이 프록시를 통해 트랜잭션 시작, 커밋, 롤백을 자동으로 처리하므로 개발자는 비즈니스 로직에만 집중할 수 있습니다.@Transactional 애노테이션을 이용하면 스프링 프레임워크가 프록시를 통해 트랜잭션 관리를 대신해 줍니다. 이를 이해하기 위해서는 스프링의 AOP (Aspect-Oriented Programming) 개념과 프록시 패턴을 이해하는 것이 중요합니다.@Transactional과 프록시의 관계 AOP와 프록시 패턴: 스프링은 AOP를 이용하여 @Transactional 애노테이션을 적용할 때 프록시 패턴을 사용합니다. AOP는 관점 지향 프로그래밍을 의미하며, 코드의 특정 관점에서의 공통된 기능을 분리하여 관리하는 기술입니다. 프록시의 역할: @Transactional 애노테이션이 붙은 메서드가 호출될 때, 스프링 프레임워크는 그 메서드를 호출하기 전후에 추가적인 작업을 수행하기 위해 프록시 객체를 생성합니다. 이 프록시 객체는 원본 객체(서비스 클래스)를 감싸며, 트랜잭션 관리와 같은 공통된 기능을 제공합니다. 트랜잭션 관리: @Transactional 애노테이션이 붙은 메서드에서는 트랜잭션을 시작하고, 메서드 실행을 감싸는 프록시가 트랜잭션을 커밋 또는 롤백합니다. 이 과정에서 데이터베이스 연산의 성공 또는 실패에 따라 트랜잭션을 적절하게 처리합니다. 간편한 설정: 개발자는 @Transactional 애노테이션을 사용하여 간편하게 트랜잭션 경계를 정의할 수 있습니다. 이는 개발자가 직접 트랜잭션을 시작하고, 커밋 또는 롤백하는 코드를 작성하지 않아도 되게 만듭니다. @Servicepublic class OrderService { @Autowired private OrderRepository orderRepository; @Transactional public void placeOrder(Order order) { // 비즈니스 로직 수행 orderRepository.save(order); // 추가적인 데이터베이스 작업 등 } // 다른 트랜잭션 메서드 @Transactional public void cancelOrder(Order order) { order.setStatus(OrderStatus.CANCELED); orderRepository.save(order); // 추가적인 로직 수행 }}이 예시에서 @Transactional 애노테이션이 붙은 placeOrder()와 cancelOrder() 메서드는 스프링 프록시가 관리하는 트랜잭션 범위에서 실행됩니다. 메서드 내의 모든 데이터베이스 연산은 하나의 트랜잭션으로 묶이며, 이 트랜잭션은 메서드 실행 완료 후 자동으로 커밋 또는 롤백됩니다.따라서 @Transactional을 이용하면 개발자는 트랜잭션 관리에 대한 복잡한 코드를 작성하지 않아도 되며, 스프링 프록시가 이를 대신 처리하여 코드의 간결성과 유지보수성을 높여줍니다." }, { "title" : "Transaction", "category" : "", "tags" : " ", "url" : "/spring/2024/07/17/transaction.html", "date" : "July 17, 2024", "excerpt" : "트랜잭션?일련의 작업들을 하나로 묶어서 처리하는 단위.트랜잭션이 성공적으로 완료되면 모든 작업이 영구적으로 반영되고, 하나라도 실패하면 모든 작업이 취소됩니다.데이터의 일관성과 결성을 유지하는 중요한 개념입니다.트랜잭션의 개념은 많이 들어서 알고 있었지만 내가 완전하게 이해하기는 어려웠다.콘서트 티켓 예매를 예로 들어보자상품을 구매하려면 어떻게 해야할까? 상품의 재고를 확인한 후 장바구니에 추가합니다. 상품을 결제합니다. 결제가 성공...", "content" : "트랜잭션?일련의 작업들을 하나로 묶어서 처리하는 단위.트랜잭션이 성공적으로 완료되면 모든 작업이 영구적으로 반영되고, 하나라도 실패하면 모든 작업이 취소됩니다.데이터의 일관성과 결성을 유지하는 중요한 개념입니다.트랜잭션의 개념은 많이 들어서 알고 있었지만 내가 완전하게 이해하기는 어려웠다.콘서트 티켓 예매를 예로 들어보자상품을 구매하려면 어떻게 해야할까? 상품의 재고를 확인한 후 장바구니에 추가합니다. 상품을 결제합니다. 결제가 성공하면 주문을 생성하고 재고를 업데이트합니다.이 과정에서 트랜잭션을 사용하지 않는다고 하면 어떤 문제가 발생할까?재고가 부족한 상황에서 동시에 여러 사용자가 같은 상품을 구매하려고 하면 재고가 음수가 될 수 있습니다.또한 결제가 성공했지만 주문 생성이 실패하거나 재고 업데이트가 실패하면 데이터의 일관성이 깨질 수 있습니다.그리고 결제에는 성공했지만 재고가 부족한 상황에서 주문생성에 실패하면, 사용자는 돈을 지불했지만 주문이 완료되지 않을 수 있습니다.상품 구매 시스템에서 트랜잭션을 사용하면 여러 단계의 구매 과정을 하나의 단위로 묶어서 처리할 수 있습니다.모든 단계가 성공적으로 완료됙거나, 도중에 실패하는 경우 모든 변경 사항이 롤백되어 데이터의 무결성과 일관성을 보장할 수 있습니다.스프링에서는 @Transactional 어노테이션을 사용하여 트랜잭션을 관리할 수 있습니다.@Servicepublic class OrderService { // 코드 생략 @Transactional public void orderProcess(Long productId, int quantity, PaymentInfo paymentInfo) { Product product = productRepository.findById(productId).orElseThrow(() -&amp;gt; new RuntimeException(&quot;Product not found&quot;)); // 재고 확인 if (product.getStock() &amp;lt; quantity) { throw new RuntimeException(&quot;Not enough stock&quot;); } // 결제 처리 paymentService.processPayment(paymentInfo); // 재고 감소 product.setStock(product.getStock() - quantity); productRepository.save(product); // 주문 생성 Order order = new Order(); order.setProduct(product); order.setQuantity(quantity); order.setTotalPrice(product.getPrice() * quantity); orderRepository.save(order); }}클래스나 메서드에 붙여 해당 범위 내 메서드가 트랜잭션이 되도록 보장합니다.직접 객체를 생성할 필요없이 선언만으로 관리가 가능합니다.트랜잭션의 특징 Atomicity 원자성 한 트랜잭션 내의 모든 연산들이 완전히 수행되거나 전혀 수행되지 않습니다. ( All or Nothing ) Consistency 일관성 어떤 트랜잭션이 수행되기 전에 데이터베이스가 일관된 상태를 가졌다면 트랜잭션이 수행된 후에 일관된 상태를 갖습니다. Isolation 격리성 or 고립 여러 트랜잭션이 동시에 실행될 때 각 트랜잭션은 다른 트랜잭션의 영향을 받지않고 독립적으로 실행되어야 합니다. Durability 영속성 성공적으로 완료된 트랜잭션의 결과를 영구적으로 보존해야 합니다. 영속성 컨텍스트(Persistence Context)영속성 컨텍스트는 엔티티(Entity) 객체를 관리하는 환경주로 ORM 프레임워크에서 사용되며, 데이터베이스로부터 엔티티를 읽어올 때 영속성 컨텍스트에 저장하고, 엔티티의 상태 변경을 추적하여 데이터베이스에 동기화하는 기능을 제공합니다. 엔티티의 생명주기영속성 컨텍스트는 엔티티의 생명주기를 관리합니다. 엔티티 객체가 생성되어 영속성 컨텍스트에 저장되면 ‘영속 상태’가 되며, 데이터베이스와 동기화됩니다. 수정된 엔티티는 트랜잭션이 커밋될 때 자동으로 데이터베이스에 반영됩니다. 지연 로딩(Lazy Loading)영속성 컨텍스트는 지연 로딩을 지원하여, 연관된 엔티티 객체를 실제로 사용할 때까지 데이터베이스 조회를 지연시킬 수 있습니다. 이는 성능 최적화에 도움을 줍니다. 동일성 보장영속성 컨텍스트는 동일한 엔티티 식별자를 가진 객체에 대해 같은 인스턴스를 반환하여 동일성을 보장합니다. 트랜잭션과 영속성 컨텍스트의 상호작용트랜잭션과 영속성 컨텍스트는 서로 긴밀하게 연결되어 있습니다 트랜잭션 범위: 트랜잭션은 데이터베이스 작업을 논리적 단위로 묶어주며, 트랜잭션 내에서 영속성 컨텍스트는 엔티티의 상태 변경을 추적합니다. 트랜잭션 커밋 시 영속성 컨텍스트는 데이터베이스에 변경 사항을 반영하고, 롤백 시 변경 사항을 취소합니다. 트랜잭션의 격리 수준: 트랜잭션 격리 수준(Transaction Isolation Level)은 여러 트랜잭션이 동시에 실행될 때의 동작을 제어합니다. 높은 격리 수준일수록 동시성 문제를 줄일 수 있지만, 성능 저하가 발생할 수 있습니다. 플러시(Flushing): 영속성 컨텍스트의 변경 사항을 데이터베이스에 동기화하는 작업을 플러시라고 합니다. 일반적으로 트랜잭션 커밋 시 자동으로 플러시가 발생합니다. 결론적으로 영속성 컨텍스트는 엔티티의 생명주기를 관리하고, 트랜잭션은 데이터베이스 작업을 단위로 묶어 원자적인 실행을 보장합니다. 이 두 개념을 잘 이해하고 활용함으로써 데이터베이스 작업의 일관성과 동시성을 유지할 수 있습니다.트랜잭션의 활용 데이터베이스 상태 변경 예를 들어, 사용자가 새로운 주문을 생성할 때, 주문 내역을 데이터베이스에 반영하는 작업은 하나의 트랜잭션으로 묶입니다.이 경우 주문 생성, 결제 정보 저장, 재고 조정 등 여러 개의 데이터베이스 작업이 하나의 원자적인 작업 단위로 묶이게 됩니다. 예외 처리와 롤백 트랜잭션은 예외 상황이 발생했을 때 데이터베이스 상태를 롤백하여 이전 상태로 복원하는 데 사용됩니다. 예를 들어, 주문 생성 중 결제 과정에서 오류가 발생하면, 주문과 관련된 모든 변경 사항을 취소하고 이전 상태로 돌아가게 됩니다. 동시성 제어 트랜잭션은 동시에 여러 사용자가 동일한 데이터에 접근할 때 발생할 수 있는 문제를 방지합니다. 여러 사용자가 동시에 주문을 생성하려고 할 때, 트랜잭션을 이용하여 충돌을 방지하고 일관성 있는 데이터 처리를 보장할 수 있습니다. 복잡한 비즈니스 로직 처리 복잡한 비즈니스 로직을 처리할 때도 트랜잭션을 활용할 수 있습니다. 여러 개의 서비스 호출이나 데이터 조작 작업을 하나의 트랜잭션으로 묶어서 실행하면, 데이터 일관성을 유지하면서 원자적으로 처리할 수 있습니다. 권한 관리 및 보안 트랜잭션을 이용하여 데이터베이스 접근 권한을 관리할 수 있습니다. 트랜잭션을 시작할 때 권한을 확인하고, 트랜잭션이 종료될 때 권한을 제거하는 등의 작업을 통해 보안을 강화할 수 있습니다." }, { "title" : "JWT", "category" : "", "tags" : " ", "url" : "/spring/2024/07/02/spring-jwt.html", "date" : "July 2, 2024", "excerpt" : "프로젝트 중에 JWT를 사용하여서잘 몰라서.. 공부하고자이전에는?JWT가 보급되기 전에는 주로 세션 기반 인증 방식이 사용되었습니다.세션의 Stateful 로 상태를 유지하는 것이 특징입니다.세션 기반 인증은 사용자의 정보를 서버에 저장하고, 클라이언트는 세션ID를 통해인증 상태를 유지하는 방식입니다.세션은 서버 메모리나 데이터베이스에 저장되어야하기 때문에 서버 측에서 상태를 유지해야합니다.매 요청맏마 서버와 통신해야하기 때문에 부하가 초...", "content" : "프로젝트 중에 JWT를 사용하여서잘 몰라서.. 공부하고자이전에는?JWT가 보급되기 전에는 주로 세션 기반 인증 방식이 사용되었습니다.세션의 Stateful 로 상태를 유지하는 것이 특징입니다.세션 기반 인증은 사용자의 정보를 서버에 저장하고, 클라이언트는 세션ID를 통해인증 상태를 유지하는 방식입니다.세션은 서버 메모리나 데이터베이스에 저장되어야하기 때문에 서버 측에서 상태를 유지해야합니다.매 요청맏마 서버와 통신해야하기 때문에 부하가 초래됩니다.이러한 문제로 등장한 것이 JWT로 Stateless 인 것이 특징입니다.JWTJSON Web Token의 약자로 정보를 JSON 형태로 클라이언트에 저장하고 서버는 해당 토큰을 검증하여인증을 처리하는 방식입니다.토큰 안에 미리 인증에 필요한 정보를 넣어두며 매 요청마다 서버와 통신할 필요가 없습니다.이로 인해 서버 부하와 같은 문제를 해결할 수 있습니다.구조헤더, 페이로드, 서명 세 부분으로 구성됩니다.헤더 부분은 알고리즘 방식과 토큰의 타입을 지합니다. 서명 생성을 위해 어떤 알고리즘을 사용할지 식별하는 부분입니다.페이로드는 클레임이라고 불리는 정보 조각을 포함합니다.클레임은 토큰에 추가할 정보를 의미하며 사용자 ID, 권한 정보등이 포함될 수 있습니다.하지만 디코딩을 통해 들어있는 정보를 확이할 수 있기 때문에 민감한 정보는 포함하지 않는 것이 좋습니다.서명은 토큰을 인코딩하거나 유효성 검증을 위해서 사용되는 부분으로,헤더와 페이로드를 합친 후 비밀키를 사용하여 생성합니다.서버는 클라이언트로부터 받은 토큰을 검증하기 위해 서명 부분을 해싱알고리즘과 비밀키로 다시 생성하고이를 클라이언트가 전달한 서명과 비교합니다.일치라면 인증이 유요한 것으로 판단합니다." }, { "title" : "영속성 컨텍스", "category" : "", "tags" : " ", "url" : "/jpa/2024/07/01/jpa-%EC%98%81%EC%86%8D%EC%84%B1%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8.html", "date" : "July 1, 2024", "excerpt" : "영속성 컨텍스트JPA 는 영속성 컨텍스트라는 작은 메모리 공간을 가지고 있습니다. 이 영속성 컨텍스트는 엔티티 매니저의 생명주기와 일치하며, 엔티티를 관리하고 데이터베이스와 통신을 처리합니다.하나의 영속성 컨텍스트는 트랜잭션 단위로 관리되며, 엔티티의 상태를 추적하고 엔티티를 데이터베이스와 동기화합니다.@Service@Transactionalpublic class UserService { @PersistenceContext ...", "content" : "영속성 컨텍스트JPA 는 영속성 컨텍스트라는 작은 메모리 공간을 가지고 있습니다. 이 영속성 컨텍스트는 엔티티 매니저의 생명주기와 일치하며, 엔티티를 관리하고 데이터베이스와 통신을 처리합니다.하나의 영속성 컨텍스트는 트랜잭션 단위로 관리되며, 엔티티의 상태를 추적하고 엔티티를 데이터베이스와 동기화합니다.@Service@Transactionalpublic class UserService { @PersistenceContext private EntityManager em; public void saveUser(User user) { // 엔티티를 영속성 컨텍스트에 저장 em.persist(user); } public User findUser(Long userId) { // 1차 캐시에서 엔티티를 조회 (데이터베이스 조회 필요 없음)em.find(User.class, user.getId()) 는 JPA 에서 제공하는 메서드로 데이터베이스에 접근하여 return em.find(User.class, userId); 지정된 엔티티 클래스와 키를 기반으로 엔티티를 조회합니다. } public void updateUser(User user) { // 엔티티의 상태 변경 (Dirty Checking) User managedUser = em.find(User.class, user.getId()); managedUser.setUsername(user.getUsername()); managedUser.setEmail(user.getEmail()); // 트랜잭션이 커밋될 때 데이터베이스에 자동으로 반영됨이로써 반복적으로 조죄할 때 데이터베이스에 대한 추가적인 조회를 피할 수 있으며 성능이 향상됩니다. } public void deleteUser(Long userId) { // 1캐시는 영속성 컨텍스트의 생명주기에 의존하기 때문에 트랜잭션이 종료되면 1차 캐시도 함께 종료됩니다. // 엔티티를 영속성 컨텍스트에서 제거 // 이후에 같은 엔티티를 조회할 경 다시 데이터베이스에서 조회해야 합니다. User user = em.find(User.class, userId); em.remove(user); // 트랜잭션이 커밋될 때 데이터베이스에서 삭제됨 }}1차 캐시영속성 컨텍스트의 일부로 JVM 메모리에 위치합니다. 따라서 데이터베이스에 접근하는 것보다 훨씬 빠른 접근이 가능합니다다.엔티티의 식별자를 키로 사용하여 엔티티를 저장합니다. 이 식별자를 사용하여 빠르게 엔티티를 조회할 수 있습니다. public User findUser(Long userId) { // 1차 캐시에서 엔티티를 조회 (데이터베이스 조회 필요 없음) return em.find(User.class, userId); }em.find(User.class, user.getId()) 메서드는 데이터베이스에서 엔티티를 조회하고 이 엔티티를 영속성 컨텍스트에 저장합니다.이때 저장된 엔티티는 1차 캐시에 저장됩니다.이후 동일한 엔티티를 다시 조회하는 경우 영속성 컨텍스트에서 먼저 조회하여 데이터베이스에 접근하지 않고 1차 캐시에 저장된 엔티티를 반환합니다.1차 캐시를 통해 동일한 엔티티를 반복적으로 조회할 때 데이터베이스에 대한 추가적인 조회를 피할 수 있습니다영속성 컨텍스트는 트랜잭션 범위 내에서 관리되기 때문 동일한 엔티티에 대해 일관된 상태를 유지할 수 있습니다.하지만 컨텍스트의 생명주기에 의존하기 때문에 트랜잭션이 종료되면 1차 캐시도 함께 종료됩니다.따라섯 이후에 같은 엔티티를 조회할 때는 다시 데이터베이스에서 조회해야 합니다.1차 캐시는 멤모리에 저장되기 때문에 많은 수의 엔티티를 동시에 처리하 할 때 메모리 사용에 주의해야 합니다.지연 로딩연관된 엔티티나 컬렉션을 실제로 사용할 때까지 데이터베이스에서 로딩하지 않고 필요한 시점에 로딩하는 기능입니다.지연로딩은 FetchType.LAZY로 설정하며, 실제 엔티티가 필요한 시점에 데이터베이스에서 조회합니다.반면에 즉시로딩(FetchType.EAGER)은 엔티티를 조회할 때 연관된 엔티티들을 즉시 한번에 조회합니다. 이는 성능 저하를 초래할 수 있으므로 주의해서 사용해야 합니다.@Entity@Table(name = &quot;orders&quot;)public class Order { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = &quot;order_id&quot;) private Long id; @ManyToOne(fetch = LAZY) @JoinColumn(name = &quot;user_id&quot;) private User user;}단순한 관계나 적은 데이터 양을 다룰 때는 즉시로딩을 사용하는 것이 좋습니다.대규모 데이터를 다루거나 성능 최적화가 필요한 경우에는 지연로딩을 고려해야 합니다.기본적으로는 지연로딩을 사용하고, 성능 문제나 데이터 접근 패턴에 따라 필요할 때 즉시로딩으로 변경하는 것이 바람직합니다.변경 감지트랜잭션 내에서 엔티티의 상태 변경을 감지하여 자동으로 데이터베이스와 동기화합니다.트랜잭션 내에서 엔티티의 수정이 이루어져야 변경 감지가 동작합니다. 트랜잭션이 커밋될 때 변경 사항이 데이터베이스에 반영됩니다.트랜잭션이 커밋되기 전까지는 데이터베이스에 변경 사항이 반영되지 않습니다. @PersistenceContext private EntityManager entityManager; public void updateProduct(Long productId, String newName, double newPrice) { // 엔티티 조회 Product product = entityManager.find(Product.class, productId); // 엔티티 수정 product.setName(newName); product.setPrice(newPrice); // 변경 감지가 발생하여 자동으로 데이터베이스에 반영됨 }}별도의 save 메서드 호출이 필요하지 않습니다.트랜잭션 범위영속성 컨텍스트는 트랜잭션 범위 내에서 엔티티를 관리하므로, 트랜잭션이 커밋되거나 롤백되기 전까엔티티의 변경 사항을 추적하고 커밋할 때 최종적으로 데이터베이스에 반영합니다." }, { "title" : "JPA란", "category" : "", "tags" : " ", "url" : "/jpa/2024/07/01/jpa-jpa.html", "date" : "July 1, 2024", "excerpt" : "JPA란자바 애플리케이션에서 관계형 데이터베이스를 관리하고 조작할 수 있도록 도와주는 표준 API 입니다.자바 객체를 데이터베이스 테이블에 매핑하여 객체지향 프로그래밍과 관계형 데이터베이스 간의 불일치를 해결합니다.JPA를 사용하면 SQL쿼리를 직접 작성하지 않고도 데이터베이스 작업을 수행할 수 있습니다.등장 배경??JPA 가 등장하기 전에는 객체지향 프로그래밍 언어와 관계형 데이터베이스 간의 매핑을 직접 구현했습니다.주로 JDBC를 이용...", "content" : "JPA란자바 애플리케이션에서 관계형 데이터베이스를 관리하고 조작할 수 있도록 도와주는 표준 API 입니다.자바 객체를 데이터베이스 테이블에 매핑하여 객체지향 프로그래밍과 관계형 데이터베이스 간의 불일치를 해결합니다.JPA를 사용하면 SQL쿼리를 직접 작성하지 않고도 데이터베이스 작업을 수행할 수 있습니다.등장 배경??JPA 가 등장하기 전에는 객체지향 프로그래밍 언어와 관계형 데이터베이스 간의 매핑을 직접 구현했습니다.주로 JDBC를 이용하여 데이터베이스와 연결하여 쿼리를 실행하고 결과를 가져왔습니다.Connection 으로 데이터베이스를 연결을 설정하고 관리하였습니다. 개발자는 쿼리를 직접 작성하여 데이터베이스에 보낸 후반환된 결과를 받아 자바 객체로 매핑하는 작업을 수동을 해주어야 했습니다.추가적으로 SQL 실행 중 발생할 수 있는 예외를 처리해야합니다.SQL을 사용하여 데이터베이스와 상호작용해야 했으며, 반복적인 코드작성이 일어났습니다.쿼리를 직접 다루기 때문에 발생할 수 있는 오류가 많고 유지보수가 어렵다는 문제가 있습니다.객체 지향 언어의 클래스와 객체를 관계형 데이터베이스의 테이블과 매핑하는 과정에서 일관성을 유지하기 어려웠습니다.따라서 이러한 문제를 해결하기 위해 나온 것이 ORM 입니다.ORM 프레임워크객체와 데이터베이스 매핑 자동화 ORM 프레임워크는 객체와 데이터베이스 간의 매핑을 자동으로 처리해줍니다.CRUD 작업의 객체지향적 처리 CRUD(Create, Read, Update, Delete) 작업을 객체지향적으로 처리할 수 있습니다.표준화된 인터페이스 제공 JPA와 같은 ORM 프레임워크는 표준화된 인터페이스를 제공하여, 다양한 데이터베이스와도 쉽게 연동할 수 있습니다.성능 최적화 및 편의성 제공 내부적으로 캐싱, 지연로딩 등의 기법을 사용하여 성능을 최적화하고, 개발자가 데이터베이스와의 상호작용을 편리하게 처리할 수 있습니다.###JPA는 개발자가 객체지향적으로 데이터를 다루면서 이것을 관계형 데이터베이스에 저장하고 조회할 수 있도록 도와줍니다.객체와 테이블 간의 매핑 규칙을 정의하고 이를 바탕으로 JPA 구현체가 SQL을 생성하여 데이터베이스와 상호작용합니다.ORM을 통해 객체와 데이터베이스 간의 매핑을 자동화하기 때문에 개발자는 객체지향적인 코드를 집중적으로 작성할 수 있습니다.데이터베이스 스키마의 변경이 발생해도 JPA가 자동으로 SQL을 생성하여 매핑을 처리해주기 때문에 유지보수가 편리합니다.개념 엔티티 영속성을 가진 객체 데이터베이스 테이블에 매핑되는 자바 클래스로 각 인스턴스는 테이블의 행을 나타냅니다. 엔티티 매니저 엔티티의 생명주기를 관리하고 데이터베이스와 상호작용합니다. 엔티티를 저장, 삭제, 조회하는 등의 작업을 수행합니다. 영속성 컨텍스트 엔티티 객체를 관리하는 메모리상의 공간입니다. 데이터베이스와의 상호작용을 중재하는 역할을 합니다. JPQL 엔티티 객체를 대상으로 쿼리를 작성합니다. 영속성(Persistence)이란? 데이터를 일시적인 저장소가 아닌 영구적인 저장소에 저장하는 것을 의미합니다.영속성을 통해 프로그램이 종료되더라도 데이터가 손실되지 않고 유지될 수 있으며 시스템의 오류나 충돌이 발생했을 때데이터를 복구할 수 있습니다.여러 프로그램이나 사용자가 동일한 데이터를 사용할 수 있으며 트랜잭션을 통해 데이터의 일관성을 유지할 수 있습니다.ex) 데이터를 데이터베이스에 저장하여 프로그램이 종료되더라도 데이터가 유지되도록 합니다.데이터를 파일에 저장하여 프로그램이 종료되더라도 데이터가 파일에 남아있도록 합니다.JPA에서의 “영속성”은 엔티티 객체의 생명 주기 중 하나로, 엔티티 객체가 영속성컨텍스트에 의해 관리되는 상태를 말합니다.엔티티 객체를 영속성 컨텍스트에 저장하고 이를 통해 데이터베이스와의 지속적인 동기화를 관리합니다.자바에서는 JPA를 사용하여 영속성을 관리할 수 있습니다.이를 통해 객체를 데이터베이스 테이블에 매핑하고 CRUD 작업을 쉽게 수행할 수 있습니다.영속성 컨텍스트엔티티 매니저가 관리하는 엔티티 객체들의 집합입니다.영속성 컨텍스트는 엔티티 객체를 캐시로 관리하여 데이터베이스와의 상호작용을 최적화하고 객체 상태의 변경을추적합니다.엔티티 객체를 메모리에 저장하고 관리하며 이를 통해 엔티티 객체가 데이터베이스와 동기화됩니다.엔티티 객체를 메모리에 캐싱하여, 동일한 트랜잭션 내에서 반복적인 데이터베이스 접근을 줄입니다. (1차 캐시)엔티티의 상태 변화를 감지하여 트랜잭션이 커밋될 때 변경된 내용을 데이터베이스에 반영합니다.딩 (변경감지)필요한 시점에 데이터베이스에서 데이터를 로드하는 기능을 제공합니다. (지연로딩)엔티티 객체의 생명 주기 비영속 (Transient)엔티티 객체가 영속성 컨텍스트에 의해 관릳되지 않은 상태입니다.데이터베이스와 연관이 없습니다. 영속 (Persistent)엔티티 객체가 영속성 컨텍스트에 의해 관리되는 상태입니다.엔티티 매니저를 통해 데이터베이스에 저장됩니다. 준영속 (Detached)한 번 영속상태 였지만 현재는 영속성 컨텍스트에 의해 관리되지 않는 상태입니다.영속성 컨텍스트가 닫히거나 detch() 메서드를 호출하여 엔티티가 분리될 때 발생합니다. 삭제 (Removed)엔티티 객체가 영속성 컨텍스트에 의해 삭제된 상태입니다.데이터베이스에서 해당 엔티티가 삭제됩니다. 주요 어노테이션 @Entity : 클래스가 엔티티임을 선언합니다. @Table : 엔티티와 매핑되는 데이터베이스 테이블을 지정합니다. @Id : 엔티티의 기본키를 지정합니다. @GeneratedValue : 기본키 값을 자동으로 생성하는 전략을 지정합니다. @Column : 엔티티 필드와 매핑되는 데이터베이스 컬럼을 지정합니다.@Entity@Table(name = &quot;user&quot;)@NoArgsConstructor(access = AccessLevel.PROTECTED)@Getter @Setterpublic class User{ @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = &quot;user_id&quot;, updatable = false) private Long id; private String email; private String password; private String phone; }JPA는 자동으로 엔티티와 데이터베이스 테이블 간의 매핑을 처리해주기때문에 개발자는 별도의 SQL 쿼리를 작성할 필요가 없습니다." }, { "title" : "Blocking vs Non-Blocking", "category" : "", "tags" : " ", "url" : "/java/2024/07/01/java-%EB%B8%94%EB%A1%9C%ED%82%B9-%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9.html", "date" : "July 1, 2024", "excerpt" : "Blocking vs Non-BlockingBlocking IO는 작업이 완료될 때까지 스레드가 대기하는 방식Non-Blocking IO는 작업이 완료되지 않더라도 대기하지 않고 다른 작업을 처리하는 방식Blocking IO에서의 문제점입출력 작업이 완료될때 까지 다른 스레드가 대기하여야한다. 따라서 멀티 스레드 환경에서 대기시간이 오래걸릴수있다. 많은 클라이언트의 요청을 동시에 처리할 수 없으며 블록상태가 발생할 수 있습니다.Non-Bl...", "content" : "Blocking vs Non-BlockingBlocking IO는 작업이 완료될 때까지 스레드가 대기하는 방식Non-Blocking IO는 작업이 완료되지 않더라도 대기하지 않고 다른 작업을 처리하는 방식Blocking IO에서의 문제점입출력 작업이 완료될때 까지 다른 스레드가 대기하여야한다. 따라서 멀티 스레드 환경에서 대기시간이 오래걸릴수있다. 많은 클라이언트의 요청을 동시에 처리할 수 없으며 블록상태가 발생할 수 있습니다.Non-Blocking IO에서의 장단점작업이 완료될 때까지 기다리지 않고 해당 작업을 수행하는 동안 다른 작업을 수행할 수 있는 방식입니다.요청한 작업이 완료되면, 결과를 처리할 수 있도록 콜백함수 등을 통해 알림을 받습니다.병렬적으로 여러 작업을 처리할 수 있는 장점이 있습니다.대기시간이 최소화되어 시스템이 더 효율적을 자원을 이용할 수 있으며 여러 작업을 동시에 처리하기 때문에 응답성이 향상됩니다.비교적 적은 스레드로 많은 요청을 처리할 수 있어 스케일링에 유리합니다.IO 작업이 많이 발생하는 환경에 효과적입니다.하지만 비동기 프로그래밍으로 동기적 프로그래밍보다 복잡하며 콜백 지옥과 같은 문제가 발생할 수 있습니다.또한 이벤트를 기반으로 동작하기 때문에 실행 흐름을 추적하거나 디버깅이 어렵습니다.비동기 작업이 많아질수록 메모리 사용량이 증가할 수 있습니다.주로 다수의 클라이언트 요청을 비동기로 처리할 때 사용됩니다. 또한 웹 서버에서 여러 요청을 동시에 처리하고IO 작업이 완료될 때까지 기다리지 않고 다른 요청을 처리하는데 유용하게 사용됩니다.대규모 데이터베이스나 파일 처리에서 비동기 IO는 시스템의 처리량을 향상 시키는데 기여할 수 있습니다.구현방법에는 가장 기본적인 방법으로 자바스크립트에서 콜백함수를 사용하거나 promise 를 사용하는 방법이 있습니다.또한 자바의 NIO 와 같은 라이브러리를 사용하여 블로킹 IO 를 비동기적으로 처리할 수 있습니다." }, { "title" : "Db Index", "category" : "", "tags" : " ", "url" : "/2024/06/27/db-index.html", "date" : "June 27, 2024", "excerpt" : "layout: posttitle: index와 B-tree, Hash인덱스categories: DB–인덱스란 데이터베이스 테이블에서 데이터를 빠르게 검색할 수 있도록 도와주는 데이터 구조인덱스는 테이블 내의 1개 또는 여러 개의 컬럼을 이용하여 생성할 수 있습니다. 인덱스는데이터베이스의 테이블과 별도로 저장되며, 인덱스를 저장하기 위한 추가적인 저장공간이 필요합니다.테이블의 특정 컬럼에 대해서 인덱스를 생성하면, 해당 컬럼의 데이터를 정...", "content" : "layout: posttitle: index와 B-tree, Hash인덱스categories: DB–인덱스란 데이터베이스 테이블에서 데이터를 빠르게 검색할 수 있도록 도와주는 데이터 구조인덱스는 테이블 내의 1개 또는 여러 개의 컬럼을 이용하여 생성할 수 있습니다. 인덱스는데이터베이스의 테이블과 별도로 저장되며, 인덱스를 저장하기 위한 추가적인 저장공간이 필요합니다.테이블의 특정 컬럼에 대해서 인덱스를 생성하면, 해당 컬럼의 데이터를 정렬한 후 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장됩니다. 키 값 : 인덱스가 참조하는 컬럼 값 포인터/ 참조 : 실제 데이터가 저장된 테이블의 행을 가리키는 포인터해당 컬럼의 값을 키로 사용하기 때문에 테이블 전체를 스캔하지 않고 원하는 데이터를 찾을 수 있습니다.이는 검색속도를 향상시킵니다 정렬된 상태로 저장이 되기 때문에 정렬된 데이터에 빠르게 접근할 수 있습니다.장점인덱스를 이용하면 특정 키 값을 빠르게 검색할 수 있습니다. 이는 인덱스가 정렬된 상태이기 때문입니다.정렬된 데이터 구조이기 때문에 비트리 인덱스와 같은 알고리즘을 사용하여 데이터를 빠르게 찾을 수 있습니다.인덱스를 사용하면 전체 테이블을 스캔하지 않고 원하는 데이터를 찾을 수 있습니다. 따라서 더 빠른 응답시간을 제공할 수 있습니다.정렬되지 않은 데이터의 경우 특정 키 값을 찾기 위해 데이터를 순차적으로 스캔해야 하기 때문에 선형 검색을 수행해야 합니다.따라서 데이터가 많아질수록 검색 속도가 느려질 수 있습니다.단점인덱스는 추가적인 저장공간을 필요로 하기 때문에 데이터베이스의 크기가 증가할 수 있습니다.또한 데이터의 삽입, 삭제, 수정시 인덱스도 리밸런싱되어야 하기 때문에 오버헤드가 발생할 수 있습니다.키를 기준으로 검색하는 경우 빠른 속도를 기대할 수 있으나 다른 컬럼을 기준으로 검색하는 경우 해당 컬럼이 인덱스로 지정되지 않은 경우성능 저하가 발생할 수 있습니다. 따러서 자주 사용되는 검색 조건에 대해 적절한 인덱스를 생성하고 관리하는 것이 중요합니다.언제 사용해야 할까?특정 컬럼이 자주 검색 조건으로 사용될 때 인덱스를 생성하는 것이 효율적입니다.예로 주문 번호, 날짜, 사용자 ID 등 검색이 빈번한 컬럼은 인덱스를 통해 검색 성능을 향상시킬 수 있습니다.정렬과 같은 그룹화 작업이 자주 일어나는 컬럼에 사용하는 것도 쿼리의 성능을 향상시킬 수 있습니다.조인 연산에 사용되는 컬럼에 인덱스를 생성하거나, 범위 검색이나 부분 일치 검색을 수행할 때 사용할 수 있습니다.하지만 너무 많은 인덱스를 생성하는 것은 성능 저하를 일으킬 수 있기때문에 자주 사용되는 검색 조건 등 꼭 필요한 인덱스만 생성하는 것이 좋습니다.인덱스의 구조B-tree 인덱스Balanced tree의 약자로 균형잡힌 트리 구조입니다. 모든 리프노드가 동일한 깊이에 위치합니다.노드의 삽입 및 삭제 시 특정 규칙에 맞게 재정렬 되어 밸런스를 유지하는 트리입니다.각 노드는 여러 키와 포인터를 가지고 있으며 키는 정렬된 상태로 저장됩니다.검색시 루트 노드부터 시작하여 비교를 통해 적절한 리프노드에 도달합니다.해시 인덱스해시 함수를 사용하여 키 값을 해시코드로 변환하고 이를 기반으로 데이터를 저장하고 검색하는 구조입니다.키와 값의 구조로 되어있기 때문에 해시 인덱스의는 탐색 시간이 O(1) 로 탐색 시간이 빠릅니다.정확하게 일치하는 검색에 대해서는 빠르지만 범위를 검색하는 경우에는 적합하지 않습니다.해시 인덱스는 데이터가 해시코드에 따라 분산되어 있습니다. 그래서 데이터를 정렬된 순서로 접근하는 것이 어렵습니다.데이터들이 정렬되어 있지 않기 때문에 특정 기준보다 크거나 작은 값, 부등호 연에 대해 검색이 적합하지 않습니다." }, { "title" : "Configuration어노테이션", "category" : "", "tags" : " ", "url" : "/annotation/2024/06/27/annotation-configuration.html", "date" : "June 27, 2024", "excerpt" : "@Configuration 설정 클랫스를 정의할 때 사용합니다.해당 클래스가 스프링 Bean 구성 클래스임을 나타내며, 스프링 컨테이너에 의해 빈으로 관리됩니다.", "content" : "@Configuration 설정 클랫스를 정의할 때 사용합니다.해당 클래스가 스프링 Bean 구성 클래스임을 나타내며, 스프링 컨테이너에 의해 빈으로 관리됩니다." }, { "title" : "어노테이션 RequiredArgsConstructor, AllArgsConstructor", "category" : "", "tags" : " ", "url" : "/spring/2024/06/27/annotation-allargsconstructor-requiredargsconstructor.html", "date" : "June 27, 2024", "excerpt" : "프로젝트 진행 중 계속해서 의존성 주입 문제가 생겼다.도대체 뭘까..@Service@RequiredArgsConstructorpublic class SmsSenderService { private final SmsCertification smsCertification; @Value(&amp;quot;${coolsms.apikey}&amp;quot;) private String apiKey; @Value(&amp;quot;${coolsms....", "content" : "프로젝트 진행 중 계속해서 의존성 주입 문제가 생겼다.도대체 뭘까..@Service@RequiredArgsConstructorpublic class SmsSenderService { private final SmsCertification smsCertification; @Value(&quot;${coolsms.apikey}&quot;) private String apiKey; @Value(&quot;${coolsms.apisecret}&quot;) private String apiSecret; @Value(&quot;${coolsms.fromnumber}&quot;) private String fromNumber; // 코드 생략}@RequiredArgsConstructor 와 @AllArgsConstructor 를 알아보자둘 다 Lombok 에서 제공하는 어노테이션으로 코드를 간결하게 작성할 수 있도록 도와주는 역할을 합니다.@RequiredArgsConstructor클래스의 final로 선언된 필드나 @NonNull 로 표시된 필드를 기반으로 생성자를 생성합니다.생성자는 이러한 필드들을 매개변수로 받아 초기화합니다.@RequiredArgsConstructorpublic class User { private final String name; // final로 선언 private final int age; /* 아래와 같은 생성자가 자동으로 생성됩니다. public User(String name, int age) { this.name = name; this.age = age; } */} 즉, 초기화되지 않은 final 필드의 생성자를 생성합니다.@AllArgsConstructor모든 필드를 기반으로 생성자를 생성합니다.final로 선언되지 않은 필드도 포함하여 모든 필드를 매개변수로 받는 생성자를 생성합니다.@AllArgsConstructorpublic class User { private String name; private int age; /* 아래와 같은 생성자가 자동으로 생성됩니다. public User(String name, int age) { this.name = name; this.age = age; } */}@Value 와 @RequiredArgsConstructor?@Value 이 뭘까?final 로 선언한 필드에 @Value를 사용하면?스프링이 빈을 생성할 때 해당 필드를 초기화할 수 없기 때문에 에러가 발생합니다.@Value 을 사용할 때는 생성자 인젝션을 사용하지 않기 때문에 @RequiredArgsConstructor 를 사용하여생성자를 자동을 생성할 수 없습니다.@Value 와 @AllArgsConstructor?스프링은 빈을 초기화 할 때 @Value 어노테이션을 사용하여 외부 프로퍼티 파일에서 값을 주입할 수 있습니다.이것은 생성자 인젝션을 지원하지 않습니다.따라서 @AllArgsConstructor을 사용할 때는 스프링이 @Value 어노테이션을 통해 초기화할 수 없는 필드에 대해서는 생성자를 자동으로 생성하지 않습니다. 이로 인해 apiKey, apiSecret, fromNumber 필드는 @Value 어노테이션을 통해 초기화할 수 없어서 에러가 발생합니다." }, { "title" : "인코딩", "category" : "", "tags" : " ", "url" : "/java/2024/06/26/java-encoding.html", "date" : "June 26, 2024", "excerpt" : "인코딩?데이터를 특정 형식으로 변환하여 저장하거나 전송할 수 있도록 하는 과정입니다.인코딩을 통해 데이터를 안전하게 전송할 수 있으며 보다 효과적으로 저장할 수 있습니다.서로 다른 시스템이나 프로그램 간의 데이터 호환성을 유지하며 데이터 전송 중 보안을 강화하고 민감한 정보를 보호합니다.또한 데이터를 압축하여 저장 공간을 절약하거나, 특정 형식에 맞추어 데이터를 저장합니다.데이터를 더 빠르고 안정적으로 전송할 수 있도록 최적화합니다.Mys...", "content" : "인코딩?데이터를 특정 형식으로 변환하여 저장하거나 전송할 수 있도록 하는 과정입니다.인코딩을 통해 데이터를 안전하게 전송할 수 있으며 보다 효과적으로 저장할 수 있습니다.서로 다른 시스템이나 프로그램 간의 데이터 호환성을 유지하며 데이터 전송 중 보안을 강화하고 민감한 정보를 보호합니다.또한 데이터를 압축하여 저장 공간을 절약하거나, 특정 형식에 맞추어 데이터를 저장합니다.데이터를 더 빠르고 안정적으로 전송할 수 있도록 최적화합니다.Mysql 에서 HTML 인코딩HTML 데이터를 데이터베이스에 저장할 때 특수문자나 HTML 태그로 인해 문제가 발생할 수 있습니다.이러한 문제를 해결하기 위해 데이터 인코딩을 사용할 수 있습니다.Mysql에서 HTML 태그를 인코딩하여 데이터베이스에 저장하려면 HTML 특수 문자를 이스케이프 처리하여야 합니다.이를 통해 태그를 안전하게 저장하고 XSS 공격을 방지하는데 도움이 됩니다.방법Apache Commons Text 라이브러리 설정Apache Commons Text 라이브러리 추가 필요PreparedStatementHTML 데이터를 그래도 저장한다.Base64 인코딩바이너리 데이터를 ASCII 문자열로 변환하는 방법입니다. 이를 통해 바이너리 텍스트 형식의 데이터베이스나텍스트 전송 프로토콜을 통해 안전하게 전송하고 저장할 수 있습니다.HTML 데이터를 Base64로 인코딩하면, 특수 문자를 포함하는 HTML 태그를 안전하게 데이터베이스에 저장할 수 있습니다.그 외 종류ASCII 인코딩 (American Standard Code for Information Interchange)가장 오래된 인코딩 방식 중 하나로, 7비트로 표현되며 영문 알파벳, 숫자, 특수 문자를 포함하며, 확장된 형태 8비트의 ASCII도 있습니다.UTF-8 (Unicode Transformation Format - 8-bit)현재 가장 일반적으로 사용되는 문자 인코딩 방식으로 유니코드(Unicode)를 위한 다양한 문자를 다룰 수 있습니다. 가변 길이 문자 인코딩 방식으로, ASCII와 호환되며 다국적 텍스트 처리에 적합합니다.UTF-16유니코드 문자를 16비트 단위로 인코딩하는 방식입니다. 주로 한글, 한자 등 다국적 문자 처리에 사용됩니다.UTF-32유니코드 문자를 32비트 단위로 인코딩하는 방식입니다. 모든 문자를 고정 길이로 표현할 수 있으며, UTF-16과 UTF-8에 비해 메모리 공간을 많이 사용합니다.URL 인코딩 (Percent Encoding)URL에 사용할 수 없는 문자나 특수 문자를 ‘%XX’와 같은 형태로 인코딩하는 방식입니다.HTML 엔티티 인코딩HTML 문서에서 사용할 수 없는 문자나 특수 기호를 대체 문자열(&amp;amp;, &amp;lt;, &amp;gt;, 등)로 변환하는 방식입니다." }, { "title" : "해시", "category" : "", "tags" : " ", "url" : "/java/2024/06/21/algorithm-hash.html", "date" : "June 21, 2024", "excerpt" : "Mysql?데이터를 특정 형식으로 변환하여 저장하거나 전송할 수 있도록 하는 과정입니다.인코딩을 통해 데이터를 안전하게 전송할 수 있으며 보다 효과적으로 저장할 수 있습니다.서로 다른 시스템이나 프로그램 간의 데이터 호환성을 유지하며 데이터 전송 중 보안을 강화하고 민감한 정보를 보호합니다.또한 데이터를 압축하여 저장 공간을 절약하거나, 특정 형식에 맞추어 데이터를 저장합니다.데이터를 더 빠르고 안정적으로 전송할 수 있도록 최적화합니다.H...", "content" : "Mysql?데이터를 특정 형식으로 변환하여 저장하거나 전송할 수 있도록 하는 과정입니다.인코딩을 통해 데이터를 안전하게 전송할 수 있으며 보다 효과적으로 저장할 수 있습니다.서로 다른 시스템이나 프로그램 간의 데이터 호환성을 유지하며 데이터 전송 중 보안을 강화하고 민감한 정보를 보호합니다.또한 데이터를 압축하여 저장 공간을 절약하거나, 특정 형식에 맞추어 데이터를 저장합니다.데이터를 더 빠르고 안정적으로 전송할 수 있도록 최적화합니다.HikariCPHTML 데이터를 데이터베이스에 저장할 때 특수문자나 HTML 태그로 인해 문제가 발생할 수 있습니다.이러한 문제를 해결하기 위해 데이터 인코딩을 사용할 수 있습니다.Mysql에서 HTML 태그를 인코딩하여 데이터베이스에 저장하려면 HTML 특수 문자를 이스케이프 처리하여야 합니다.이를 통해 태그를 안전하게 저장하고 XSS 공격을 방지하는데 도움이 됩니다.방법Apache Commons Text 라이브러리 설정Apache Commons Text 라이브러리 추가 필PreparedStatementHTML 데이터를 그래도 저장한다.Base64 인코딩바이너리 데이터를 ASCII 문자열로 변환하는 방법입니다. 이를 통해 바이너리 텍스트 형식의 데이터베이스나텍스트 전송 프로토콜을 통해 안전하게 전송하고 저장할 수 있습니다.HTML 데이터를 Base64로 인코딩하면, 특수 문자를 포함하는 HTML 태그를 안전하게 데이터베이스에 저장할 수 있습니다.종류ASCII 인코딩 (American Standard Code for Information Interchange)가장 오래된 인코딩 방식 중 하나로, 7비트로 표현되며 영문 알파벳, 숫자, 특수 문자를 포함하며, 확장된 형태 8비트의 ASCII도 있습니다.UTF-8 (Unicode Transformation Format - 8-bit)현재 가장 일반적으로 사용되는 문자 인코딩 방식으로 유니코드(Unicode)를 위한 다양한 문자를 다룰 수 있습니다. 가변 길이 문자 인코딩 방식으로, ASCII와 호환되며 다국적 텍스트 처리에 적합합니다.UTF-16유니코드 문자를 16비트 단위로 인코딩하는 방식입니다. 주로 한글, 한자 등 다국적 문자 처리에 사용됩니다.UTF-32유니코드 문자를 32비트 단위로 인코딩하는 방식입니다. 모든 문자를 고정 길이로 표현할 수 있으며, UTF-16과 UTF-8에 비해 메모리 공간을 많이 사용합니다.Base64 인코딩이진 데이터를 ASCII 문자로만 이루어진 문자열로 변환하는 인코딩 방식입니다. 주로 이메일 첨부 파일 전송이나 데이터 URL 스키마와 같은 컨텍스트에서 사용됩니다.URL 인코딩 (Percent Encoding)URL에 사용할 수 없는 문자나 특수 문자를 ‘%XX’와 같은 형태로 인코딩하는 방식입니다.HTML 엔티티 인코딩HTML 문서에서 사용할 수 없는 문자나 특수 기호를 대체 문자열(&amp;amp;, &amp;lt;, &amp;gt;, 등)로 변환하는 방식입니다." }, { "title" : "StringBuffer StringBuilder", "category" : "", "tags" : " ", "url" : "/java/2024/06/18/java-StringBuffer-StringBuilder.html", "date" : "June 18, 2024", "excerpt" : "StringBuffer StringBuilderStringBuffer StringBuilder 둘 다 가변 길이 문자열을 처리하는 데 사용되는 클래스입니다.StringBuffer 동기화가 적용되어 있으며 thread-safe 로 멀티 스레드 환경에서 StringBuffer 인스턴스에 접근할 때 안전하게 사용할 수 있습니다.여러 스레드가 동시에 문자열을 수정하는 경우에 사용됩니다. 예를 들어 멀티 스레드 환경에서 공유 문자열을 처리하는 경...", "content" : "StringBuffer StringBuilderStringBuffer StringBuilder 둘 다 가변 길이 문자열을 처리하는 데 사용되는 클래스입니다.StringBuffer 동기화가 적용되어 있으며 thread-safe 로 멀티 스레드 환경에서 StringBuffer 인스턴스에 접근할 때 안전하게 사용할 수 있습니다.여러 스레드가 동시에 문자열을 수정하는 경우에 사용됩니다. 예를 들어 멀티 스레드 환경에서 공유 문자열을 처리하는 경우 사용됩니다.StringBuilder 은 내부적으로 동기화가 적용되어 있지 않습니다. 따라서 멀티 스레드 환경에서 안전하지 않습니다.단일 스레드 환경에서 문자열을 수정할 때 사용되며 성능이 중요하고 thread-safe 가 필요하지 않은 경우 사용하는 것이 좋습니다.StringBuilder 가 단일 스레드 환경에서 사용하기 적합한 이유StringBuilder 가 단일 스레드 환경에 적합한 이유는 동기화로 인한 오버헤드가 없기 때문입니다. 따라서 단일 스레드환경에서 빠릅니다.동기화는 메서드 호출시마다 추가적인 검사와 잠금 획득 및 해제를 필요로 하여 성능을 저하시킬 수 있습니다.따라서 동기화가 없는 StringBuilder 이 더 빠르게 실행됩니다.동기화가 앖는 만큼 StringBuilder 의 메서드들은 더 간단하고 경량화되어 빠른 실행이 가능하며 StringBuffer 보다 더 적은 자원을 소모합니다.불변성불변성은 객체가 한 번 생성된 후로 상태를 바꿀 수 없는 성질을 말합니다.그렇기 때문에 여러 스레드가 동시에 읽어도 안전하며 상태가 변하지 않기 때문에 동기화 처리가 없어도 여러 스레드가 동시에 접근할 수 있습니다.또한 불변 객체는 변경될 일이 없기 때문에 캐싱하여 재사용할 수 있습니다. 따라서 메모리의 사용을 높일 수 있습니다.StringBuilder 는 가변 객체로 불변 객체와 반대되는 개념입니다.StringBuidler 은 내부 상태를 변경할 수 있으며 그 과정에서 내부 배열을 재사용합니다. 새로운 객체를 생성하지 않고 문자열 수정이 가능합니다.따라서 성능 측면에서는 유리할 수 있지만 멀티 스레드 환경에서는 주의해야 합니다.StringBuilder를 멀티 스레드 환경에서 안전하게 사용하려면StringBuilder 를 멀티스레드 환경에서 안전하게 사용하기 위해서는 외부에서 동기화 처리를 해주어야 합니다.동기화 처리 방법에는 synchronized 와 Lock 있습니다.내부적으로 동기화 처리가 되어있는 StringBuffer을 사용하는 방법도 있습니다.ReentrantLock과 Synchronized?ReentrantLock과 Synchronized 둘 다 자바에서 동기화를 제공하지만 사용법과 기능 측면에서 차이가 있습니다.synchronized 키워드는 블록이나 메서드 수준에서 동기화가 가능합니다. 자동으로 락을 획득하고 해제합니다.사용이 간단하며 가독성이 좋습니다.ReentrantLock 클랫스는 명시적으로 락을 획득하고 해제하는 작업이 필요합니다.타임아웃을 지정할 수 있으며 Condition 객체를 사용하여 보다 세밀한 스레드 제어가 가능하며 공정성을 설정할 수 있습니다.복잡한 동기화 요구에 적합하지만 코드가 복잡해질 수 있습니다.ReentrantLock의 await 와 signalReentrantLock 클래스는 Condition 객체를 통 스레드 간에 특정한 조건을 기다리고 신호를 보내는 기능을 제공합니다.해await() 메서드는 현재 스레드를 일시적으로 멈추고 다른 스레드가 signal() 또는 signalAll() 을 호출할 때까지 기다립니다.singnal() 메서드는 하나의 대기 중인 스레드에게만 신호를 보냅니다. 일반적으로 상태가변경되어 하나의 스레만 깨어나야할 때 사용됩니다.공유 자원의 상태가 특정 조건을 만족할 때까지 대기하도록 스레드를 설정하는 경우 사용됩니다.StringBuffer의 동기화StringBuffer 은 내부적으로 동기화 처리가 되어있습니다.따라서 멀티 스레드 환경에서 안전하게 사용이 가능합니다.하지만 모든 메서드 동기화 되며 단일 스레드 환경에서도 불필요한 락을 걸고 해제하기 때문에 오버헤드가 발생할 수 있습니다.복잡 스레드 상호작용 과정에서 데드락이 발생할 수 있으며 synchronized 는 블록과 메서드 수준에서만 사용이 가능하기 때문에 세밀한 제어가 어려울 수 있습니다." }, { "title" : "Statement와 PreparedStatement", "category" : "", "tags" : " ", "url" : "/java/2024/06/13/java-PreparedStatement.html", "date" : "June 13, 2024", "excerpt" : "Statement와 PreparedStatement의 차이Statement와 PreparedStatement는 둘 다 JDBC API 에서 제공하는 인터페이스입니다.데이터베이스에서 쿼리를 실행할 때 쿼리를 효율적으로 실행하기 위해서 쿼리 캐싱이라는 작업을 시행합니다.쿼리 캐싱은 쿼리를 파싱하고 최적의 실행계획을 세운 뒤 실행하는 과정입니다.Statement는 쿼리를 실행할 때마다 매번 쿼리를 파싱하고 실행계획을 세우는 과정을 반복하게됩니다...", "content" : "Statement와 PreparedStatement의 차이Statement와 PreparedStatement는 둘 다 JDBC API 에서 제공하는 인터페이스입니다.데이터베이스에서 쿼리를 실행할 때 쿼리를 효율적으로 실행하기 위해서 쿼리 캐싱이라는 작업을 시행합니다.쿼리 캐싱은 쿼리를 파싱하고 최적의 실행계획을 세운 뒤 실행하는 과정입니다.Statement는 쿼리를 실행할 때마다 매번 쿼리를 파싱하고 실행계획을 세우는 과정을 반복하게됩니다.PreparedStatement는 한 번 쿼리가 실행된 후에는 실행계획을 따로 세우지 않고 이전의 실행계획에 파라미터만 변경하여 쿼리를 날립니다.고따라서 처음 실행된 실행계획을 재사용함으로써 성능상에서 좋습니다.보안 측면에서는 Statement는 입력값을 실제 쿼리에 문자열의 형태로 이어 붙입니다.만약 패스워드를 검색하는 쿼리가 있다고 가정을 했을 때, 유저가 패스워드 값을 입력한 후 이어서 세미콜론을 붙이고새로운 select * from User; 쿼리를 작성하면 노출되면 안되는 데이터들이 노출될 위험이 있습니다.따라서 SQL injection 문제가 발생할 위험이 있습니다.PreparedStatement는 입력값을 파라미터로 넘깁니다. 파라미터로 넘어가는 부분을 ? 로 표시하여 바인딩해서 처리합니다.PreparedStatement를 사용할 때 ?(플레이스 홀)를 사용하면, 사용자 입력값이 쿼리에 직접 삽입되지 않고JDBC 드라이버가 자동으로 매개변수 값을 이스케이프 처리합니다.위와 같은 방식(“; select * from User;”)으로 값을 넘기게 되면 SQL injection을 했을 때 문법 에러가 발생하게 됩니다.이렇게 쿼리와 입력 값을 분리해서 처리하기 때문에 입력값은 쿼리의 데이터로만 사용되며 쿼리 구문으로 해석되지 않습니다.이는 SQL 인젝션 공격을 방지하는 데 매우 효과적입니다.PreparedStatement를 사용할 때 주의해야 하는 부분주의사항으로는 PreparedStatement 는 AutoCloseable 를 확장하고 있기 때문에 사용 후에는 리소스를 닫아주어야 합니다.또한 실행 전에 컴파일되기 때문에 sql 문법 오류가 생기는 경우 컴파일 시점에 예외가 발생합니다.PreparedStatement를 사용시 발생할 수 있는 성능 이슈캐싱을 이용하기 때문에 동일한 쿼리를 여러 번 실행할 때 성능을 최적화할 수 있습니다.하지만 Mysql의 경우 좀 다릅니다.쿼리는 정상적으로 오류없이 동작 하지만 내부적으로 캐싱하는 동작을 하지않습니다. 따라서 캐싱을 하기위해서는useServerPrepStmts 와 cachePrepStmts 옵션을 설정하여야 캐싱을 활용할 수 있습니다.또한 매개변수 바인딩시 적절한 데이터 타입(setString, setInt)을 사용하여 성능을 최적화할 수 있으며대랑의 데이터 처리시 addBatch 와 executeBatch 메서드를 사용하여 배치 처리함으로써 성능을 높일 수 있습니다.동일한 Sql 템플릿을 재사용하기 때문에 컴파일 비용을 줄이고 성능을 최적화합니다.SQL Injection 공격을 예방하는 방법SQL injection 공격을 막기 위해서는 매개변수를 이용해 쿼리에 값을 넣어야합니다.PreparedStatement를 사용하면 드라이버가 자동으로 매개변수 값을 이스케이프 처리하여 SQL Injection 공격을 방지합니다.PreparedStatement에서 Batch 처리를 사용하는 경우 장점과 주의할 점Batch의 장점은 대량의 데이터를 한 번에 처리할 수 있습니다.이로써 네트워크 비용을 줄이고 연산 횟수를 감소시킴으로써 성능을 향상시킬 수 있습니다.또한 여러 SQL 문을 하나의 트랜잭션으로 묶어서 실행하기 때문에 데이터의 일관성이 유지됩니다.주의해야할 부분은 대량의 데이터를 처리하기 때문에 메모리 부족 현상이 발생할 수 있다는 것입니다.따라서 적절한 배치 크기를 설정해야합니다.executeBatch() 는 쿼리의 실행 결과를 반환하지 않기 때문에 각 쿼리의 행 수 등의 정보를 확인하려면 추가적인 처리가 필요합니다." }, { "title" : "try-catch와 try-with-resources", "category" : "", "tags" : " ", "url" : "/java/2024/06/10/java-try-catch-%EC%99%80-try-with-resources.html", "date" : "June 10, 2024", "excerpt" : "try-catch-finallytry-catch-finally 문은 많이 들어보았을 것이다.try-catch-finally 문은 자바7 이전에 나온 예외 처리 구문으로 모든 객체를 포함할 수 있다.사횽 후 반납을 해주어야 하는 자원들은 Closeable 인터페이스를 구현하고 있으며 사용 후 close 메서드를 직접 호출하여 반납해야 한다.자원 반납이 이루어지지 않는 경우 메모리 누수가 생길 수 있으며 다른 프로세스, 스레드에 영향을 줄 수...", "content" : "try-catch-finallytry-catch-finally 문은 많이 들어보았을 것이다.try-catch-finally 문은 자바7 이전에 나온 예외 처리 구문으로 모든 객체를 포함할 수 있다.사횽 후 반납을 해주어야 하는 자원들은 Closeable 인터페이스를 구현하고 있으며 사용 후 close 메서드를 직접 호출하여 반납해야 한다.자원 반납이 이루어지지 않는 경우 메모리 누수가 생길 수 있으며 다른 프로세스, 스레드에 영향을 줄 수 있습니다. 따라서 finally 블록 내에서 자원을 해제하도록 해야합니다.자원을 반납하는 추가적인 코드가 필요하며 실수나 에러로 자원을 반납하지 못하는 경우가 생길 수 있습니다.이러한 문제를 해결하기 위해 자바 7 부터 자원을 자동으로 반납해주는 try-with-resources 문법이 도입되었습니다.try-with-resources ?try-with-resources 는 Java7 부터 도입된 자원 관리를 위한 구문입니다.AutoClosable 인터페이스를 구현하고 있는 자원을 사용 후 자동으로 반납해주는 기능을 제공합니다.이를 사용함으로써 가독성이 좋아지고 예외 발생 시 자원이 안전하게 해제될 수 있습니다.구조try (/*자원 초기화*/) { // 자원을 사용하는 코드} catch (예외 타입 변수) { // 예외 처리 코드}주의할 점은 AutoCloseable 인터페이스를 구현한 객체만이 try 블록내에서 리소스로 사용될 수 있다는 것입니다. 주로 파일, 소켓, 데이터베이스 연결 등에 사용됩니다.Connection.javaCloseable과 AutoCloseable의 관계기존의 Closeable 에 부모 인터페이스 AutoCloseable 를 추가한 형태입니다.Closeable은 AutoCloseable을 확장한 하위 인터페이스입니다. 따라서 Closeable은 AutoCloseable이 제공하는 모든 기능을 포함합니다. 이러한 구조로 기존에 구현된 자원 클래스 모두 try-with-resources 를 사용할 수 있습니다.정리 try-catch 문에서는 예외가 발생할 수 있는 모든 코드가 포함될 수 있으며, 특정 객체 타입에 제한되지 않습니다. try-with-resources 문에서는 AutoCloseable 를 구현한 객체만을 사용할 수 있으며, 구문을 사용하면 리소스 누수를 방지할 수 있어 자원 관리에 매우 유용합니다." }, { "title" : "static", "category" : "", "tags" : " ", "url" : "/java/2024/06/10/java-static.html", "date" : "June 10, 2024", "excerpt" : "static 변수변수나 메서드를 정의할때 사용하는 키워드로, 프로그램의 시작과 동시에 메모리에 로드되며 모든 인스턴스가 공유할 수 있는 변수입니다.모든 객체마다 존재하는 인스턴스 변수와는 다르게 클래스 당 한 개만 존재합니다.인스턴스 변수는 객체마다 개별적인 값을 갖지만 정적 변수는 모든 객체가 동일한 값을 공유합니다.클래스에 종속되어 있으며 객체의 생성과는 무관하게 클래스가 로드될 때 딱 한 번 메모리에 할당됩니다.동일한 데이터를 여러 ...", "content" : "static 변수변수나 메서드를 정의할때 사용하는 키워드로, 프로그램의 시작과 동시에 메모리에 로드되며 모든 인스턴스가 공유할 수 있는 변수입니다.모든 객체마다 존재하는 인스턴스 변수와는 다르게 클래스 당 한 개만 존재합니다.인스턴스 변수는 객체마다 개별적인 값을 갖지만 정적 변수는 모든 객체가 동일한 값을 공유합니다.클래스에 종속되어 있으며 객체의 생성과는 무관하게 클래스가 로드될 때 딱 한 번 메모리에 할당됩니다.동일한 데이터를 여러 인스턴스에 저장할 필요가 없기 때문에 메모리 사용의 중복을 줄일 수 있습니다.JVM의 클래스 영역(Method Area, Metaspace)에 저장됩니다.Static 변수는 클래스가 처음 로드될 때 한 번만 초기화되며, 프로그램 종료 시까지 유지되기 때문에 메모리 할당과 해제에 따른 오버헤드를 줄여줍니다.정적 메서드클래스 수준에서 호출할 수 있는 메서드입니다.해당 클래스의 모든 객체들에 의해서 공유되는 메서드로 객체를 생성하지 않고 클래스 이름으로 직접 호출 합니다또한 정적 메서드는 정적 변수만 사용할 수 있다.그리고 정적 메서드는 특정 객체에 속해있지 않기 때문에 this 키워드를 사용할 수 없는 특징이 있습니다.정적 메서드는 클래스 레벨에서 정의되므로, 메서드 호출 시 객체의 타입이 아닌 클래스의 타입에 따라 호출이 결정됩니다.또한 정적 메서드는 오버라이딩 되지 않습니다.일반적으로 Math 함수와 같이 유틸리티 함수나 독립적인 작업을 수행하는 메서드에서 사용됩니다.static으로 인한 메모리 낭비static는 클래스로드 시점부터 메모리에 로듣됩니다. 따라서 큰 객체를 저장하는 경우 해당 객체가 사용되지 않을 때도 메모리를 차지하게 됩니다.이로 인해 메모리 낭비가 발생할 수 있습니다.static 주의 사항모든 인스턴스에서 공유되기 때문에 여러 스레드에서 동시에 접근할 수 있습니다.동시성 문제가 발생할 수 있기 때문에 스레듣 간에 동기화를 보장하기 위한 추가적인 처리가 필요합니다.이렇게 되면 코드의 의존성이 증가하고 클래스 간의 결합도가 높아질 수 있습니다.Static 변수는 프로그램 종료 시까지 메모리에 유지되기때문에 불필요한 Static 변수 사용은 메모리 사용량을 증가시킬 수 있습니다.Static 변수는 상태를 공유하기 때문에 단위 테스트 시 테스트 간 의존성이 생길 수 있습니다. 따라서 Static 변수의 상태를 테스트 전후에 초기화하거나 가능한 한 사용을 자제해야 합니다.동시성 문제 해결 방법동시성 문제를 해결하는 방법으로는 동기화와 불변성이 있습니다.동기화는 여러 스레드가 동시에 스태틱 변수를 읽고 쓰는 것을 방지하기 위해 사용합니다.방법에는 synchronized 키워드를 사용해서 임계영역을 설정하는 방법이 있습니다. 이렇게 되면 한 번에 하나의 스레드만임계영역에 접근할 수 있게됩니다.불변성불변성은 스태틱 변수를 변경할 수 없도록 만드는 것입니다.. 변수를 final 로 선언하고 불변 객체를 할당합니다.이렇게 되면 동시에 여러 스레드가 해당 변수를 읽을 수는 있지만 변경할 수는 없게됩니다.의존성 주입을 통한 테스트 가능성을 확보하는 방법외부에서 의존 객체를 주입 받아 사용하는 방법이 있습니다.외부 의존성을 mock 객체로 대체 하여 테스트 케이스를 작성할 수 있습니다.static 변수의 사용을 최소화하기 위해 고려해야 할 것의존성 주입을 통하여 외부에서 필요한 객체를 주입 받도록 설계하는 방법이 있습니다.이를 통해 클래스 간의 결합도를 낮추고 유연한 테스트 가능한 코드를 작성할 수 있다또한 하나의 인스턴스를 생성하여 사용하는 싱글톤 패턴을 사용하는 방법입니다. 이를 통해 static 변수 사용을 최소화하고필요한 경우에만 인스턴스를 생성하여 메모리를 절약할 수 있습니다.그리고 스프링과 같은 의존성 주입 프레임워크를 사용하여 의존 관계를 관리하고 필요한 객체를 주입 받는 방법이 있다" }, { "title" : "JDBC과 커넥션", "category" : "", "tags" : " ", "url" : "/java/2024/06/10/java-JDBC.html", "date" : "June 10, 2024", "excerpt" : "JDBCJava Database Connectivity 으로 자바 애플리케이션과 데이터베이스 사이의 통신을가능하게 하는 API 입니다.특징 Java 언어 기반으로 개발되어 있기 때문에 플랫폼에 독립적입니다. Java 언어가 실행될 수 있는 모든 플랫폼엣서동일한 방식으로 데이터베이스를 접속하고 관리할 수 있음을 의미합니다. 데이터베이스에 접속하기 위한 절차를 단순화할 수 있습니다.데이터베이스 연결, 쿼리 실행, 결과 처...", "content" : "JDBCJava Database Connectivity 으로 자바 애플리케이션과 데이터베이스 사이의 통신을가능하게 하는 API 입니다.특징 Java 언어 기반으로 개발되어 있기 때문에 플랫폼에 독립적입니다. Java 언어가 실행될 수 있는 모든 플랫폼엣서동일한 방식으로 데이터베이스를 접속하고 관리할 수 있음을 의미합니다. 데이터베이스에 접속하기 위한 절차를 단순화할 수 있습니다.데이터베이스 연결, 쿼리 실행, 결과 처리의 과정을 통합적으로 지원합니다. 다양한 데이터베이스 관리시스템(DBMS)와 호환됩니다. SQL을 사용해서 데이터베이스와 상호작용합니다. 트랜잭션을 지원하여 데이터베이스 작업의 일관성을 유지할 수 있으며하나의 트랜잭션으로 묶어 실행하거나 롤백할 수 있습니다. 커넥션 풀데이터 베이스를 연결하려면 네트워크 연결, 인증, 권한 확인 등여러 단계를 거쳐야 하기 때문에 상당히 많은 리소스를 소모합니다.이러한 문제를 해결하기 위해 커넥션 풀이 사용됩니다.커넥션 풀은 미리 일정 수의 연결을 생성해두고 필요할 때마다 연결을 재사용하는 방식입니다.이를 통해서 연결을 생성하는데 드는 비용을 절감ㅁ하고 애플리케이션의 성능을 향상시킬 수 있습니다.매번 데이터 베이스 연결을 생성하는 것에는 많은 시간과 리소스를 소모하기 때문에 고성능을 요구하는 애플리케이션에서는커넥션 풀의 사용이 필수적입니다.동작프로그램이 시작하는 시점에서 연결이 미리 생성이 됩니다. 이 연겯을 풀에 저장해두고 연결이 필요할 때마다커넥션 풀에 미리 생성해둔 연결을 가져와서 사용합니다.사용이 끝난 연결은 다시 풀에 반환되어 재사용됩니다.이 과정에서 데이터베이스 연결의 생성과 소멸이 최소화되기 때문에 비용을 절감할 수 있으며 재사용하기 때문에 효율적입니다.풀의 크기가 너무 작은 경우 사용 가능한 연결이 부족해져 성능 저하가 발생할 수 있으며 반대로 풀의 크기가 너무 큰 경우불필요하게 많은 리소스를 소모하게 됩니다." }, { "title" : "JDBC구현", "category" : "", "tags" : " ", "url" : "/java/2024/06/10/java-JDBC-%EA%B5%AC%ED%98%84.html", "date" : "June 10, 2024", "excerpt" : "JDBCManager JDBC를 사용해 Mysql 데이터베이스와의 연결을 관리하는 매니저 클래스Mysql 데이터베이슷 접속에 필요한 정보(사용자이름, 암호, URL) 를 상수로 정의 private static final String USERNAME = &amp;quot;root&amp;quot;; // 데이터베이스 사용자 이름 private static final String PASSWORD = &amp;quot;XXXXXXXX&amp;quot;; /...", "content" : "JDBCManager JDBC를 사용해 Mysql 데이터베이스와의 연결을 관리하는 매니저 클래스Mysql 데이터베이슷 접속에 필요한 정보(사용자이름, 암호, URL) 를 상수로 정의 private static final String USERNAME = &quot;root&quot;; // 데이터베이스 사용자 이름 private static final String PASSWORD = &quot;XXXXXXXX&quot;; // 데이터베이스 암호 private static final String URL = &quot;jdbc:mysql://localhost/XXX?useSSL=false&quot;; JDBC URL: localhost에 설치된 MySQL 서버의 XXX데이터베이스에 접속 useSSL=false : SSL 을 사용하지 않음드 이외 추가 접속 옵션 설클래스가 로드될 때 JDBC 드라이버 로드static { // 클래스가 로드될때 드라이버가 항상 로드되도록 보장하기 위해 정적으로 설정함(필수X) try { // Mysql JDBC 드라이버 클래스 로드 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); } catch (ClassNotFoundException e) { e.printStackTrace(); throw new RuntimeException(&quot;Failed to load JDBC driver&quot;); }}데이터베이스 연결 public static Connection getConnection() throws SQLException { return DriverManager.getConnection(URL, USERNAME, PASSWORD); } getConnection() 메서드 : 데이터베이스 연결을 생성하고 반환 DriverManager.getConnection(URL, USERNAME, PASSWORD)접속정보를 이용해 데이터베이스 연결 요청을 하고 이를 Connection 객체로 반환합니다.JdbcManager.java 전체코드연결을 했으니까 이제 SQL 쿼리를 실행하는 Java 코드 보겠습니다.예시로 주문을 insert 하는 쿼리입니다.insertOrder메서드public class ItemDao { public int insertOrder(String itemId, int quantity, Order order) { String sql = &quot;INSERT INTO orders (order_id, item_id, stock_count) VALUES (?, ?, ?)&quot;; try (Connection conn = JdbcManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) { // Order 객체에서 필요한 정보를 가져와서 SQL 문에 설정합니다. // 주문 insert pstmt.setString(1, order.getOrderId()); pstmt.setString(2, itemId); pstmt.setInt(3, quantity); int count = pstmt.executeUpdate(); // 코드 생략 } catch (SQLException e) { e.printStackTrace(); // 예외 처리 및 롤백 로직이 필요할 수 있음 } return 0; }} 쿼리문 작성 : String sql = “~~~”?은 PreparedStatement의 매개변수 위치 지정자입니다. Connection conn = JdbcManager.getConnection(); JdbcManager 클래스의 getConnection() 메서드를 사용하여 데이터베이스와 연결합니다. PreparedStatement pstPreparedStatement pstmt = conn.prepareStatement(sql)mt = conn.prepareStatement(sql)준비된 문장을 사용하여 SQL 쿼리를 실행할 PreparedStatement 객체를 생성합니다. pstmt.setString(1, order.getOrderId());Sql 쿼리의 첫 번째 매개변수에 값을 바인딩합니다. pstmt.executeUpdate()sql 쿼리를 실행하고 데이터베이스에 데이터를 삽입합니다. executeUpdate()와 executeQuery()하나 기억할 점은 각각 데이터 조작 및 조회 작업에 맞게 sql문 실행 메서드를 사용해야 합니다.executeUpdate() 메서드는 insert, update, delete 와 같은 DML 쿼리를 실행할 때 사용됩니다.반환값으로 영향을 받은 레코드, 행의 개수를 반환합니다.executeQuery() 메서드는 select 쿼리와 같이 데이터베이스 에서 데이터를 조회할 때 사용합니다.ResultSet 객체를 반환하며, ResultSet 는 쿼리에 대한 결과 집합을 나타냅니다.?하지만 이런 형식으로 select, insert, update 메서드를 구현한다며?커넥션을 획득하고, 매개변수를 매핑하고, 쿼리를 실행하는 동작들이 중복될 것이다.중복이 너무 많아~~~중복을 없애보자!!public abstract class BaseDao&amp;lt;T&amp;gt; { public &amp;lt;T&amp;gt; T execute(String sql, ResultSetHandler&amp;lt;T&amp;gt; handler, Object...params) { try (Connection conn = JdbcManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) { for (int i=0; i&amp;lt;params.length; i++) { pstmt.setObject(i+1, params[i]); } ResultSet rs = pstmt.executeQuery(); return handler.handle(rs); } catch (SQLException e) { e.printStackTrace(); } return null; }}제네릭 타입 T를 받는 추상 클래스로 다양한 유형의 데이터를 처리할 수 있다. execute() 는 제네릭 메서드로 데이터베이스 쿼리를 실행하고 그 결과를 처리기 위한 메서드이다. sql : 실행할 쿼리문입니다. handler : ResultSet 을 처리할 ResultSetHandler 인터페이스 구현체입니다. params : 쿼리에 바인딩할 매개변수입니다. 사용 예시public class ItemDao extends BaseDao { public Item selectOne(String id) { String sql = &quot;SELECT * FROM item WHERE item_id = ?&quot;; return (Item) execute(sql, rs -&amp;gt; { if (rs.next()) { Item item = new Item(); item.setId(rs.getString(&quot;item_id&quot;)); item.setName(rs.getString(&quot;item_nm&quot;)); item.setPrice(rs.getInt(&quot;price&quot;)); item.setStockCount(rs.getInt(&quot;stock_count&quot;)); return item; } else { return null; } }, id); }}@FunctionalInterfacepublic interface ResultSetHandler&amp;lt;T&amp;gt; { T handle(ResultSet rs) throws SQLException;;}" }, { "title" : "ArrayList와 LinkedList", "category" : "", "tags" : " ", "url" : "/alogrithm/2024/06/10/algorithm-arrayList.html", "date" : "June 10, 2024", "excerpt" : "Array배열은 동일한 타입의 데이터들이 순차적으로 메모리에 저장되는 자료구조입니다.인덱스를 통한 직접 접근이 가능하기 때문에 탐색 속도가 빠르다는 장점이 있습니다.하지만 크기가 고정되어 있으며 동적으로 변경할 수 없다는 단점이 있습니다.변경이 필요한 경우 배열을 새로 생성한 후 기존의 요소들을 복사하여야 합니다.ArrayList동적 배열 기반의 리스트 자료구조입니다. 내부적으로 배열을 사용하여 요소를 저장하며요소의 추가나 삭제에 의해 크...", "content" : "Array배열은 동일한 타입의 데이터들이 순차적으로 메모리에 저장되는 자료구조입니다.인덱스를 통한 직접 접근이 가능하기 때문에 탐색 속도가 빠르다는 장점이 있습니다.하지만 크기가 고정되어 있으며 동적으로 변경할 수 없다는 단점이 있습니다.변경이 필요한 경우 배열을 새로 생성한 후 기존의 요소들을 복사하여야 합니다.ArrayList동적 배열 기반의 리스트 자료구조입니다. 내부적으로 배열을 사용하여 요소를 저장하며요소의 추가나 삭제에 의해 크기가 동적으로 조정됩니다.ArrayList는 생성할 때 초기 용량을 설정할 수 있으며 기본으로 10 으로 설정됩니다.내부 배열의 용량이 초과되면 ArrayList 는 자동으로 배열의 크기를 증가시킵니다.이 과정에서 더 큰 새로운 배열을 생성하고, 기존 배열의 요소를 새로운 배열로 복사합니다.(새로운 배열의 크기는 기존 배열 크기의 1.5 또는 2 배)초기 용량을 적절히 설정하면 배열의 크기를 동적으로 늘리는 작업을 줄일 수 있습니다.배열을 늘리는 작업은 새로운 배열을 생성하고 기존 배열의 요소를 복사해야하기 때문에 비용이 많이 듭니다.너무 크게 설정하면 메모리 공간을 낭비하게 되며너무 작게 설정하게 되면 크기 조정 작업이 빈번하게 발생하여 오버헤드가 발생할 수 있습니다.배열을 기반으로 하기 때문에 인덱스를 통한 직접 접근이 가능합니다.LinkedList양방향 연결리스트 기반의 자료구조입니다. 노드로 구성이 되며 배열에 비해 삽입 삭제가 유연합니다.각 노드는 데이터 요소와 두 개의 참조(이전 노드, 다음 노드를 가리키는 포인터)로 이루어져 있습니다. 이러한 노드들이 서로 연결되어 있어서 양방향 연결 리스트(doubly linked list) 구조를 형성합니다.ArrayList와 LinkedList의 요소 추가 및 삭제 성능 차이ArrayList는 요소를 끝에 추가하는 작업이 빈번한 경우에 유리합니다.요소를 중간에 추가하거나 삭제하는 경우 비효율적일 수 있습니다.LinkedList는 요소를 중간에 추가하거나 삭제하는 작업이 빈번한 경우에 유리합니다.하지만 인덱스를 기반으로 요소에 접근하는 작업에는 비효율적입니다.특정 인덱스의 요소에 접근하려면 처음부터 해당 인덱스까지 찾아가야합니다.##ArrayList와 LinkedList의 탐색 속도ArrayList 는 인덱스를 기반으로 요소에 직접 접근하기 때문에 요소에 대한 빠른 접근이 가능합니다.따라서 요소를 탐색하는데 있어 O(1)의 시간이 소요됩니다.LinkedList 특정 인덱스의 요소에 접근하기 위해서는 처음부터 해당 인덱스까지 찾아가야 합니다. 따라서 요소를 탐색하는 데에는 평균적으로 O(n/2)의 시간이 소요됩니다. 최악의 경우 O(n)의 시간이 소요될 수 있습니다.따라서 요소의 탐색이 빈번한 경우에는 ArrayList를 사용하는 것이 효율적이며요소의 추가 및 삭제가 자주 일어나는 경우에는 LinkedList를 사용하는 것이 효율적일 수 있습니다." }, { "title" : "TCP/ UDP", "category" : "", "tags" : " ", "url" : "/network/2024/04/29/network-tcp-udp.html", "date" : "April 29, 2024", "excerpt" : "전송 계층에서 사용하는 두 가지 주요 프로토콜TCP (Transmission Control Protocol)키워드 : 전송제어, 속도조절, 패킷순서, 재전송, 신뢰성, 연결 설정 연결 지향적 프로토콜로 통신 전에 연결을 설정하고 통신이 완료되면 연결을 해제합니다. (3way handshake) 데이터를 순서대로 조립해서 보내며 데이터를 유실한 경우 재전송합니다. 네트워크에 트래픽이 몰리는 경우 전송 속도를 조절하여 혼잡을 제어합니다....", "content" : "전송 계층에서 사용하는 두 가지 주요 프로토콜TCP (Transmission Control Protocol)키워드 : 전송제어, 속도조절, 패킷순서, 재전송, 신뢰성, 연결 설정 연결 지향적 프로토콜로 통신 전에 연결을 설정하고 통신이 완료되면 연결을 해제합니다. (3way handshake) 데이터를 순서대로 조립해서 보내며 데이터를 유실한 경우 재전송합니다. 네트워크에 트래픽이 몰리는 경우 전송 속도를 조절하여 혼잡을 제어합니다. 일단 데이터가 왔다고 하면 그 데이터는 온전한 데이터임을 보장합니다. 하는 일이 많다보니 부하가 크고 속도가 상대적으로 느립니다. 웹 서비스, 파일 전송, 파일 다운로드 등 신뢰성과 순서 보장이 필요한 응용 프로그램에 적합합니다.UDP (User Datagram Protocol)키워드 : 비신뢰성, 비 연결성 비연결 지향적 프로토콜로 송신자와 수신자의 연결을 확립하지 않고 데이터를 전송합니다. 한 번 전송한 후, 확인하지 않습니다. (재전송 X) 순서와 중복, 데이터의 손실에 대해 전송을 보장하지 않습니다. 실시간 데이터 같은 경우 많은 트래픽을 계속해서 보내기 때문에 TCP 로 하기에는 부하가 큽니다. 부하가 적어 빠른 속도로 데이터를 전송할 수 있다 게임, 실시간 스트리밍 서비스 등 속도가 중요하고 약간의 데이터 손실이 허용되는 실시간 응용 프로그램에 적합합니다." }, { "title" : "TCP 3-way handshake, 4-way handshake", "category" : "", "tags" : " ", "url" : "/network/2024/04/29/network-handshake.html", "date" : "April 29, 2024", "excerpt" : "3-way handshake ?TCP 통신을 이용해서 데이터를 전송하기 위해 네트워크 연결 설정을 하는 과정즉, (TCP/IP 프로토콜을 이용해서) 통신을 하는 응용 프로그램이데이터를 전송하기 전에 정확한 전송을 보장하기 위해 상대방 컴퓨터와의 세션을 수립하는 과정입니다. FLAG 정보 SYN연결 설정 ACK응답 확인, 패킷을 받았다는 것을 의미Acknowledgement Number FIN연결 해제, 세션 종료, 더...", "content" : "3-way handshake ?TCP 통신을 이용해서 데이터를 전송하기 위해 네트워크 연결 설정을 하는 과정즉, (TCP/IP 프로토콜을 이용해서) 통신을 하는 응용 프로그램이데이터를 전송하기 전에 정확한 전송을 보장하기 위해 상대방 컴퓨터와의 세션을 수립하는 과정입니다. FLAG 정보 SYN연결 설정 ACK응답 확인, 패킷을 받았다는 것을 의미Acknowledgement Number FIN연결 해제, 세션 종료, 더 이상 전송할 데이터 없음 STEP[Step1] Client -SYN-&amp;gt; Server 나 너한테 접속할건데 괜찮니? SYN : Client가 Server에게 접속을 요청[Step2] Client &amp;lt;-SYN + ACK- Server 웅 괜찮아! 서버가 클라이언트에 SYN + ACK 전송 (LISTEN -&amp;gt; SYN_RECV) 그 후 Server는 다시 대기 상태[Step3] Client -ACK-&amp;gt; Server 오케이 -&amp;gt; 연결 SYN + ACK 상태를 확인 후 Client는 서버에게 ACK 전송 연결 성립 (Established)4-way handshake ?세션 연결을 종료하기 위한 과정연결 종료는 양쪽 호스트 모두 먼저 시도할 수 있으며, 연결을 먼저 요청하는 Host가 클라이언트,연결을 요청받는 Host 는 서버이다.실제로 TCP는 양방향 통신이기에 ‘클라이언트-클라이언트’의 형태 Control bits ACK(Acknowledgement)패킷을 받았다는 응답을 할 때 사용 Acknowledgement Number가 유효한지 표시 최초 연결의 첫 번째 세그먼트를 제외한 모든 Segment의 ACK 비트는 1로 설정 최초 연결의 첫 번째 Handshake 과정에서는 응답할 요청이 없음 FIN(Finish)TCP 연결을 종료할 때 사용 더 이상 전송할 데이터가 없음을 의미 RST(Reset)TCP 연결을 강제로 종료할 때 사용비 정상적인 세션 연결 끊기 연결을 즉시 끊고자 할 때 사용 Port 상태 정보 ESTAB 포트가 연결된 상태 CLOSE-WAIT 상대방의 FIN(종료 요청)을 받은 상태 상대방 FIN에 대한 ACK를 보내고 애플리케이션에 종료를 알린다 LAST-ACKCLOSE-WAIT 상태를 처리 후 자신의 FIN요청을 보낸 후 FIN에 대한 ACK를 기다리는 상태 FIN-WAIT-1자신이 보낸 FIN에 대한 ACK를 기다리거나 상대방의 FIN을 기다린다. FIN-WAIT-2자신이 보낸 FIN에 대한 ACK를 받았고 상대방의 FIN을 기다린다. CLOSING상대방의 FIN에 ACK를 보냈지만 자신의 FIN에 대한 ACK를 못받은 상태 TIME-WAIT모든 FIN에 대한 ACK를 받고 연결 종료가 완료된 상태 새 연결과 겹치지 않도록 일정 시간 동안 기다린 후 CLOSED로 전이한다. CLOSED연결 수립을 시작하기 전의 기본 상태 (연결 없음) STEP[STEP1] 클라이언트 -FIN-&amp;gt; 서버 연결종료 가능하니? 클라이언트가 서버에 연결 종료를 요청하는 FIN 세그먼트를 보낸다FIN 비트 : 1 이때 FIN 패킷에는 실질적으로 ACK도 포함 클라이언트는 전송 FIN-WAIT-1[STEP2] 클라이언트 &amp;lt;-ACK- 서버 우웅! 잠만! 확인해볼겡! 서버는 FIN을 받고 확인했다는 ACK를 클라이언트에 보낸 후자신의 통신이 끝날때까지 기다림 남은 데이터가 있는 경우 전송을 마친 후 close() 호출 클라이언트는 ACK를 받은 후에 서버가 남은 데이터 처리를 끝내고FIN 패킷을 보낼 때까지 기다린다. FIN_WAIT_2[STEP3] 클라이언트 &amp;lt;-FIN- 서버 종료하장! 서버가 데이터를 모두 보냈다면 연결 종료에 합의한다는 의미로FIN 패킷을 클라이언트에 전송 이후 ACK 를 받을때까지 기다림 LAST_ACK[STEP4] 클라이언트 -ACK-&amp;gt; 서버 우웅! 아직 안 온 거 있을 수 있으니까 좀만 기다렸다가 종료해야징 클라이언트는 FIN 을 받고, 응답 ACK 를 서버에 전송 아직 서버로 부터 받지 못한 데이터가 있을 수 있으므로TIME_WAIT 를 통해 기다린다 TIME_WAIT : 의도치 않은 에러로 인해 데드락으로 빠지는 것을 방지 [AFTER] 서버는 ACK 를 받은 이후 소켓 Closed TIME_WAIT 시간이 끝나면 클라이언트도 소켓을 Closed3-way-handshake와 차이가 나는 이유?클라이언트가 데이터를 전송을 마쳤다고 하더라도 서버는 아직 보낼 데이터가 남아있을 수 있기 때문에 FIN 에 대한 ACK 만 보내고 데이터를 모두 전송한 후에 자신도 FIN 메시지를 보내기 때문!서버는 마지막 FIN 을 보내기 전 아직 전송하지 못한 데이터를 전송할 수 있다그러나 데이터가 유실되어 재전송하거나 지연되어 FIN 보다 늦게 도착할 수 잇다따라서 클라이언트는 FIN을 받고도 TIME_WAIT 를 통해 혹시 모를 패킷 수신을 기다린다Abrupt Connection Release(갑작스런 연결 해제)RST(TCP reset) 세그먼트가 전송되면 갑작스러운 연결 해제가 수행된다. ACK를 보내거나 기다리는 작업이 필요하지 않고, 바로 연결이 종료된다. RST 비트를 1로 설정한 세그먼트를 전송한다. 송신자는 패킷을 보내고 바로 연결을 종료한다. 수신자는 패킷을 받으면 바로 연결을 종료한다. RST를 사용해 연결을 종료하는 경우 보안 위반의 경우 악성 코드가 존재한다고 판단되면 연결을 즉시 종료하여 보호 자원이 부족해 자원 할당을 해제해야하는 경우 TCP 연결에 장애가 발생한 경우 즉시 연결을 끊고 새로운 연결을 시도" }, { "title" : "URL (Uniform Resource Locator)", "category" : "", "tags" : " ", "url" : "/network/2024/04/28/network-url.html", "date" : "April 28, 2024", "excerpt" : "URL(Uniform Resource Locator)인터넷 상의 자원을 찾기 위한 주소https://www.naver.com:443/ 은 무슨 의미일까?1. https Hypertext Transfer Protocol Secure의 약자 웹 브라우저와 웹 서버 간의 안전한 통신을 보장합니다. HTTPS는 데이터를 암호화하여 전송함으로써 중간에서의 도청이나 데이터 변조를 방지합니다.2. www 호스트 정보3. naver.com 도메인...", "content" : "URL(Uniform Resource Locator)인터넷 상의 자원을 찾기 위한 주소https://www.naver.com:443/ 은 무슨 의미일까?1. https Hypertext Transfer Protocol Secure의 약자 웹 브라우저와 웹 서버 간의 안전한 통신을 보장합니다. HTTPS는 데이터를 암호화하여 전송함으로써 중간에서의 도청이나 데이터 변조를 방지합니다.2. www 호스트 정보3. naver.com 도메인 네임4. 443 포트 번호 웹 서버의 특정 서비스를 식별하는 번호 서버가 여러 서비스를 동시에 제공할 수 있도록 합니다. 포트 번호는 네트워크 상의 특정 프로세스를 식별하는 데 사용됩니다. 웹 브라우저가 URL에서 포트 번호를 보면, 해당 포트로 연결을 시도하여 서버와 통신을 시작합니다 일반적으로 HTTPS를 사용하는 경우 포트 번호를 명시하지 않아도 기본적으로 443 포트를 이용합니다.5. / 리소스 경로 서버에 접근하려는 자원의 경로를 나타냅니다. 서버의 루트 디렉터리를 의미 (홈페이지)도메인을 산다 -&amp;gt; naver.com 을 사는 것이 도메인을 사고 그 앞에 www 라는 웹 서버를 만들어 놓은 것이다일반적으로 웹 서비스를 담당하는 호스트는 www를 사용하는 것이 관례이다naver.com 이라는 도메인을 가진 www 서버에 443 포트로https 프로토콜을 이용해서 이 홈페이지로 접속해라" }, { "title" : "OSI 7 계층과 주소창에 naver.com을 치면 일어나는 일", "category" : "", "tags" : " ", "url" : "/network/2024/04/28/network-osi7.html", "date" : "April 28, 2024", "excerpt" : "OSI 7 계층 물리 계층 물리적인 연결을 담당하며, 물리적 매체를 통해 데이터를 전송합니다. 이더넷 케이블, 광섬유, 전송 매체의 전기적/ 광학적 특성 데이터 링크 계층 데이터의 오류를 감지하고 수정하며, 물리 계층을 통해 전송되는 데이터를 프레임으로 변환하여 전달합니다. 네트워크 내에서 노드간의 데이터 전송을 담당합니다. MAC 주소, 스위치, 이더넷 네트워크...", "content" : "OSI 7 계층 물리 계층 물리적인 연결을 담당하며, 물리적 매체를 통해 데이터를 전송합니다. 이더넷 케이블, 광섬유, 전송 매체의 전기적/ 광학적 특성 데이터 링크 계층 데이터의 오류를 감지하고 수정하며, 물리 계층을 통해 전송되는 데이터를 프레임으로 변환하여 전달합니다. 네트워크 내에서 노드간의 데이터 전송을 담당합니다. MAC 주소, 스위치, 이더넷 네트워크 계층 라우터를 이용하여 최적의 경로를 설정하여 데이터를 전달하고 라우팅하는 과정을 수행합니다. 트래픽 관리 및 패킷 분할을 수행합니다. IP 주소, 라우터, IP 프로토콜 전송 계층 신뢰성 있는 데이터의 전송을 보장합니다. 데이터 전송을 수행합니다. TCP, UDP 세션 계층 세션을 연결하고 유지합니다. 애플리케이션 간의 통신 세션을 관리하고, 데이터 교환의 동기화를 제공합니다. 표현 계층 데이터의 표현 방식을 관리합니다. 암호화 알고리즘등을 암호화 및 압축을 수행합니다. 데이터 압축, 암호화, 인코딩 응용 계층 사용자와 애플리케이션 간의 인터페이스를 제공합니다. 웹 브라우저, FTP 주소창에 naver.com을 치면 어떤 일이 일어날까?1. URL 입력 및 DNS 조회사용자가 웹 브라우저에 naver.com 을 입력합니다.브라우저는 먼저 DNS 서버에 도메인 네임(naver.com)의 IP 주소를 요청합니다. 이 과정을 통해 도메인 네임을 IP 주소로 변환합니다. DNS 도메인 네임에 매핑되는 IP 주소를 알려줍니다.2. 데이터 링크 계층DNS 쿼리로 받은 IP 주소를 가지고 개인의 컴퓨터를 빠져나와 스위치에 패킷을 전송합니다.스위치에서 ARP 테이블을 통해서 IP 주소에 해당하는 MAC 주소를 찾습니다.해당 네트워크 내에 있는 장치 중 이 MAC 주소를 가진 장치가 있는지 확인합니다. ARP 테이블에 해당하는 ARP 요청을 네트워크에 브로드캐스트하여 MAC 주소를 알아냅니다.스위치? 네트워크 내에서 여러 장치 간에 데이터를 전송하는 장치 주로 로컬 네트워크(LAN)에서 사용됩니다. MAC 주소를 사용하여 패킷을 네트워크 내에서 전송합니다. 스위치는 여러 포트를 가지고 있으며, 각 포트는 개별적인 네트워크 장치에 연결됩니다. 포트 간에 데이터를 전송, 관리하며 네트워크 트래픽을 효율적으로 관리합니다. 패킷이 동일 네트워크 내의 장치가 아닌 경우, 패킷 공유기로 전달합니다. 이때, 패킷의 목적지로 가는 최적의 경로는 공유기가 처리합니다. 2~4 계층 까지 처리할 수 있는 장비이나 주로 2계층 처리! 스위치와 공유기로 보는 데이터 이동 과정? 네트워크 구성에서는 스위치와 공유기가 함께 사용됩니다. 네트워크에서 데이터가 이동하는 과정을 보면 1. 내부 네트워크 (LAN): 컴퓨터, 서버, 프린터 등 네트워크에 연결된 장치들은 모두 스위치에 연결된다 스위치는 이 장치들 간에 데이터를 전송하고 관리합니다 내부 네트워크에서 통신할 때는 스위치를 통해 데이터가 전달된다 (나 &amp;lt;-&amp;gt; 아빠) ex) 컴퓨터 A에서 컴퓨터 B로 데이터를 보낼 때, 스위치는 컴퓨터 B의 MAC 주소를 찾아 해당 포트로 데이터를 전송한다 2. 라우터 (공유기)를 통한 외부 네트워크 (인터넷) 연결: 공유기는 내부 네트워크와 외부 네트워크(인터넷)를 연결하는 역할을 한다 공유기는 외부 네트워크와의 통신을 관리하고 내부 네트워크의 장치들이 인터넷에 접속할 수 있도록 한다 내부 네트워크에 연결된 모든 장치는 공유기에 연결되어 있으며, 데이터가 외부 네트워크로 전송될 때는 공유기를 통해 전송된다 따라서 데이터가 내부 네트워크에서 스위치를 통해 이동한 후, 외부 네트워크로 전송될 때는 공유기를 통해 이동합니다.IP 주소와 MAC 주소 🟣 왜 IP 주소가 아닌 MAC 주소일까? IP 주소는 LAN 카드에 연결되어 있는 회선(랜선)의 주소이다. 따라서 고정되어 있는 값이 아니라 인터넷 망에 접속할 때마다 달라진다 🟣 그럼 MAC 주소는? 네트워크 상에서 서로를 구분하기 위해 장치마다 할당된 물리적인 주소로 인터넷이 가능한 장비들이 가지고 있는 물리적인 주소로 고정되어 있는 값입니다. 🟣 IP 주소? 랜선을 찾아가는 라우팅 기법은 패킷에 포함된 IP주소(회선의 위치) 를 추적해서 최단 경로를 선택한다. IP 주소는 논리적인 주소이기 때문에 이 IP에서 IP주소로 목표된 네트워크로 추적해서 패킷을 보낸 뒤 그곳에서 그 IP에 등록된 MAC 주소로 변환되어 그 컴퓨터로 패킷을 전송하게 된다. 🟣 MAC 주소로만 통신하면 안 되나? 집에서 naver.com의 웹 서버를 찾는다고 가정하면, ISP내의 모든 라우터들은 전세계 모든 서버들의 MAC 주소를 다 가지고 있어야 한다. 즉, 하나하나 MAC 주소에 대해 라우팅 해줘야 한다. 하지만 IP 주소 체계는 변경 가능하고, 라우팅하는 데 효과적이다. 결론 : IP는 최적의 경로를 찾아주는 라우팅을 하기 위한 주소이고 실질적인 통신은 MAC 주소로 한다! 컴퓨터를 켜면 스위치에 신호가 들어간다 나 : 스위치야 나 켜졌으니까 IP 주소를 주겠니? 공 : 자 ~ 이거 너 IP야~~이런식으로 IP를 알려준다 -&amp;gt; 이후 스위치는 다른 컴퓨터와 핸드폰에 이런 IP 주소에 이런 MAC 주소를 갖는 아이가 들어왔어~~라며 브로드캐스트를 한다 그러고 나면 이제 스위치 안에 있는 모든 컴퓨터와 네트워크는 ARP 테이블에 정보를 하나 추가한다랜? 이더넷? arp?토큰링 만약 공유기에 1000대의 컴퓨터가 있다 그러면 그 1000대의 컴퓨터가 켜졌다/꺼졌다 할 텐데 그럴때마다 모든 컴퓨터에게 브로드캐스트를 날려서 ARP테이블을 업데이트 시켜야한다 그렇게 되면 그 1000대의 컴퓨터는 불필요하나 작업을 계속하게 된다. 그러면 부담이 생기기 때문에 브로드캐스트가 되는 범위를 좁혀줘야한다. 그리고 이 범위를 구분하기 위한 것이 넷 마스크이다. 즉, 넷 마스크는 네트워크를 구분하기 위한 것이다. OSI 관점에서 IP와 넷마스크 주소가 동일한 애들은 같은 네트워크로 본다 (AND 연산)같은 네트워크에 있는 컴퓨터는 브로드캐스트와 arp를 공유하게 되고 네트워크가 다르면영향을 받지 않는다3-1. 해당 네트워크에 MAC 주소가 있는 경우MAC 주소를 찾은 후 스위치는 해당 MAC주소를 가진 컴퓨터로 패킷을 전달합니다. 이 과정에서 데이터 링크 계층의 프레임을 사용합니다.3-2. 해당 네트워크에 MAC 주소가 없는 경우 -&amp;gt; 라우터를 통한 네트워크 계층네트워크 내에 MAC 주소가 없으면 스위치에서 라우터(공유기)를 통해 다른 네트워크로 이동합니다.네트워크 계층에서는 네트워크 간의 통신이 일어납니다.그리고 이제 naver.com 을 담당하는 라우터를 IP 주소를 이용하여 찾습니다.출발지의 장치는 네이버IP 주소를 기반으로 라우팅 테이블을 사용하여 다음 라우터를 결정합니다. 그리고 네이버 IP 주소가 있는 라우터로 패킷을 전송합니다.이 과정에서 출발 장치의 MAC 주소를 목적지 라우터의 MAC 주소로 설정하여 패킷을 전송합니다. 라우터를 거칠때마다 라우터끼리 정보를 서로 공유하고 업데이트하며 최적화된 경로를 제공합니다.라우터? 네트워크 계층에서 동작하며, 패킷을 서로 다른 네트워크 간에 데이터 패킷을 전달하는 장치 라우팅 과정을 통해 목적지 네트워크에 도착하면, 해당 네트워크의 스위치가 패킷을 처리합니다. 이 스위치는 다시 ARP 요청을 통해 최종 목적지 MAC 주소를 찾고, 패킷을 최종 장치로 전달합니다. 공유기는 방화벽, DHCP 서버, 포트 포워딩 등의 기능을 제공 집 안 내부와 같이 작은 공간에서 연결되는 친구들을 LAN 이라고 한다 LAN 은 집 안 사람들끼리 서로 간에 정보는 전달할 수는 있어도, 네이버 홈페이지에 들어가거나 멀리 있는 사람에게 연락은 할 수가 없다. 그래서 있는 것이 ISP(Internet Service Provider) 이다. 여기에 우리가 잘 알고있는 SK, KT, U+ 가 있다. 이 회사 들이 우리나라 곳곳에 인터넷 케이블을 깔아두었고 우리는 돈을 지불하고 이 케이블을 사용하는 것이다 이렇게 ISP 등이 제공해주는 더 큰 범위의 네트워크를 WAN이라고 한다.이렇게 집 안 컴퓨터들은 공유기나 ISP가 제공하는 장비들을 통해 WAN에 연결된다 WAN 은 LAN 으로 구성된 네트워크(집, 회사, 건물) 들을 연결해주는 역할을 한다출발지 장치는 패킷을 보낼 때 자신의 MAC 주소를 설정합니다. 이 MAC 주소는 출발지 장치의 네트워크 카드를 식별합니다.목적지 장치의 MAC 주소는 직접적으로 설정되지 않습니다. 대신 패킷을 다음으로 보낼 라우터의 MAC 주소로 설정됩니다. 라우터는 목적지에 패킷을 전달하기 위해 중간에 패킷을 전달하는 역할을 합니다.이렇게 하면 목적지에 도달하기 위해 패킷이 지나는 모든 라우터는 패킷을 수신하고, 다음으로 전달해야 할 곳을 알아내기 위해 자신의 MAC 주소를 사용합니다. 최종적으로 패킷은 목적지에 도달하고, 목적지 장치의 MAC 주소를 사용하여 목적지 장치에 전달됩니다.따라서 출발지 장치의 MAC 주소는 출발지를 식별하는 데 사용되고, 목적지 장치의 MAC 주소는 직접적으로 설정되지 않고, 다음으로 패킷을 보낼 라우터의 MAC 주소로 설정됩니다.출발지 장치의 네트워크 카드를 식별해야하는 이유가 있어? 네트워크에서 효율적인 통신을 가능하게 하기 위함 패킷 라우팅: 네트워크에서 패킷을 보낼 때, 출발지 장치의 네트워크 카드는패킷의 출발지를 식별하는 데 사용됩니다.이를 통해 목적지로 패킷을 전송할 때 어디서 왔는지를 알 수 있습니다. 네트워크 보안: 네트워크 보안에서 출발지 장치의 네트워크 카드는인증 및 접근 제어에 사용됩니다.네트워크에 접근하려는 디바이스가 실제로 인가된 디바이스인지 확인하기 위해네트워크 카드의 고유 식별 정보가 사용됩니다. 네트워크 장애 해결: 네트워크에서 문제가 발생할 때,네트워크 카드의 식별 정보를 사용하여 문제를 해결할 수 있습니다.각 장치의 네트워크 카드는 고유한 식별자를 가지고 있으므로,문제가 발생한 장치를 식별하고 추적하는 데 사용될 수 있습니다. 4. 패킷 전달패킷은 이러한 과정을 반복하여 네이버 서버에 도착합니다.5. 전송 계층네이버 서버가 패킷을 수신한 후, TCP, UDP 프로토콜을 이용해서 클라이언트와 서버간의 연결을 설정합니다. 연결이 정상적으로 이루어지면 소켓을 생성하고 열어서 데이터를 주고 받을 준비를 합니다.ex) peer 2 peer ( host to host )택배로 치면 그 전까지의 과정은 택배기사가 문 앞까지 배송해 준 과정이고전송계층(4)은 내가 택배의 주인(집 구성원)에게 가져다 주는 것을 말한다TCP, UDP 가 공통적으로 포트라는 것을 가지고 있는데 이건 왜 필요할까? 클라이언트 프로그램이 네트워크 상의 특정 프로그램을 지정할 때 사용 어느 서버에 접속해야하는지 포트번호를 통해 지정 어떤 프로그램이 해당 서비스를 담당하는지 알기위해서 사용한다 만약 우리 컴퓨터에 여러 개의 프로그램이 돌고 있는데 (브라우저도, 워드, 파워포인트 등) 프로그램들이 다 네트워크가 필요한 경우 패킷이 컴퓨터에 왔을때 이 패킷이 많은 프로그램들 중 어떤 프로그램이 요청한 건 지를 알 수 가 없다 그래서 어떤 프로그램이 해당 패킷을 요청했는지 컴퓨터 내부에서 알기 위해서 사용된다 ex ) https : 443, http : 80소켓? 데이터를 읽고 쓸 수 있는 하나의 통로 4 계층에서 처리된 데이터를 5 계층으로 보내줍니다. 6. 세션 계층그러면 5계층에서 세션을 열어서 실제로 데이터를 교환합니다.세션은 상태를 유지하기 위한 기능으로 세션을 통해 클라이언트와 서버의 연결이 유지됩니다.세션이란? 키워드 : 상태유지 유저의 로그인, 서비스 이용 상태 유지를 위해 사용합니다. naver.com 에 접속을 한 이후에 재접속을 했을 때 내가 아까 걔라는 것을 알기 위해서 서버가 나에 대한 정보를 저장해두고 session Id 발급한다 이후에 내가 그 session Id를 들고가면 내가 아까 걔인지 알 수 있게 해준다 유저가 로그인하거나 서비스를 이용하는 동안 상태가 유지되는 것을 말한다 7. 표현 계층그리고 6계층에서 데이터가 네이버 서버에서 클라이언트로 전달되기 전에 필요한 인코딩, 암호화 등을 처리합니다.ex) 실제 사용하는 서비스로 포장을 뜯어서 물건을 확인하는 것과 비슷하다. 우리가 살 수 있는 물건이 많은 것처럼 7계층에는 많은 서비스가 존재한다8. 응용계층데이터 형식을 변환한 후 7계층엣서 브라우저는 웹 페이지를 렌더링하고, 사용자가 웹사이트와 상호작용할 수 있도록 합니다.그 중 HTTP는 뭘까 ? 문자열을 전송하는 프로토콜 문자열을 전송할때 문자열의 엔터, 대행문자, 특수문자 등을 처리하기 위해 어떻게 처리하고 몇 개를 쪼개는 등 이러한 부분에 있어서 사전에 정해 놓은 텍스트 기반의 통신 규약 인터넷에서 데이터를 주고받을 수 있는 프로토콜 연결을 유지하지 않는 비 연결성 프로토콜 방식 -&amp;gt; Session 과 Cookie 가 등장 웹 서비스에서 사용 웹서비스인터넷 기반이 대표 서비스 중 하나 이름 프로토콜 포트 기능 WWW HTTP 80 웹서비스 Email SMTP/POP3/IMAP 25/110/114 이메일 서비스 FTP FTP 21 파일 전송 서비스 DNS TCP/UDP 53 네임 서비스 NEWS NNTP 119 인터넷 뉴스 서비스 이 서비스 자체는 웹서비스이며 웹 브라우저락고도 부른다HTTP 프로토콜을 사용해서 이 웹사이트를 사용하는 것이다웹이라고 하는 서비스를 사용하기 위한 도구가 http이다" } ,  { "title" : "About", "category" : "", "tags" : " Page", "url" : "/about/", "date" : "N/A", "excerpt" : "Type on Strap is based on Type Theme, a free and open-source theme for Jekyll, licensed under the MIT License.Head over to the theme’s documentation for much more information about Type on Strap or to install this theme on your own Jekyll site.Thi...", "content" : "Type on Strap is based on Type Theme, a free and open-source theme for Jekyll, licensed under the MIT License.Head over to the theme’s documentation for much more information about Type on Strap or to install this theme on your own Jekyll site.This file is an example of a page in Jekyll, that automatically shows up in the header navigation, you can delete or modify this file freely." },      { "title" : "Works", "category" : "", "tags" : " ", "url" : "/portfolio/", "date" : "N/A", "excerpt" : "", "content" : "" },   { "title" : "Tags", "category" : "", "tags" : " ", "url" : "/tags/", "date" : "N/A", "excerpt" : "", "content" : "" },       { } , { "title" : "Tic tac toe", "category" : "", "tags" : " ", "url" : "/portfolio/tictactoe", "date" : "September 1, 2014", "excerpt" : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia...", "content" : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?Use this area of the page to describe your project. The icon above is part of a free icon set by Flat Icons." }, { "title" : "Lorem Ipsum", "category" : "", "tags" : " ", "url" : "/portfolio/submarine", "date" : "September 3, 2017", "excerpt" : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia...", "content" : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?Use this area of the page to describe your project. The icon above is part of a free icon set by Flat Icons." } , {} ]
