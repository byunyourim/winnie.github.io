<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-09-17T21:50:38+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Winnie’s Blog</title><subtitle>A website with blog posts and pages</subtitle><entry><title type="html">LRU(Least Recently Used)Cache 알고리즘</title><link href="http://localhost:4000/algorithm/2024/09/13/algorithm-lru.html" rel="alternate" type="text/html" title="LRU(Least Recently Used)Cache 알고리즘" /><published>2024-09-13T00:00:00+09:00</published><updated>2024-09-13T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2024/09/13/algorithm-lru</id><content type="html" xml:base="http://localhost:4000/algorithm/2024/09/13/algorithm-lru.html"><![CDATA[<p>캐시는 데이터나 값을 미리 복사해 놓는 임시 저장소를 말한다.
데이터를 접근하는 시간이 오래 걸리는 경우나 값을 다시 계산하는 시간을 절약하고 싶은 경우 사용한다.
캐시에 데이터를 미리 복사해 놓으면 계산이나 접근 없이 더 빠른 속도로 데이터에 접근이 가능하다.</p>

<p><br /></p>

<p>LRU (Least Recently Used)
<strong>가장 최근에 사용되지 않은 데이터를 제거하는 방식</strong></p>

<p>빠른 접근과, 업데이터가 가능하지만 많ㄱ은 공간을 차지한다는 단점이 있다.</p>

<p>새로운 데이터가 캐시에 저장될 때, 캐시에 있는 데이터에 접근할 때마다 해당 데이터를
<strong>가장 최근에 사용된 데이터</strong>로 표시하고 가장 오래 전에 사용된 데이터를 제거한다.
따라서 가장 최근에 사용된 데이터를 캐시에 보존한다.</p>

<p>이중 연결 리스트나 해시 맵과 같은 자료 구조를 사용하여 구현할 수 있다.</p>

<p><br /></p>

<h3 id="구현">구현</h3>
<p><img src="https://github.com/user-attachments/assets/863a880f-3ede-4108-8446-4b1e659fd9c4" alt="lru.png" /></p>

<h2 id="구현-1">구현</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LRUCache</span> <span class="o">{</span>

    <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">;</span>
        <span class="nc">Node</span> <span class="n">prev</span><span class="o">,</span> <span class="n">next</span><span class="o">;</span>
        <span class="nc">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Node</span><span class="o">&gt;</span> <span class="n">cache</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">capacity</span><span class="o">,</span> <span class="n">size</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Node</span> <span class="n">head</span><span class="o">,</span> <span class="n">tail</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">LRUCache</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">capacity</span> <span class="o">=</span> <span class="n">capacity</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">size</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">cache</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

        <span class="k">this</span><span class="o">.</span><span class="na">head</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">tail</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span>
        <span class="n">tail</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>

        <span class="n">moveToHead</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">moveToHead</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">removeNode</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="n">addToHead</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">removeNode</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">node</span><span class="o">.</span><span class="na">prev</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">prev</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">addToHead</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">node</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="n">node</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>

        <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
        <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Node</span> <span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
            <span class="n">cache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">newNode</span><span class="o">);</span>
            <span class="n">addToHead</span><span class="o">(</span><span class="n">newNode</span><span class="o">);</span>
            <span class="n">size</span><span class="o">++;</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">Node</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">removeTail</span><span class="o">();</span>
                <span class="n">cache</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">tail</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
                <span class="n">size</span><span class="o">--;</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">node</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
            <span class="n">moveToHead</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">Node</span> <span class="nf">removeTail</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Node</span> <span class="n">res</span> <span class="o">=</span> <span class="n">tail</span><span class="o">.</span><span class="na">prev</span><span class="o">;</span>
        <span class="n">removeNode</span><span class="o">(</span><span class="n">res</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Algorithm" /><summary type="html"><![CDATA[캐시는 데이터나 값을 미리 복사해 놓는 임시 저장소를 말한다. 데이터를 접근하는 시간이 오래 걸리는 경우나 값을 다시 계산하는 시간을 절약하고 싶은 경우 사용한다. 캐시에 데이터를 미리 복사해 놓으면 계산이나 접근 없이 더 빠른 속도로 데이터에 접근이 가능하다.]]></summary></entry><entry><title type="html">Backtracking</title><link href="http://localhost:4000/algorithm/2024/09/13/algorithm-backtrack.html" rel="alternate" type="text/html" title="Backtracking" /><published>2024-09-13T00:00:00+09:00</published><updated>2024-09-13T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2024/09/13/algorithm-backtrack</id><content type="html" xml:base="http://localhost:4000/algorithm/2024/09/13/algorithm-backtrack.html"><![CDATA[<p><strong>가능한 모든 경우의 수를 탐색하는</strong> 알고리즘 기법</p>

<p>모든 가능한 경우의 수 중에서 특정 조건을 만족하는 경우만 탐색한다. 조건을 만족하지 않으면 이전 단계로 돌아가
다른 해를 탐색한다.
불필요한 경로를 빨리 제거할 수 있어, 효율적이다.</p>

<p><br />
<img src="https://github.com/user-attachments/assets/b756e965-1c06-4de9-9a58-311184ed0136" alt="backtracking.png" /></p>

<ul>
  <li>해를 부분적으로 구성해 나가면서, 해당 해가 유망하지 않은 경우 탐색을 중단하고 이전 단계로 돌아간다.</li>
  <li>각 단계에서 선택을 하고, 그 선택에 따라 다시 문제를 재귀적으로 탐색한다.</li>
  <li>Pruning 가지치기</li>
</ul>

<p><br /></p>

<h3 id="동작">동작</h3>
<ol>
  <li>가능한 해를 하나씩 만들며 조건을 만족하는지 확인한다.</li>
  <li>각 단계에서 유망성을 확인한다.</li>
  <li>유효하지 않으면 해당 경로의 탐색을 중단하고 이전 단계로 돌아간다.</li>
  <li>유효한 해인 경우 결과에 추가한다.</li>
  <li>위의 과정을 반복하여 가능한 모든 경오를 탐색한다.</li>
</ol>

<p><br /></p>

<h2 id="구현-예시">구현 예시</h2>
<p>숫자 n이 주어졌을 때, n개의 쌍으로 된 모든 유효한 괄호 조합을 리턴하는 함수 구현</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution_BackTracking</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">backtracking</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">backtrack</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="s">""</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">backtrack</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result</span><span class="o">,</span> <span class="nc">String</span> <span class="n">currentStr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">openCnt</span><span class="o">,</span> <span class="kt">int</span> <span class="n">closeCnt</span><span class="o">,</span> <span class="kt">int</span> <span class="n">max</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">currentStr</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="n">max</span><span class="o">*</span><span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">currentStr</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">openCnt</span> <span class="o">&lt;</span> <span class="n">max</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">backtrack</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">currentStr</span> <span class="o">+</span> <span class="s">"("</span><span class="o">,</span> <span class="n">openCnt</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">closeCnt</span><span class="o">,</span> <span class="n">max</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">closeCnt</span> <span class="o">&lt;</span> <span class="n">openCnt</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">backtrack</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">currentStr</span> <span class="o">+</span> <span class="s">")"</span><span class="o">,</span> <span class="n">openCnt</span><span class="o">,</span> <span class="n">closeCnt</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">max</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Algorithm" /><summary type="html"><![CDATA[가능한 모든 경우의 수를 탐색하는 알고리즘 기법 모든 가능한 경우의 수 중에서 특정 조건을 만족하는 경우만 탐색한다. 조건을 만족하지 않으면 이전 단계로 돌아가 다른 해를 탐색한다. 불필요한 경로를 빨리 제거할 수 있어, 효율적이다.]]></summary></entry><entry><title type="html">HashMap 의 구조</title><link href="http://localhost:4000/algorithm/2024/09/12/Algorithm-hashmap.html" rel="alternate" type="text/html" title="HashMap 의 구조" /><published>2024-09-12T00:00:00+09:00</published><updated>2024-09-12T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2024/09/12/Algorithm-hashmap</id><content type="html" xml:base="http://localhost:4000/algorithm/2024/09/12/Algorithm-hashmap.html"><![CDATA[<p><strong>키-값</strong>의 쌍으로 데이터를 저장하는 자료구조</p>

<p>각 키를 해시 함수로 변환하여 배열의 인덱스에 저장하여 데이터 추가, 검색, 삭제 등의 작업을 수행한다.
키의 중복을 허용하지 않으며, 하나의 키에 하나의 값이 매핑된다.</p>

<p><img src="https://github.com/user-attachments/assets/8bffadb9-b7c8-4540-b120-da08e088dec4" alt="hashmap.png" /></p>

<p><br /></p>

<p>해시 함수는 키를 해시 코드로 변환하여 HashMap의 버킷 인덱스를 정하는데, 서로 다른 두 개의 키가 같은 해시 값을 갖는 경우가 발생한다.
이 현상을 해시 충돌이라고 한다.</p>

<p>HashMap에서는 해시 충돌을 방지하기 위해 Chaining, Open Addressing을 이용한다.</p>

<p><br /></p>

<ul>
  <li><strong>Chaining</strong><br />
충돌이 발생한 버킷 안에서 연결리스트, 트리 구조로 여러 키-값을 저장하는 방식</li>
  <li><strong>Open addressing</strong><br />
다른 빈 버킷을 찾아 데이터를 저장하는 방식</li>
</ul>

<p><img src="https://github.com/user-attachments/assets/3f8e2ac4-9be9-40fe-9861-326f10766a20" alt="hashmap2.png" /></p>

<p><br /><br /></p>

<p>자바의 HashMap은 hashCode() 메서드를 이용해 해시 값을 얻고, 배열이 찬 경우 resize() 메서드를 이용하여 
버킷 배열의 크기를 늘릴 수 있다. 기존의 항목을 새로 해싱하여 새 배열에 재분배한다.</p>

<blockquote>
  <h5 id="로드-팩터-load-factor">로드 팩터 (Load Factor)</h5>
  <p>Load Factor은 HashMap이 일정 수준 채워지면 버킷 배열을 확장할지 정하는 기준이다.
기본적으로 Java의 HashMap은 로드 팩터 0.75를 사용한다. 따라서 버킷의 75%가 차면 배열의 크기를 resizing하고 재해싱 한다.
로드 팩터를 낮게 설정하는 경우 리사이징이 더 자주 일어나며, 높게 설정하는 경우 충돌 가능성이 증가한다.</p>
</blockquote>

<p><br /></p>

<p>HashMap의 시간 복잡도는 평균적으로 <strong>O(1)</strong>이다.
하지만, 해시 충돌이 많이 발생하면, 특정 버킷에 연결된 리스트를 탐색해야 하기 때문에 시간 복잡도가  <strong>O(n)</strong>에 도달한다.
하지만, Java 8 이후 트리 구조를 사용하여 최악의 경우에도 <strong>O(log n)</strong>으로 성능을 보장할 수 있.</p>

<p><br /><br /><br /></p>

<h2 id="주요-메서드">주요 메서드</h2>
<h4 id="1-putkey-value">1. put(key, value)</h4>
<p>키와 값을 HashMap에 추가한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">dataMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;():</span>
<span class="n">dataMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"key1"</span><span class="o">,</span> <span class="s">"value1"</span><span class="o">);</span>
<span class="n">dataMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"key2"</span><span class="o">,</span> <span class="s">"value2"</span><span class="o">);</span>
<span class="n">dataMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"key3"</span><span class="o">,</span> <span class="s">"value3"</span><span class="o">);</span>
</code></pre></div></div>
<ol>
  <li>해시 함수를 통해 키를 버킷 배열의 인덱스로 변환한다.</li>
  <li>해당 버킷이 비어있는 경우 새로운 노드를 추가한다.</li>
  <li>충돌이 발생하는 경우, 연결 리스트를 순회하여 동일 키가 있는지 확인
    <ul>
      <li>동일 키가 있는 경우 값 update</li>
      <li>동일 키가 없는 경우 리스트의 끝에 새 노드 추가</li>
    </ul>
  </li>
</ol>

<p><br /></p>

<h4 id="2-getkey">2. get(key)</h4>
<p>키에 대응하는 값을 반환한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dataMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"key1"</span><span class="o">);</span>
</code></pre></div></div>
<ol>
  <li>키를 해시 함수로 변환하여 버킷의 인덱스를 찾는다.</li>
  <li>해당 버킷에 연결된 리스트를 순회하여 일치하는 키를 찾아 대응하는 값을 반환한다.</li>
  <li>키가 없는 경우 -1 또는 null 반</li>
</ol>

<p><br /></p>

<h4 id="3-removekey">3. remove(key)</h4>
<p>해당 키를 삭제한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dataMap</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="s">"key1"</span><span class="o">);</span>
</code></pre></div></div>
<ol>
  <li>키를 해시 함수로 변환해 버킷을 찾는다.</li>
  <li>해당 버킷에서 연결 리스트를 순회하여 키를 찾는다.</li>
  <li>키를 찾아 해당 노드를 리스트에서 제거한다.</li>
</ol>

<p><br /><br /><br /></p>

<h3 id="hashmap-구조">HashMap 구조</h3>
<p>버킷 배열과 노드로 구성</p>

<ul>
  <li>버킷 배열 : 키의 해시 값에 따라 값이 저장되는 배열</li>
  <li>노드 : 각 노드는 키-값과 다음 노드 정보를 갖으며, 연결리스트, 트리 형태로 연결된다.</li>
</ul>

<blockquote>
  <h4 id="버킷">버킷</h4>
  <p>배열의 한 칸으로, 해시 함수에 의해 변환된 키가 매핑되는 위치이다.
버킷 배열의 크기는 보통 2의 제곱수로 설정되어 있으며, 해시 충돌을 처리하기 위해 각 버킷에 여러 개의 키-값이 저장될 수 있다.</p>
</blockquote>

<p><br /><br /><br /></p>

<p>배열과 연결리스트의 결합으로 해시맵은 키에 대해 해시 함수를 사용해서 키가 저장될 배열의 인덱스를 정한다. 만약 서로 다른 두 키가 동일한 해시 값을
갖게 되면, 해시 충둘이 발생한다.
충돌이 발생하면, 같은 버킷에 여러 엔트리가 저장되는데, 이때 연결리스트로 연결한다.</p>

<p>자바 8 이전에는 충돌이 발생하는 경우 연결리스트를 이용하였지만, 하나의 버킷에 많은 엔트리가 저장되면,
검색 속도가 O(n)이 된다. 이를 개선하기 위해 엔트리가 일정 수준을 넘어가게되면 이진트리로 변환된다.
이진 트리는 최악의 경우에도 검색 성능이 O(log n)으로 유지된다.</p>

<p>해시코드를 이용해 데이터의 저장 위치를 빠르게 찾을 수 있으며, 검색 속도를 향상시킨다.</p>

<p><br /><br /><br /></p>

<h2 id="myhashmap-구현">MyhashMap 구현</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyHashMap</span> <span class="o">{</span>

    <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">;</span>
        <span class="nc">Node</span> <span class="n">next</span><span class="o">;</span>

        <span class="nc">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">Node</span><span class="o">[]</span> <span class="n">buckets</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">capacity</span> <span class="o">=</span> <span class="mi">10000</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MyHashMap</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">buckets</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">[</span><span class="n">capacity</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="c1">// insert or update</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">buckets</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>   <span class="c1">// 없는 경우 새로운 노드 추가</span>
            <span class="n">buckets</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>    <span class="c1">// 있는 경우 연결 리스트를 탐색, 키가 있으면 update, 없으면 node 추</span>
            <span class="nc">Node</span> <span class="n">current</span> <span class="o">=</span> <span class="n">buckets</span><span class="o">[</span><span class="n">index</span><span class="o">];</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">current</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">key</span> <span class="o">==</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">current</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
                    <span class="k">return</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">current</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
                    <span class="k">return</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">hash</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">key</span> <span class="o">%</span> <span class="n">capacity</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="nc">Node</span> <span class="n">current</span> <span class="o">=</span> <span class="n">buckets</span><span class="o">[</span><span class="n">index</span><span class="o">];</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">current</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">key</span> <span class="o">==</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">current</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">remove</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="nc">Node</span> <span class="n">current</span> <span class="o">=</span> <span class="n">buckets</span><span class="o">[</span><span class="n">index</span><span class="o">];</span>
        <span class="nc">Node</span> <span class="n">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">current</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">key</span> <span class="o">==</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">prev</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">buckets</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="n">prev</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">current</span><span class="o">;</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Algorithm" /><summary type="html"><![CDATA[키-값의 쌍으로 데이터를 저장하는 자료구조]]></summary></entry><entry><title type="html">Dependency Injection</title><link href="http://localhost:4000/spring/2024/09/06/Spring-DI.html" rel="alternate" type="text/html" title="Dependency Injection" /><published>2024-09-06T00:00:00+09:00</published><updated>2024-09-06T00:00:00+09:00</updated><id>http://localhost:4000/spring/2024/09/06/Spring-DI</id><content type="html" xml:base="http://localhost:4000/spring/2024/09/06/Spring-DI.html"><![CDATA[<p>객체지향 프로그래밍에서 <strong>객체 간의 의존성을 외부에서 주입하여 객체 간의 결합도를 낮추고, 코드의 재사용성과 유연성을 높이는 설계 패턴</strong></p>

<p>이를 통해 객체가 스스로 직접 의존성을 생성하거나 관리하는 대신, 외부에서 필요한 의존성을 주입받아서 사용한다.<br />
객체는 자신이 사용할 객체의 구현을 몰라도 되고, 인터페이스나 추상 타입에 의존한다.</p>

<h3 id="강합-결합">강합 결합?</h3>
<p>한 클래스가 다른 클래스의 구현에 직접적으로 의존하는 상황으로, 두 클래스 간의 관계를 변경하거나 유지보수가 어렵다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Engine</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Engine start!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ElectricEngine</span> <span class="kd">extends</span> <span class="nc">Engine</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Electric engine started"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Car</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Engine</span> <span class="n">engine</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">Car</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">engine</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Engine</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">startCar</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">engine</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Car started!"</span><span class="o">);</span>
    <span class="o">}</span>
    
<span class="o">}</span>
</code></pre></div></div>
<p>Car 클래스는 Engine 객체의 구현에 의존한다. 
만약 Engine이 변경되거나 다른 종류의 엔진을 사용해야 하는 경우, Car의 코드를 변경해야 한다.
그리고 테스트를 해야하는 경우 실제 Engine 객체가 필요하기 때문에 테스트가 복잡해질 수 있ㄷ사.</p>

<h5 id="구체적인-구현">구체적인 구현?</h5>
<p>클래스의 실제 행동이나 기능을 수행하는 코드를 의미한다.
Engine는 기본 엔진을 나타내는 클래스이고, ElectricEngine은 전기 엔진을 나타내는 구체적인 구현이다.
각 클래스는 start() 메서드를 다르게 구현할 수 있다.</p>

<p>Car 클래스가 특정한 Engine 객체를 직접 생성할 때, Car는 Engine의 구현에 의존하게 된다.</p>

<p>만약 Engine의 클래스가 변경 되면 Car도 변경될 수 있다.
Car 가 ElectricEngine을 사용해야 한다면, 코드를 수정해야 한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Car</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Engine</span> <span class="n">engine</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">Car</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">engine</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ElectricEngine</span><span class="o">();</span>
    <span class="o">}</span>

   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">startCar</span><span class="o">()</span> <span class="o">{</span>
      <span class="n">engine</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Car started"</span><span class="o">);</span>
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>이러한 방식은 Car가 특정한 엔진 구현에 강하게 결합되어 있어 유연성이 떨어지기 때문에, 새로운 엔진이 추가될 때마다 Car 클래스를 수정해야한다.</p>

<p>이러한 문제를 해결하기 위해 의존성 주입을 사용할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Car</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Engine</span> <span class="n">engine</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">Car</span><span class="o">(</span><span class="nc">Engine</span> <span class="n">engine</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">engine</span> <span class="o">=</span> <span class="n">engine</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">startCar</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">engine</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Car started"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>Car은 Engine의 구현에 의존하지 않고, Engine 이라는 인터페이스 또는 상위 클래스에 의존한다.
Engine 객체가 어떤 클래스인지 신경 쓰지 않아도 되고, 외부에서 주입을 받아서 사용하는 방식이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Engine</span> <span class="n">regularEngine</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Engine</span><span class="o">();</span>
<span class="nc">Car</span> <span class="n">car1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Car</span><span class="o">(</span><span class="n">regularEngine</span><span class="o">);</span>

<span class="nc">Engine</span> <span class="n">electricEngine</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ElectricEngine</span><span class="o">();</span>
<span class="nc">Car</span> <span class="n">car2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Car</span><span class="o">(</span><span class="n">electricEngine</span><span class="o">);</span>

<span class="n">car1</span><span class="o">.</span><span class="na">startCar</span><span class="o">();</span>
<span class="n">car2</span><span class="o">.</span><span class="na">startCar</span><span class="o">();</span>
</code></pre></div></div>

<h2 id="의존성-주입-방법">의존성 주입 방법</h2>
<h3 id="1-생성자-주입">1. 생성자 주입</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserService</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">UserRepository</span> <span class="n">userRepository</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">UserService</span><span class="o">(</span><span class="nc">UserRepository</span> <span class="n">userRepository</span><span class="o">)</span> <span class="o">{</span>
       <span class="k">this</span><span class="o">.</span><span class="na">userRepository</span> <span class="o">=</span> <span class="n">userRepository</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="2-setter-주입">2. Setter 주입</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserService</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">UserRepository</span> <span class="n">userRepository</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setUserRepository</span><span class="o">(</span><span class="nc">UserRepository</span> <span class="n">userRepository</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">userRepository</span> <span class="o">=</span> <span class="n">userRepository</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="3-field-주입">3. field 주입</h3>
<p>@Autowired 어노테이션을 사용하여 의존성을 필드에 직접 주입한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserService</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">UserRepository</span> <span class="n">userRepository</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>의존성 주입으로 클래스가 다른 클래스의 구현에 의존하지 않고, 인터페이스나 추상 클래스에 의존함으로써
클래스 간 결합도가 낮아진다. 
의존성 주입을 사용하면 테스트 시, 실제 객체 대신 Mock객체나 Stub 객체를 주입하여 단위 테스트가 더 용이해진다.
객체의 생성과 사용을 분리하여, 코드의 유연성과 재사용성을 높일 수 있다.</p>

<p>스프링 프레임워크는 의존성  활용한 프레임 워크로</p>]]></content><author><name></name></author><category term="Spring" /><summary type="html"><![CDATA[객체지향 프로그래밍에서 객체 간의 의존성을 외부에서 주입하여 객체 간의 결합도를 낮추고, 코드의 재사용성과 유연성을 높이는 설계 패턴]]></summary></entry><entry><title type="html">Stream API</title><link href="http://localhost:4000/java/2024/09/01/java-stream_api.html" rel="alternate" type="text/html" title="Stream API" /><published>2024-09-01T00:00:00+09:00</published><updated>2024-09-01T00:00:00+09:00</updated><id>http://localhost:4000/java/2024/09/01/java-stream_api</id><content type="html" xml:base="http://localhost:4000/java/2024/09/01/java-stream_api.html"><![CDATA[<h2 id="stream-api">Stream API</h2>
<p><strong>데이터 처리를 간결하고 효율적으로 할 수 있도록 도와주는 API</strong></p>

<p>Java8 부터 도입되어 컬렉션의 데이터를 함수형으로 처리할 수 있도록 해준다.
데이터 소스 (컬렉션, 배열, I/O 채널 등)에서 파이프라인 방식으로 연속적인 연산을 수행할 수 있다.</p>

<p><br /></p>

<h3 id="특징">특징</h3>
<h4 id="1-불변성">1. 불변성</h4>
<p>스트림은 기존의 데이터를 변경하지 않고, 새로운 스트림을 생성하여 작업을 수행한다.</p>

<h4 id="2-지연-연산-lazy-evaluation">2. 지연 연산 Lazy Evaluation</h4>
<p>스트림에는 중간 연산과 최종 연산이 있는데, 최종 연산이 호출될 때까지 중간 연산이 실제로 수행되지 않는 것을 말한다.
지연 연산으로 불필요한 계산이 줄어들어 성능이 최적화 될 수 있다.</p>

<h4 id="3-파이프라이닝-pipelining">3. 파이프라이닝 Pipelining</h4>
<p>여러 중간 연산을 연결하여 하나의 파이프라인을 구성할 수 있다.
파이프라인은 한 번의 최종 연산을 통해 처리 될 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">fruits</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"apple"</span><span class="o">,</span> <span class="s">"banana"</span><span class="o">,</span> <span class="s">"orange"</span><span class="o">);</span>

<span class="nc">Listt</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">fruits</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                             <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">name</span> <span class="o">-&gt;</span> <span class="n">name</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="o">)</span>
                             <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">String:</span><span class="o">:</span><span class="n">toUpperCase</span><span class="o">)</span>
                             <span class="o">.</span><span class="na">sorted</span><span class="o">()</span>
                             <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</code></pre></div></div>

<h4 id="4-함수형-프로그래밍-지원">4. 함수형 프로그래밍 지원</h4>
<p>함수형 인터페이스와 람다 표현식을 활용하여 함수형 프로그래밍을 지원하며, 이를 통해 코드를 간결하게 할 수 있다.</p>

<h4 id="5-다양한-데이터-소스-지원">5. 다양한 데이터 소스 지원</h4>
<p>Collection 인터페이스를 구현한 클래스뿐 아니라 배열, 파일 등 다양한 데이터를 사용할 수 있다.</p>

<h4 id="6-유형-스트림-지원">6. 유형 스트림 지원</h4>
<p>기본형 타입을 위한 스트림을 별도로 제공하여 박싱 비용을 줄일 수 있다.</p>

<p><br /><br /></p>

<h2 id="lazy-evaluation">Lazy Evaluation</h2>
<p>Java Stream API에서 중간 연산이 최종 연산이 호출될 때까지 실제로 수행되지 않는 것을 말한다.</p>

<h3 id="구현-방식">구현 방식</h3>
<h4 id="1-스트림을-생성한다">1. 스트림을 생성한다.</h4>
<p>스트림은 데이터의 요소들의 연속적인 데이터 흐름으로 스트림을 생성하면, 데이터를 일관된 방식으로 처리할 수 있는 파이프 라인을 만들 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">names</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"Alice"</span><span class="o">,</span> <span class="s">"Bob"</span><span class="o">,</span> <span class="s">"Charlie"</span><span class="o">);</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">nameStream</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="na">stream</span><span class="o">();</span> <span class="c1">// 스트림 생성</span>
        
<span class="nc">String</span><span class="o">[]</span> <span class="n">nameArray</span> <span class="o">=</span> <span class="o">{</span><span class="s">"Alice"</span><span class="o">,</span> <span class="s">"Bob"</span><span class="o">,</span> <span class="s">"Charlie"</span><span class="o">};</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">nameStream</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">nameArray</span><span class="o">);</span> <span class="c1">// 스트림 생성</span>
        
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">nameStream</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"Alice"</span><span class="o">,</span> <span class="s">"Bob"</span><span class="o">,</span> <span class="s">"Charlie"</span><span class="o">);</span> <span class="c1">// 스트림 생성</span>
</code></pre></div></div>

<h4 id="2-중간-연산을-정의한다">2. 중간 연산을 정의한다.</h4>
<p>중간 연산(filtter, map, sorted)이 스트림에 연결된다. 각 중간 연산은
   스트림을 변환하는 새로운 스트림을 반화하며, 실제 데이터는 처리되지 않는다.
   중간 연산은 다음 연산을 위한 연산 체인을 설정한다.</p>

<h4 id="3-최종-연산을-호출한다">3. 최종 연산을 호출한다.</h4>
<p>최종 연산(collect, forEach, reduce)이 호출되면 스트림의 데이터가 실제로 처리된다.<br />
   이때 스트림의 중간 연산이 실행된다.</p>

<p><br /></p>

<h4 id="장점">장점</h4>
<ul>
  <li>
    <p>스트림은 필요한 데이터만 처리하기 때문에 성능을 향상시킨다.</p>
  </li>
  <li>
    <p>중간 연산이 지연되어 필요한 시점에 처리되기 때문에 메모리 사용이 줄어든다.</p>
  </li>
  <li>
    <p>여러 중간 연산이 연결된 경우, 하나의 파이프라인에서 순차적으로 처리되기 때문에 불필요한 중간 결과가 생성되지 않는다.
모든 연산이 최종 연산이 호출될 때 한 번에 처리된다.</p>
  </li>
</ul>

<h4 id="단점">단점</h4>
<ul>
  <li>
    <p>지연 평가로 중간 연산이 언제 실행될지 모르기 때문에 디버깅이 복잡해질 수 있다.</p>
  </li>
  <li>
    <p>오류가 발생할 경우, 실제 실행 시점에서 오류가 발생하기 때문에 중간 연산에서 발생한 문제를 추적하기 어렵다.</p>
  </li>
</ul>

<p><br /><br /></p>

<h4 id="스트림은-데이터를-변경하지-않는다-왜">스트림은 데이터를 변경하지 않는다? 왜?</h4>
<p>스트림은 연산 과정에서 원본 데이터를 복사하는 것이 아닌, 참조된 데이터를 바탕으로 필요한 연산을 수행하여 새로운 데이터를 생성한다.</p>

<p>한 번 사용된 이후 재사용할 수 없는 일회성 객체이며, 이를 통해 원본 데이터의 불변성을 유지할 수 있다.</p>

<p>또한 참조 변수에 저장하지 않고 곧바로 연산을 수행할 수 있다. 즉, 스트림 객체를 별도로 저장하지 않고 사용하는 것이 가능하다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">names</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"apple"</span><span class="o">,</span> <span class="s">"banana"</span><span class="o">,</span> <span class="s">"coke"</span><span class="o">);</span>

<span class="n">names</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>          <span class="c1">// 스트림 생성</span>
     <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">name</span> <span class="o">-&gt;</span> <span class="n">name</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"a"</span><span class="o">))</span>   <span class="c1">// 중간연산 </span>
     <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="nl">String:</span><span class="o">:</span><span class="n">toUpperCase</span><span class="o">)</span>   <span class="c1">// 중간연산 </span>
     <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>          <span class="c1">// 최종연산</span>
</code></pre></div></div>
<p>위 코드에서는 names.stream()으로 스트림을 생성한 후, 이를 Stream<String> stream = names.stream(); 같은 참조 변수에 할당하지 않고 
바로 연산(filter, forEach)을 수행한다.</String></p>

<p>한 번 사용하면 다시 사용할 수 없는 일회성 객체로, 최종 연산이 수행되면 더 이상 해당 스트림을 사용할 수 없다.
만약 동일한 연산을 다시 수행하려면 names.stream()으로 새로 스트림을 생성해야 한다.</p>

<p>스트림의 파이프라인은 최종 연산이 호출될 때 한 번에 실행되고 그 후에 스트림은 종료된다.
다시 사용하려고 하면 IllegalStateException이 발생한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">stream</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">filter</span><span class="o">(</span><span class="n">name</span> <span class="o">-&gt;</span> <span class="n">name</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"A"</span><span class="o">));</span>
<span class="n">stream</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span> <span class="c1">// 최종 연산</span>
<span class="n">stream</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span> <span class="c1">// IllegalStateException 발생</span>
</code></pre></div></div>

<p><br /><br /><br /></p>

<h2 id="stateful--statefuless">Stateful &amp; Statefuless</h2>

<h4 id="stateful-연산-stateful-operations">Stateful 연산 (Stateful Operations)</h4>

<p>Stateful Stream 은 스트림의 중간 연산 중 이전 단계의 결과를 바탕으로 현재 연산을 수행하는 것을 말한다.<br />
전체 스트림의 상태를 추적하기 때문에 성능이 떨어질 수 있다.
sorted(), distinct() 가 있으며, 전체 데이터의 상태를 고려해야 하기 때문에 연산 중 일시적으로 전체 데이터를 저장하거나 처리해야 한다.</p>

<p>연산을 수행할 때 스트림의 요소들 간의 상태나 순서를 유지하거나 추적해야 하는 연산<br />
연산은 스트릠의 모든 요소를 고려하여 상태를 유지하거나 변경할 필요가 깅ㅅ다.
상태를 추적해야 하기 때문에 메모리 사용량이 증가하고 성능이 저하될 수 있다.
요소 간의 관계를 고려하거나, 스트림 전체를 정렬, 필터링해야 할 때 사용한다.</p>

<ul>
  <li>
    <p>sorted 
스트림의 모든 요소를 정렬하기 위해 전체 스트림을 고려한다. 요소를 정렬하려면 전체 데이터를 메모리에
로드하고 정렬해야 하기 때문에 상태를 유지한다.</p>
  </li>
  <li>
    <p>distinct
중복을 제거하기 위해 스트림의 모든 요소를 기억하고 비교해야 하기 때문에 상태를 유지한다.</p>
  </li>
</ul>

<p><br /></p>

<h4 id="stateless-연산-stateless-operations">Stateless 연산 (Stateless Operations)</h4>
<p>연산을 수행할 때 스트림의 요소 간의 상태를 유지하지 않고, 각 요소를 독립적으로 처리하는 연산<br />
요소 간의 관계를 고려하지 않는다.</p>

<p>연산은 각 요소를 독립적으로 처리하며, 이전 또는 다른 요소의 상태에 의존하지 안흔다.
상태를 유지하지 않기 때문에 메모리 사용량이 적고 성능이 좋으며, 각 요소를 독립적으로 처리하여 결과를 생성한다.</p>

<ul>
  <li>
    <p>filter()
각 요소를 개별적으로 검사하여 조건에 맞는 요소만 남기며, 다른 요소의 상태나 관계를 고려하지 않는다.</p>
  </li>
  <li>
    <p>map()
각 요소를 다른 형태로 변환하며, 이 과정에서 요소 간이 관계를 고려하지 않는다.</p>
  </li>
</ul>

<p><br /><br /><br /></p>

<h2 id="중간-연산과-최종-연산">중간 연산과 최종 연산</h2>

<p><br /></p>

<h3 id="중간-연산">중간 연산</h3>
<p>스트림 파이프라인에서 스트림을 변환하거나 필터링한다.
스트림을 변경하지 않고 새로운 스트림을 반환하며, 지연 평가를 통해 최종 연산이 호출될 때까지 실제로 수행되지 않는다.
연속해서 호출할 수 있으며, 스트림 파이프라인을 구성할 수 있다.</p>
<ul>
  <li>filter(Predicate<T>) : 조건에 맞는 요소만 필터링하여 새로운 스트림 반환
</T>    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">names</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"amy"</span><span class="o">,</span> <span class="s">"jenny"</span><span class="o">,</span> <span class="s">"bob"</span><span class="o">,</span> <span class="s">"jun"</span><span class="o">);</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">filteredStream</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="na">streaam</span><span class="o">()</span>
                                   <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">name</span> <span class="o">-&gt;</span> <span class="n">name</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"j"</span><span class="o">));</span>
</code></pre></div>    </div>
  </li>
  <li>map(Function&lt;T, R&gt;) : 각 요소를 다른 형태로 변환하여 새로운 스트림 반환
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">names</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"amy"</span><span class="o">,</span> <span class="s">"jenny"</span><span class="o">,</span> <span class="s">"bob"</span><span class="o">,</span> <span class="s">"jun"</span><span class="o">);</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">upperCaseStream</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                                    <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">String:</span><span class="o">:</span><span class="n">toUpperCase</span><span class="o">);</span>
</code></pre></div>    </div>
  </li>
  <li>sorted(Comparator<T>) : 스트릠의 요소를 정렬하여 새로운 스트림 반환
</T>    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">sortedStream</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">sorted</span><span class="o">();</span>
</code></pre></div>    </div>
  </li>
</ul>

<p><br /></p>

<h3 id="최종-연산">최종 연산</h3>
<p>스트림 파이프라인의 결과를 생성한다.
스트림의 요소를 실제로 처리하여 결과를 반환하며, 스트림이 종료되고 더 이상 사용할 수 없다. 최종 연산이 호출되면, 중간 연산이 실행된다.</p>

<h5 id="--foreachconsumer-t-">- forEach(Consumer&lt; T &gt;)</h5>
<p>스트림의 각 요소에 대해 주어진 작업 수행</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">names</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"amy"</span><span class="o">,</span> <span class="s">"jenny"</span><span class="o">,</span> <span class="s">"bob"</span><span class="o">,</span> <span class="s">"jun"</span><span class="o">);</span>

<span class="n">names</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</code></pre></div></div>

<h5 id="--collectcollectort-a-r">- collect(Collector&lt;T, A, R&gt;)</h5>
<p>스트림의 요소를 수집하여 컬렉션 또는 다른 형태의 결과 생성</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">names</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"amy"</span><span class="o">,</span> <span class="s">"jenny"</span><span class="o">,</span> <span class="s">"bob"</span><span class="o">,</span> <span class="s">"jun"</span><span class="o">);</span>

<span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">collectedNames</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
        <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</code></pre></div></div>

<h5 id="--reducebinaryoperator">- reduce(BinaryOperator<T>)</T></h5>
<p>스트림의 요소를 하나로 결합하여 단일 결과 생성</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
<span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
        <span class="o">.</span><span class="na">reduce</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="nl">Integer:</span><span class="o">:</span><span class="n">sum</span><span class="o">);</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Java" /><summary type="html"><![CDATA[Stream API 데이터 처리를 간결하고 효율적으로 할 수 있도록 도와주는 API]]></summary></entry><entry><title type="html">Lambda 와 함수형 인터페이스</title><link href="http://localhost:4000/java/2024/09/01/java-lamda.html" rel="alternate" type="text/html" title="Lambda 와 함수형 인터페이스" /><published>2024-09-01T00:00:00+09:00</published><updated>2024-09-01T00:00:00+09:00</updated><id>http://localhost:4000/java/2024/09/01/java-lamda</id><content type="html" xml:base="http://localhost:4000/java/2024/09/01/java-lamda.html"><![CDATA[<p><br /></p>

<p>람다 표현식은 <strong>자바의 메서드 하나의 식으로 간결하게 표현한 것</strong> 이다.</p>

<p><br /></p>

<p>이전에는 자바에서 메서드를 표현하려면 클래스를 정의해야 했다. 하지만 자바 8 부터 람다식을 통해 메서드의 이름과 반환값을 
생략할 수 있고, 이를 변수에 넣어 코드를 간결하게 한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">add</span> <span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">;</span> 
<span class="o">}</span>


<span class="c1">// 이는 아래와 같이 변경할 수 있다.</span>
<span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">;</span>
</code></pre></div></div>

<p><br /></p>

<p><strong>(매개변수) -&gt; {함수 본문}</strong> 의 형태로,</p>

<p>매개 변수가 없는 경우 () 를 사용하고, 매개 변수가 하나 인 경우 괄호를 생략할 수 있으며, 
함수의 본문이 하나인 경우 중괄호와 return을 생략할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 매개변수가 없고, 표현식이 하나</span>
<span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"hello"</span><span class="o">):</span>

<span class="c1">// 매개 변수가 하나</span>
<span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="o">;</span>

<span class="c1">// 매개변수가 여러 개이고, 본문이 여러 줄</span>
<span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /><br /><br /></p>

<h2 id="람다-표현식의-특징">람다 표현식의 특징</h2>

<h3 id="1-간결하다">1. 간결하다</h3>
<p>람다 표현식을 사용하면 코드가 간결해진다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 익명 클래스로 Runnable 구현</span>
<span class="nc">Runnable</span> <span class="n">r1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello, World!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">};</span>

<span class="c1">// 람다 표현식으로 Runnable 구현</span>
<span class="nc">Runnable</span> <span class="n">r2</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello, World!"</span><span class="o">);</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="2-익명성">2. 익명성</h3>
<p>람다 표현식은 익명함수로, 함수의 이름을 정의하지 않고 사용할 수 있다.</p>

<blockquote>
  <h5 id="익명-함수란">익명 함수란?</h5>
  <p>이름이 없는 함수로, 익명 함수는 모두 일급 객체이다.
일급 객체인 함수는 변수처럼 사용이 가능하며, 매개변수로 전달이 가능하다.</p>
</blockquote>

<p><br /></p>

<h3 id="3-타입-추론">3. 타입 추론</h3>
<p>람다 표현식에서는 컴파일러가 타입을 추론할 수 있기 때문에, 매개변수의 타입을 명시적으로 지정하지 않아도 된다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 타입 명시</span>
<span class="nc">Function</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stringLength1</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>

<span class="c1">// 타입 추론</span>
<span class="nc">Function</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stringLength2</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="4-클로저-지원">4. 클로저 지원</h3>
<p>자신이 선언된 스코프의 변수에 접근할 수 있다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LambdaExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">number</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>  
        <span class="nc">Runnable</span> <span class="n">r</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">number</span><span class="o">);</span>

        <span class="n">r</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>  <span class="c1">// 출력: 10</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="5-고차-함수-지원">5. 고차 함수 지원</h3>
<p>람다 표현식은 고차 함수를 지원한다. 
고차 함수는 다른 함수를 매개변수로 받거나, 함수를 반환하는 함수이다.</p>

<p>람다식을 이용하면, 고차 함수를 쉽게 정의하고 사용할 수 잇따.</p>

<p>람다 표현식을 사용하여 코드를 더 간결하게 할 수 있다. filter 메서드를 이용해 조건을 나타내는 람다 표현식을 매개변수로 받아 필터링을 쉽게 구현할 수 있다.</p>

<p>또한 이런 filter 메서드는 여러 상황에서 재사용할 수 있다. 조건만 다르게 해서 재사용할 수 있기 때문에, 코드의 중복이 줄고 유지보수가 쉽다.</p>

<p>컬렌션의 필터링, 매핑, 집계 등 여러 작업을 람다를 이용해서 간결하게 처리할 수 있으며, 재사용성을 높인다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.function.Function</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LambdaExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Function</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Function</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">add</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">;</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">add</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="na">apply</span><span class="o">(</span><span class="mi">3</span><span class="o">));</span>  <span class="c1">// 출력: 5</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="6-병렬-처리-가능">6. 병렬 처리 가능</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LambdaExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">);</span>

        <span class="c1">// 병렬 처리</span>
        <span class="n">list</span><span class="o">.</span><span class="na">parallelStream</span><span class="o">()</span>
            <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
            <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="7-함수형-인터페이스-구현">7. 함수형 인터페이스 구현</h3>
<p>함수형 인터페이스는 하나의 추상 메서드를 갖는 인터페이스이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FunctionalInterfaceExample</span> <span class="o">{</span>

   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

      <span class="nc">MyFunctionInterface</span> <span class="n">add</span> <span class="o">=</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">;</span>
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">add</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">3</span><span class="o">));</span>
   <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 함수형 인터페이스 정의</span>
<span class="nd">@FunctionalInterface</span>
<span class="kd">interface</span> <span class="nc">MyFunctionInterface</span> <span class="o">{</span>
   <span class="kt">int</span> <span class="nf">execute</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="인터페이스에-추상-메서드가-여러-개라면">인터페이스에 추상 메서드가 여러 개라면?</h3>
<p>함수형 인터페이스는 추상 메서드를 하나만 갖는 인터페이스이다. 이 추상 메서드는 람다표현식을 사용하여 구현할 수 있다.</p>

<p>추상 메서드가 여러 개인 인터페이스의 경우 함수형 인터페이스가 아니기 때문에 람다 표현식으로 구현할 수 없다.<br />
만약 여러 개의 메서드가 필요한 경우에는 각각의 메서드를 분리하여 함수형 인터페이스로 만들어야 한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FunctionInterface</span>
<span class="kd">interface</span> <span class="nc">FunctionInterface</span> <span class="o">{</span>
   <span class="kt">void</span> <span class="nf">execute</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Example</span> <span class="o">{</span>
   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">FunctionInterface</span> <span class="n">function</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">Systemout</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"hello"</span><span class="o">);</span>
      <span class="n">function</span><span class="o">.</span><span class="na">execute</span><span class="o">();</span>
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="8-기존-인터페이스와-호환">8. 기존 인터페이스와 호환</h2>

<p>자바에서 제공하는 함수형 인터페이스에는 <strong>Runnable, Function, Predicate, Consumer, Supplier, Callable</strong> 등이 있다.</p>

<p><br /></p>

<h3 id="️-runnable">◾️ Runnable</h3>
<p>스레드를 실행하기 위한 함수형 인터페이스</p>

<h3 id="️-functiont-r">◾️ Function&lt;T, R&gt;</h3>
<ul>
  <li>T타입의 매개변수를 입력 받아, R 타입으로 반환하는 함수형 인터페이스</li>
  <li><strong>R apply (T t)</strong>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Function</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">lengthFunction</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">lengthFunction</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">);</span>
</code></pre></div>    </div>
    <p>입력을 받아서 출력으로 변환하며, 주로 변환 작업에 사용된다.</p>
  </li>
</ul>

<h3 id="️-predicate-t-">◾️ Predicate&lt; T &gt;</h3>
<ul>
  <li>T타입의 매개변수를 입력 받아, 조건 검사 후 boolean 값을 반환하는 함수형 인터페이스</li>
  <li><strong>boolean test(T t)</strong>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Predicate</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">isEmpty</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>
<span class="kt">boolean</span> <span class="n">result</span> <span class="o">=</span> <span class="n">isEmpty</span><span class="o">.</span><span class="na">test</span><span class="o">(</span><span class="s">""</span><span class="o">);</span> <span class="c1">// true</span>
</code></pre></div>    </div>
    <p>입력값에 대해 boolean 값을 반환하며, 조건 검증에 사용한다.</p>
  </li>
</ul>

<h3 id="️-consumer-t-">◾️ Consumer&lt; T &gt;</h3>
<ul>
  <li>T타입의 입력을 받아 동작을 수행한 후, 결과를 반환하지 않는 함수형 인터페이스이다.</li>
  <li><strong>void accept(T t)</strong>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Consumer</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">str</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
<span class="n">print</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="s">"Hello, World!"</span><span class="o">);</span>
</code></pre></div>    </div>
    <p>입력을 받아서 동작을 수행하며, 결과를 반환하지 않는다.</p>
  </li>
</ul>

<h3 id="️-supplier-t-">◾️ Supplier&lt; T &gt;</h3>
<ul>
  <li>매개변수 없이 T타입의 값을 반환하는 함수형 인터페이스로 객체를 생성하거나 값을 제공한다.</li>
  <li><strong>T get()</strong>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Supplier</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">randomSupplier</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">random</span><span class="o">()</span> <span class="o">*</span> <span class="mi">100</span><span class="o">);</span>
<span class="kt">int</span> <span class="n">randomValue</span> <span class="o">=</span> <span class="n">randomSupplier</span><span class="o">.</span><span class="na">get</span><span class="o">();</span> <span class="c1">// 임의의 정수 반환</span>
</code></pre></div>    </div>
    <p>매개 변수를 받지 않고, 값을 생성하거나 제공한다.</p>
  </li>
</ul>]]></content><author><name></name></author><category term="Java" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Supplier 인터페이스와 LRU</title><link href="http://localhost:4000/java/2024/09/01/java-supplier-lru.html" rel="alternate" type="text/html" title="Supplier 인터페이스와 LRU" /><published>2024-09-01T00:00:00+09:00</published><updated>2024-09-01T00:00:00+09:00</updated><id>http://localhost:4000/java/2024/09/01/java-supplier-lru</id><content type="html" xml:base="http://localhost:4000/java/2024/09/01/java-supplier-lru.html"><![CDATA[<h3 id="supplier-인터페이스">Supplier 인터페이스</h3>
<p>입력 매개변수 없이 출력을 생성하는 인터페이스<br />
<img src="https://github.com/user-attachments/assets/14423fc5-3bc1-46b8-872e-915bfcb54732" alt="supplier.png" /></p>

<p>Supplier 인터페이스는 값을 생성하거나 제공할 수 있다.</p>

<p><br /><br /><br /></p>

<h3 id="사용-사례">사용 사례</h3>

<h4 id="1-지연-초기화">1. 지연 초기화</h4>
<p>객체나 데이터를 지연 초기화하여, 실제로 필요할 때 객체를 생성하여 성능을 높일 수 있다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LazyInitializationExample</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Supplier</span><span class="o">&lt;</span><span class="nc">ExpensiveObject</span><span class="o">&gt;</span> <span class="n">expensiveObjectSupplier</span> <span class="o">=</span> <span class="k">this</span><span class="o">::</span><span class="n">createExpensiveObject</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">ExpensiveObject</span> <span class="nf">createExpensiveObject</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expensive object created"</span><span class="o">);</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">ExpensiveObject</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">ExpensiveObject</span> <span class="nf">getExpensiveObject</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">expensiveObjectSupplier</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">LazyInitializationExample</span> <span class="n">example</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LazyInitializationExample</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Before accessing expensive object"</span><span class="o">);</span>
        <span class="nc">ExpensiveObject</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">example</span><span class="o">.</span><span class="na">getExpensiveObject</span><span class="o">();</span> <span class="c1">// 이 시점에서 객체 생성</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"After accessing expensive object"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">ExpensiveObject</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">ExpensiveObject</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 복잡한 초기화 작업</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>객체의 생성이 필요할 때까지 지연되기 때문에 초기화 시점에 대한 제어가 가능하며, 따라서 불필요한 리소스 사용을 줄일 수 있다.</p>

<p><br /></p>

<h4 id="2-기본-값-제">2. 기본 값 제</h4>
<p>어떤 메서드에서 기본적으로 사용될 값을 Supplier를 통해 정의할 수 있다.
코드에서 반복적으로 사용되는 기본값을 관리하거나, 다양하나 상황에서 기본 값을 다르게 설정할 때 용이하다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.function.Supplier</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DefaultValueExample</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Supplier</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">defaultNameSupplier</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="s">"Default Name"</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">name</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">name</span> <span class="o">:</span> <span class="n">defaultNameSupplier</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">DefaultValueExample</span> <span class="n">example</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DefaultValueExample</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">example</span><span class="o">.</span><span class="na">getName</span><span class="o">(</span><span class="kc">null</span><span class="o">));</span> <span class="c1">// 출력: Default Name</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">example</span><span class="o">.</span><span class="na">getName</span><span class="o">(</span><span class="s">"John"</span><span class="o">));</span> <span class="c1">// 출력: John</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="3-캐싱">3. 캐싱</h4>
<p>특정 계산의 결과를 캐싱할 수 있다.
최초 계산 후 캐시하여 이후 호출시 동일한 값을 반환하도록 한다. 값을 재사용함으로써 성능을 최적화할 수 있다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.function.Supplier</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemoizationExample</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Supplier</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">expensiveCalculation</span> <span class="o">=</span> <span class="k">this</span><span class="o">::</span><span class="n">calculate</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">Integer</span> <span class="nf">calculate</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Performing expensive calculation..."</span><span class="o">);</span>
        <span class="k">return</span> <span class="mi">42</span><span class="o">;</span> <span class="c1">// 복잡한 계산의 결과</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">Integer</span> <span class="nf">getCalculationResult</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">expensiveCalculation</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">MemoizationExample</span> <span class="n">example</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MemoizationExample</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">example</span><span class="o">.</span><span class="na">getCalculationResult</span><span class="o">());</span> <span class="c1">// 첫 번째 호출: 계산 수행</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">example</span><span class="o">.</span><span class="na">getCalculationResult</span><span class="o">());</span> <span class="c1">// 두 번째 호출: 캐시된 결과 반환</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<h4 id="4-흐름-제어">4. 흐름 제어</h4>
<p>코드의 실행 흐름을 유연하게 제어할 수 있으며, 조건에 따라 특정 코드를 실행하거나 실행하지 않도록 설정할 수 있다.
특정 값이나 객체의 생성 타이밍을 설정할 수 있고, 반복적인 코드의 중복을 줄일 때 유용하.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.function.Supplier</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ControlFlowExample</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Supplier</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">debugMessageSupplier</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="s">"Debug: Something went wrong!"</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">performAction</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">debug</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">debug</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">debugMessageSupplier</span><span class="o">.</span><span class="na">get</span><span class="o">());</span> <span class="c1">// 디버그 메시지 출력</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Action performed successfully"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ControlFlowExample</span> <span class="n">example</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ControlFlowExample</span><span class="o">();</span>
        <span class="n">example</span><span class="o">.</span><span class="na">performAction</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>  <span class="c1">// 디버그 모드</span>
        <span class="n">example</span><span class="o">.</span><span class="na">performAction</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span> <span class="c1">// 일반 모드</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p><br /><br /><br /></p>

<h2 id="supplier와-캐싱-최적화-전략">Supplier와 캐싱 최적화 전략</h2>
<p>캐싱 최적화를 통해 속도를 개선하고, 자원을 절약하고 캐시된 데이터를 최신 상태를 유지할 수 있다.
주로 자주 조회되는 데이터, 높은 비용, 제한된 자원, 데이터가 최신으로 유지되어야 하는 경우에 캐싱 전략을 최적화 한다.</p>

<h4 id="1-캐시-만료-시간-설정">1. 캐시 만료 시간 설정</h4>
<p>캐시된 데이터가 오랫동안 사용되지 않으면, 그 데이터는 오래된 정보가 될 수 있습니다. 이 경우 만료 시간을 설정하여 데이터의 신선도를 유지하고, 필요하지 않은 데이터를 자동으로 제거할 수 있습니다.
Supplier를 사용하여 만료 시간에 따라 새로 계산된 값을 캐싱할 수 있습니다.</p>

<h4 id="2lru-least-recently-used-캐싱-알고리즘">2.LRU (Least Recently Used) 캐싱 알고리즘</h4>
<p>가장 오랫동안 사용되지 않은 데이터를 우선적으로 제거하여, 메모리 사용을 최적화할 수 있습니다. LinkedHashMap과 같은 자료구조를 사용하여 LRU 캐시를 쉽게 구현할 수 있습니다.
Supplier는 LRU 캐시 내에서 데이터를 처음 요청받을 때 실제로 값을 생성할 수 있는 방법으로 사용될 수 있습니다.</p>

<h4 id="3cache-invalidation">3.Cache Invalidation</h4>
<p>캐시된 데이터가 더 이상 유효하지 않을 때, 수동 또는 자동으로 캐시를 무효화하는 전략입니다. 이는 최신 데이터가 필요하거나, 특정 이벤트가 발생했을 때 유용합니다.
위의 CachedValue 클래스에서 invalidateCache 메서드는 수동으로 캐시를 무효화할 수 있는 방법을 제공합니다.</p>

<h4 id="4lazy-loading">4.Lazy Loading</h4>
<p>처음에 데이터를 로드하지 않고, 필요할 때만 데이터를 로드하는 전략입니다. 이 전략은 초기 로딩 시간을 줄이고, 불필요한 리소스 사용을 방지합니다.
Supplier는 Lazy Loading을 구현하는 데 필수적인 도구로, 값이 필요할 때만 생성되도록 할 수 있습니다.</p>

<h4 id="5동시성-제어">5.동시성 제어</h4>
<p>여러 스레드가 동시에 캐시에 접근하는 경우, 캐시의 일관성을 유지하기 위한 동시성 제어가 필요합니다. ConcurrentHashMap과 같은 스레드 안전한 자료구조를 사용하거나, synchronized 블록을 사용하여 동시성 문제를 해결할 수 있습니다.</p>

<p><br /><br /><br /></p>

<h2 id="least-recently-used-lru">Least Recently Used (LRU)?</h2>
<p>가장 오랫동안 사용되지 않은 데이터를 우선적으로 캐시에서 제거하는 방법으로, 이를 통해 최근에 사용한 데이터는 캐시에 유지할 수 있다.</p>

<p>메모리가 제한된 환경에서 오래된 데이터는 제거하고 최신 데이터를 유지하여 메모리를 효율적으로 관리할 수 있다. 또한 자주 사용되는 데이터에 빠르게 접근할 수 있도록 하여 성능을 높일 수 있따. 또한 최신의 데이터를 유지하여 일관성을 보장할 수 있다.</p>

<p>LRU 알고리즘의 핵심은 각 데이터의 사용 시점(최근 사용 시간)을 추적하는 것입니다. 일반적인 구현 방식은 다음과 같습니다:</p>

<p>데이터 접근 시점 갱신: 데이터를 접근(읽기/쓰기)할 때마다 그 데이터의 최근 사용 시간을 갱신합니다.
캐시 가득 참: 캐시가 가득 차서 새로운 데이터를 추가해야 할 경우, 가장 오랫동안 사용되지 않은 데이터를 제거합니다.
새로운 데이터 추가: 제거된 자리에 새로운 데이터를 추가합니다.</p>

<p>LRU 캐싱은 종종 다음과 같은 자료구조를 사용하여 구현됩니다:</p>

<p>이중 연결 리스트 (Doubly Linked List): 노드의 삽입, 삭제가 효율적으로 수행됩니다. 가장 최근에 사용된 데이터를 리스트의 앞쪽에 위치시키고, 가장 오래된 데이터를 리스트의 뒤쪽에 위치시킵니다.
해시맵 (HashMap): 데이터의 빠른 조회와 참조를 위해 사용됩니다. 키를 통해 해당 노드를 빠르게 찾을 수 있습니다.</p>

<p><br /></p>

<h3 id="lru-캐싱-알고리즘의-데이터-구조">LRU 캐싱 알고리즘의 데이터 구조</h3>
<p>LinkedHashMap을 사용하여 LRU 캐싱 알고리즘을 구현할 때 중요한 부분은 새로운 데이터가 추가될 때마다 해당 데이터를 가장 최근에 사용된 데이터로 갱신하는 것이다. 
최근에 사용된 데이터를 LinkedHashMap의 뒤로 이동시키고, 가장 앞에 있는 데이터를 LRU 데이터로 판별하여 삭제하는 메커니즘을 구현하다. 또한, 삭제될 때를 예측하여 불필요한 데이터를 즉시 삭제하는 것이 중요합니다. 
이러한 구현을 통해 LinkedHashMap를 사용한 LRU 캐싱 알고리즘을 효과적으로 운영할 수 있다.</p>

<ul>
  <li>HashMap을 확장한 구조</li>
  <li>doubleLinkedList 형태</li>
</ul>

<h4 id="doublelinkedlist">DoubleLinkedList?</h4>
<p>LinkedList를 이중으로 사용하여 요소의 순서를 유지하는 리스트이다.
자바의 링크드리스트는 더블링크드리스트로 구현되어있다.</p>

<p>LinkedHashMap에는 accessOrder 이라는 값이 있다.</p>

<p>Entry 에 access 하는 mode를 나타낸다</p>
<ul>
  <li>true : access 빈도 낮은 것부터 접근</li>
  <li>false : 입력된 순서로 Entry 에 접근</li>
</ul>

<p>linkedList는 키와 값 뿐만아니라 next, after, before를 가지고 있다.</p>

<p>before : 이 노드 앞에 삽입된 노드를 가리킴
after : 이 노드 뒤에 삽입된 노드를 가리킴
key : 제공된 키
value : 제공된 값
next : 배열 테이블의 동일한 버킷에 있는 다음 노드를 가리킴</p>

<p>HashMap과의 차이
HashMap을 확장한 구조이기 때문에 HashMap의 장점 + 순서보장을 할 수 있는 구조가 linkedHashMap라고 할 수 있다.
순서 지정 기능으로 인해 HashMap보다 더 많은 메모리가 필요하다.
시간복잡도는 HashMap과 동일하게 get,put,remove,containsKey 메소드를 호출할 때 O(1)을 가진다.
HashMap과 마찬가지로 동기화 처리가 되어있지 않기 때문에 multi-thread환경에서 사용은 적절하지 않다는 특징을 가지고 있다.</p>

<p>LinkedHashMap 를 사용하여 LRU 캐싱 알고리즘을 구현하고, 데이터를 접근할 때마다 해당 데이터의 “사용 시간” 또는 “접근 시간”을 업데이트하여 최근에 사용된 데이터를 파악할 수 있고, 
이를 바탕으로 가장 오랫동안 사용되지 않은 데이터를 식별하고 처리할 수 있습니다.</p>

<p><br /></p>

<h3 id="lru-캐싱-알고리즘을-구현할-때-고려해야-할-핵심-요소는-무엇인가요">LRU 캐싱 알고리즘을 구현할 때 고려해야 할 핵심 요소는 무엇인가요?</h3>
<p>LinkedHashMap을 이용해 LRU 캐싱을 구현할 수 있다. 
LinkedHashMap은 기본적으로 이중 연결 리스트와 해시맵의 조합 형태로 동작한다.
LinkedHashMap의 생성자에서 accessOrder 파라미터를 true로 설정하면, 데이터가 접근될 때마다 노드가 리스트의 앞쪽으로 이동하게 되어 LRU 캐싱이 자동으로 구현한.</p>

<p>이 코드에서 removeEldestEntry 메서드는 캐시의 크기가 설정된 용량을 초과할 때 가장 오래된 항목을 자동으로 제거합니다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.LinkedHashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LRUCache</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">LinkedHashMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">capacity</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">LRUCache</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">capacity</span><span class="o">,</span> <span class="mf">0.75f</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">capacity</span> <span class="o">=</span> <span class="n">capacity</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">removeEldestEntry</span><span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">eldest</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">capacity</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<ol>
  <li>시간 복잡도 최적화
빠른 데이터 접근: 캐시된 데이터를 빠르게 접근할 수 있어야 합니다. 이를 위해 보통 HashMap을 사용하여 O(1) 시간 복잡도로 데이터를 검색할 수 있게 합니다.
빠른 데이터 갱신: 데이터의 삽입, 삭제 및 갱신 작업도 O(1) 시간 복잡도로 이루어져야 합니다. 이 작업은 일반적으로 <strong>이중 연결 리스트(Doubly Linked List)</strong>와 같은 자료 구조를 활용하여 구현합니다. 이중 연결 리스트를 사용하면 캐시된 항목을 리스트의 처음이나 끝으로 쉽게 이동시킬 수 있습니다.</li>
  <li>메모리 효율성
메모리 사용량: HashMap과 이중 연결 리스트를 함께 사용하면 캐시 효율성이 높아지지만, 추가적인 메모리 오버헤드가 발생합니다. 따라서 메모리 사용량과 성능 간의 균형을 고려하여 캐시 크기를 설정해야 합니다.
캐시 크기 설정: 캐시 크기가 너무 작으면 빈번한 캐시 미스가 발생하고, 너무 크면 메모리 낭비가 발생할 수 있습니다. 시스템의 메모리 제한과 실제 사용 패턴을 기반으로 적절한 캐시 크기를 설정해야 합니다.</li>
  <li>캐시 갱신 정책
데이터 삽입 시 정책: 새로운 데이터가 캐시에 삽입되면, 이를 가장 최근에 사용된 데이터로 간주하고 이중 연결 리스트의 맨 앞에 배치합니다.
캐시 크기 초과 시 정책: 캐시가 가득 찼을 때 새로운 데이터를 추가해야 하는 경우, 이중 연결 리스트의 맨 끝에 있는, 즉 가장 오랫동안 사용되지 않은 데이터를 제거합니다.</li>
  <li>동시성 관리
스레드 안전성: 멀티스레드 환경에서 캐시가 안전하게 작동하도록 동기화가 필요합니다. Java에서는 ConcurrentHashMap이나 synchronized 키워드를 사용하여 데이터의 일관성을 유지합니다. 하지만 동기화는 성능 저하를 유발할 수 있으므로 필요한 부분에만 최소한으로 적용해야 합니다.</li>
  <li>캐시의 초기화 및 무효화
캐시 초기화: 시스템 시작 시 캐시를 미리 채우거나, 캐시가 가득 찼을 때 특정 조건에 따라 캐시를 초기화할 수 있어야 합니다.
캐시 무효화: 데이터가 갱신되거나 시스템 환경이 변할 때, 캐시의 특정 데이터를 무효화할 필요가 있습니다. 이를 통해 캐시가 최신 상태를 유지하도록 할 수 있습니다.</li>
  <li>추가적인 최적화 기법
사용 패턴 분석: 캐시 사용 패턴을 분석하여 LRU 외에 다른 캐싱 전략이 더 적합한지 평가할 수 있습니다. 예를 들어, 자주 사용되는 데이터는 캐시에 오래 남도록 하는 전략을 추가할 수 있습니다.
다중 레벨 캐싱: 메모리와 디스크 또는 네트워크 캐시를 조합한 다중 레벨 캐싱을 고려할 수 있습니다. 메모리에 여유가 없을 때 디스크 기반 캐시를 사용하여 적중률을 높일 수 있습니다.</li>
</ol>]]></content><author><name></name></author><category term="Java" /><summary type="html"><![CDATA[Supplier 인터페이스 입력 매개변수 없이 출력을 생성하는 인터페이스]]></summary></entry><entry><title type="html">Event-Driven Architecture</title><link href="http://localhost:4000/java/2024/08/29/java-event-driven.html" rel="alternate" type="text/html" title="Event-Driven Architecture" /><published>2024-08-29T00:00:00+09:00</published><updated>2024-08-29T00:00:00+09:00</updated><id>http://localhost:4000/java/2024/08/29/java-event-driven</id><content type="html" xml:base="http://localhost:4000/java/2024/08/29/java-event-driven.html"><![CDATA[<p>일반적으로 API는 클라이언트가 요청한 값에 대해서 응답을 제공한다.</p>

<p>클라이언트(웹 애플리케이션, 모바일 앱, 서버)가 특정 데이터를 요청하면, API는 그 요청에 알맞은 데이터를 반환한다.</p>

<p><img src="https://github.com/user-attachments/assets/5da65ab3-e635-4092-b146-869e89a0dfee" alt="api_process.png" /></p>

<p>API는 클라이언트의 요청에 대해서만 응답을 반환하며, 클라이언트의 요청 없이 API가 데이터를 보내지 않는다.</p>

<p>하지만 API가 클라이언트의 요청 없이 데이터를 보내야 하는 상황이 있다. 클라이언트가 특정 이벤트나 조건을 즉시 알 필요가 있거나, 실시간 데이터를 지속적으로 받아야 하는 경우가 있다.</p>

<p>API가 클라이언트의 요청 없이 데이터를 주도적으로 전달하기 위해 <strong>훅, 서버-사이드 이벤트(SSE), 웹소켓, 푸시 알림, 폴링/롱 폴링</strong>과 같은 기술들이 개발되었다. 
이러한 기술은 클라이언트와 서버 간의 실시간 통신, 효율적인 데이터 전달, 그리고 더 나은 사용자 경험을 제공한다.</p>

<p><br /></p>

<p><br /></p>

<h2 id="api가-클라이언트의-요청없이-데이터를-보내는-경우">API가 클라이언트의 요청없이 데이터를 보내는 경우?</h2>
<h4 id="1-실시간-알림-시스템">1. 실시간 알림 시스템</h4>
<ul>
  <li>사용자가 메시지를 받았거나, 중요한 업데이트가 발생했을 때 이를 실시간으로 전송한다.</li>
  <li>채팅 애플리케이션, 이메일 알림, 소셜미디어 알림</li>
</ul>

<h4 id="2-실시간-데이터-스트리밍">2. 실시간 데이터 스트리밍</h4>
<ul>
  <li>실시간 스포츠 경기 데이터처럼 실시간으로 변동되는 데이터를 클라이언트가 지속적으로 받아야하는 경우</li>
  <li>주식 가격이나 환율이 실시간으로 변동할 때, 클라이언트에게 즉시 해당 데이터를 제공한다.</li>
</ul>

<h4 id="3-자동회된-작업-처리">3. 자동회된 작업 처리</h4>
<ul>
  <li>시스템에서 특정 조건이 만족되거나 이벤트가 발생했을 때, 자동으로 클라이언트에 데이터를 보내야 하는 경우</li>
  <li>주문이 완료되었을 때, 결제 시스템이 자동으로 클라이언트에게 영수증을 전송하는 경우</li>
  <li>백엔드 서버에서 데이터가 업데이트되었을 때, 관련 데이터를 자동으로 다른 서비스나 클라이언트에게 전달한다.</li>
</ul>

<h4 id="4-상태-변화-모니터링">4. 상태 변화 모니터링</h4>
<ul>
  <li>시스템의 상태가 변할 때 이를 즉시 클라이언트에 알려야 하는 경우</li>
  <li>서버의 상태가 정상에서 오류로 변경되었을 때, 이를 실시간으로 모니터링 시스템에 알린다.</li>
</ul>

<h4 id="5-트리거-기반-워크플로우">5. 트리거 기반 워크플로우</h4>
<ul>
  <li>특정 이벤트가 발생하면 워크플로우를 자동으로 시작하고, 그에 따라 클라이언트에게 데이터를 보내야하는 경</li>
</ul>

<p><br />
<br /></p>

<h4 id="웹훅webhook">웹훅(Webhook)</h4>
<p>서버가 <strong>특정 이벤트를 발생시켰을 때, 미리 정의된 url로 http 요청을 보내는 방식</strong><br />
클라이언트가 서버에 따로 요청을 보내지 않아도 서버가 클라이언트에 데이터를 전송할 수 있다.</p>
<ul>
  <li>결제 완료, 사용자 등록, 데이터베이스 업데이트 등이 발생할 때 웹훅을 통해 관련 정보를 클라이언트에 전송한다.</li>
  <li>클라이언트는 서버에 웹훅 URL을 등록하고, 서버는 특정 이벤트 발생 시 해당 URL로 HTTP POST 요청을 보낸다.</li>
</ul>

<p><br /></p>

<h4 id="서버-사이드-이벤트server-sent-events-sse">서버-사이드 이벤트(Server-Sent Events, SSE)</h4>
<p>서버가 클라이언트에 <strong>실시간 데이터를 지속적으로 스트리밍 하는 방식</strong>
클라이언트가 한 번 서번에 연결을 맺으면, 서버는 클라이언트가 연결을 끊지 않는 한 실시간으로 데이터를 계속해서 전송할 수 있다.</p>
<ul>
  <li>실시간 주식 가격 업데이트, 뉴스 피드, 실시간 알림 등</li>
  <li>클라이언트는 서버와 연결을 맺고, 서버는 그 연결을 통해 실시간으로 데이터를 전송한다. 주로 HTTP 프로토콜을 사용하며, 클라이언트는 이벤트를 수신한다.</li>
</ul>

<p><br /></p>

<h4 id="웹소켓websocket">웹소켓(WebSocket)</h4>
<p>클라이언트와 서버 간의 <strong>실시간 양방향 통신</strong>을 가능하게 하는 프로토콜<br />
연결이 한 번 성립되면, 클라이언트와 서버는 서로 데이터를 자유롭게 주고받을 수 있다.</p>
<ul>
  <li>실시간 채팅 애플리케이션, 실시간 게임, 협업 도구 등</li>
  <li>클라이언트와 서버가 처음에 핸드셰이크를 통해 웹소켓 연결을 맺으면, 이후 양방향 데이터 전송이 가능하다.</li>
</ul>

<p><br /></p>

<h4 id="푸시-알림push-notifications">푸시 알림(Push Notifications)</h4>
<p><strong>모바일 애플리케이션</strong>에서 많이 사용되는 방식으로 서버가 클라이언트(모바일)에 <strong>알림을 푸시</strong>하는 방식<br />
푸시 알림은 서버가 클라이언트의 상태에 따라 메시지를 보낸다.</p>
<ul>
  <li>메시지 알림, 새 콘텐츠 업데이트 알림 등</li>
  <li>푸시 서버를 통해 클라이언트에 알림을 전달한다. 클라이언트는 푸시 토큰을 서버에 등록해두고, 서버는 해당 토큰을 사용해
특정 클라이언트에 알림을 보낸다.</li>
</ul>

<p><br /></p>

<h4 id="폴링polling과-롱-폴링long-polling">폴링(Polling)과 롱 폴링(Long Polling)</h4>
<p><strong>클라이언트가 주기적으로 서버에 데이터를 요청</strong>하는 방식<br />
폴링은 클라이언트가 정해진 간격으로 서버에 요청을 보내고, 롱 폴링은 서버가 새로운 데이터가 있을 때까지 응답을 지연시킨 뒤
클라이언트에 응답을 보낸다.</p>
<ul>
  <li>실시간 알림에 사용되나 비효율적</li>
  <li>클라이언트가 정해진 주기로 서버에 요청을 보내거나, 롱 폴링에서 클라이언트가 요청을 보내고 서버가 새 데이터가 생길 때까지 응답을 기다린 후 데이터를 보낸다.</li>
</ul>

<p><br /></p>

<p>위의 기술들은 클라이언트와 서버 간의 실시간 통신, 효율적인 데이터 전달, 그리고 더 나은 사용자 경험을 제공하기 위해 등장했으며, 이벤트 드리븐 방식으로 처리한다.</p>

<p><br /></p>

<p><br /></p>

<p><br /></p>

<h2 id="이벤트-드리븐-event-driven-아키텍처">이벤트 드리븐 Event-Driven 아키텍처</h2>
<p><strong>이벤트를 중심으로 동작하도록 설계된 아키텍처</strong>로
특정 이벤트가 발생할 때마다, 그에 반응하는 작업이 자동으로 실행된다.</p>

<p><br /></p>

<p><br /></p>

<h4 id="이벤트-처리-과정">이벤트 처리 과정</h4>
<p><img src="https://github.com/user-attachments/assets/3b081ef7-8bb6-4496-bc65-fe25c16aa53c" alt="event_process.png" /></p>

<h3 id="event">Event</h3>
<ul>
  <li>시스템 내에서 발생하는 중요한 사건이나 상태 변화</li>
  <li>버튼 클릭, 스크롤, 데이터베이스에 새로운 항목 추가, 특정 시간에 도달 등등</li>
</ul>

<h3 id="event-source">Event Source</h3>
<ul>
  <li>시스템 내에서 중요한 상태 변화, 이벤트 감지</li>
  <li>특정 비즈니스 이벤트를 트리거한다.</li>
  <li>사용자의 행동(클릭, 입력), 시스템 내의 상태 변화(파일 생성, 데이터 업데이트) 등</li>
</ul>

<h3 id="event-producer">Event Producer</h3>
<ul>
  <li>이벤트 소스가 감지한 상태 변화, 동작을 바탕으로 이벤트 메시지 생성한다.</li>
  <li>에빈트를 준비하고 발행한다.</li>
  <li>데이터베이스에서 새로운 레코드가 생성되거나, 사용자 애플리케이션에서 특정 역할을 수행했을 때 이벤트 프로듀서가 이벤트 메시지를 생성한다.</li>
</ul>

<h3 id="event-emitter">Event Emitter</h3>
<ul>
  <li>이벤트 프로듀서가 생성한 이벤트 메시지를 시스템 내에서 전파한다.</li>
  <li>이벤트 메시지를 이벤트 브로커나 이벤트 버스로 전달한다.</li>
</ul>

<h3 id="event-message">Event Message</h3>
<ul>
  <li>이벤트에 관한 정보를 담고 있는 데이터 구조</li>
  <li>이벤트의 유형과 관련된 데이터를 포함한다.</li>
  <li>이벤트에 대한 정보를 포함하며, 시스템 내 다른 컴포넌트들이 이 정보를 통해 작업을 수행한다.</li>
</ul>

<blockquote>
  <h4 id="구성요소">구성요소</h4>
  <p><strong>이벤트 타입</strong> : 이벤트의 종류 (OrderCreated, UserSignUp)<br />
<strong>페이로드</strong> : 이벤트와 관련된 데이터 (주문 ID, 사용자 정보)<br />
<strong>메타데이터</strong> : 이벤트 발생 시간, 위치, 우선 순위 등 부가 정보</p>
</blockquote>

<h3 id="event-broker-message-queue">Event Broker/ Message Queue</h3>
<ul>
  <li>이벤트 메시지를 수신하고, 이를 관리하여 등록된 이벤트 소비자에게 전달한다.</li>
  <li>메시지 큐는 이벤트를 일시적으로 저장하고, 차례로 소비자에게 전달한다.</li>
  <li>이벤트 프로듀서와 이벤트 컨슈머 간의 비동기적 통신을 가능하게 한다.</li>
  <li>Event Producer 큐에 이벤트 메시지를 넣고, Event Consumer 큐에서 메시지를 꺼내 처리한다.</li>
  <li>Apache Kafka, RabbitMQ, Amazon SQS.</li>
</ul>

<h3 id="event-bus">Event Bus</h3>
<ul>
  <li>이벤트 메시지를 발행하고, 여러 Event Consumer에 전달한다.</li>
  <li>애플리케이션 내에서 이벤트를 라우팅하고 관리한다.</li>
  <li>대규모 마이크로서비스 아키텍처에서 여러 서비스가 이벤트 버스를 통해 서로 이벤트를 주고 받는다.</li>
</ul>

<h3 id="event-consumer">Event Consumer</h3>
<ul>
  <li>이벤트 메시지를 수신하고 그에 맞는 작업을 수행한다.</li>
  <li>Consumer은 특정 이벤트에 대해 등록되어 있으며, 이벤트가 발생하면 이를 처리한다.</li>
  <li>주문이 생성되면, 주문 처리 서비스가 그 이벤트를 받아 결제 처리를 한다.</li>
</ul>

<h3 id="event-stream">Event Stream</h3>
<ul>
  <li>연속적으로 발생하는 이벤트를 시간 순서대로 기록하는 로그 또는 데이터 구조</li>
  <li>스트림에서 발생한 이벤트들을 순차적으로 처리하며, 실시간 데이터 처리에 유용한다.</li>
  <li>Apache Kafka와 같은 시스템에서 이벤트 스트림을 관리하며, 실시간 데이터 파이프라인을 구축한다.</li>
</ul>

<p><br /></p>

<p><img src="https://github.com/user-attachments/assets/70c816a4-98eb-4eb3-8da9-08e8a834e198" alt="event1.png" /></p>

<h2 id="동작-방식">동작 방식</h2>
<h4 id="1-이벤트-발생">1. 이벤트 발생</h4>
<ul>
  <li>특정 조건이나 사용자 행동을 인해 이벤트가 발생한다.</li>
</ul>

<h4 id="2-이벤트-생성">2. 이벤트 생성</h4>
<ul>
  <li>이벤트 프로듀서가 상태 변화에 대한 이벤트 메시지를 생성한다.</li>
</ul>

<h4 id="3-이벤트-전파">3. 이벤트 전파</h4>
<ul>
  <li>이벤트 프로듀서가 생성한 이벤트 메시지를 이벤트 브로커나 이벤트 버스로 전송한다.</li>
</ul>

<h4 id="4-이벤트-전달">4. 이벤트 전달</h4>
<ul>
  <li>이벤트 브로커, 메시지 큐는 이벤트 메시지를 수신하고, 이를 관리하여 등록된 이벤트 소비자에게 전달한다.</li>
  <li>이벤트 버스는 이벤트 메시지를 애플리케이션 내에서 라우팅하고, 여러 Consumer에 전달한다.</li>
</ul>

<h4 id="5-이벤트-처리">5. 이벤트 처리</h4>
<ul>
  <li>이벤트 소비자가 이벤트 메시지를 수신한 후, 그에 맞는 작업을 수행한다.</li>
  <li>주문이 생성되었을 때 결제를 처리하거나, 이메일을 전송하는 작업이 이루어질 수 있다.</li>
</ul>

<h4 id="6-후속-작업">6. 후속 작업</h4>
<ul>
  <li>하나의 이벤트의 처리 결과로 다른 이벤트가 발생할 수 있으, 추가적인 이벤트가 발생할 수 있다.</li>
  <li>결제가 완료되면 ‘결제완료’ 이벤트가 발생하고, 이를 기반으로 배송 시스템에서 작업이 시작될 수 있다.</li>
</ul>

<p><br /></p>

<h2 id="특징">특징</h2>
<h4 id="1-비동기성-및-비차단-io">1. 비동기성 및 비차단 I/O</h4>
<p>이벤트 드리븐 모델은 비동기로 동작하ㅏ기 때문에, 작업이 완료될 때까지 프로그램이 대기하지 않고 다른 작업을 수행할 수 있다. <br />
따라서 시스템 자원을 낭비하지 않고 다른 작업을 처리할 수 있다.</p>

<h4 id="2-높은-동시성-처리">2. 높은 동시성 처리</h4>
<p>이벤트 드리븐 모델은 많은 동시 연결을 할 수 있다. 수천 개 이상의 동시 연결을 단일 스레드로 처리할 수 있기 때문에 확장성이 뛰어나다.</p>

<p><strong>스레드 기반 모델의 경우</strong> 각 연결에 대해 별도의 스레드를 생성하기 때문에 많은 연결이 발생할 경우 스레드 관리가 복잡해지고 리소스 소모가 커진다.</p>

<h4 id="3-반응성-및-사용자-경험">3. 반응성 및 사용자 경험</h4>
<p>UI 애플리케이션에서 사용자 입력에 즉각적으로 반응하여 빠른 응답을 제공하기 때문에 사용자 경험 반응성을 높일 수 있다.</p>

<h4 id="4-복잡한-상태-관리-용이">4. 복잡한 상태 관리 용이</h4>
<p>상태 기계와 같은 구조를 사용하여, 다양한 상태에서 발생하는 여러 이벤트를 효율적으로 처리할 수 있다.</p>

<h4 id="5-예측-가능성">5. 예측 가능성</h4>
<p>각 이벤트에 대한 처리가 예측이 가능하기 때문에, 시스템과 신뢰성과 유지보수성을 높일 수 있다.</p>

<p><br /></p>

<h2 id="장단점">장단점</h2>
<ul>
  <li><strong>비동기적으로 처리하기 때문에</strong>, 시스템이 더 많은 이벤트를 처리할 수 있다. (확장성)</li>
  <li>이벤트 처리 로직을 분리하여, 새로운 기능을 추가하거나 변경할 때 기존 시스템에 <strong>영향을 최소화</strong>할 수 있다. (유연성)</li>
  <li>이벤트 발생 즉시 반응할 수 있어 <strong>실시간 시스템</strong>에 용이하다.</li>
  <li>이벤트의 흐름을 추적하고 디버깅이 어려우며, 이벤트가 여러 시스템에 걸쳐 발생할 때 <strong>복잡도가 증가</strong>한다.</li>
  <li>비동기 처리로 인해 <strong>데이터의 일관성</strong>을 유지하기 어려우며, 추가적인 설계, 관리가 필요할 수 있다.</li>
  <li>이벤트나 버스의 관리 및 유지보수에 추가적인 리소스가 필요하기때문에 <strong>오버헤드가 발생</strong>할 수 있다.</li>
</ul>

<p><br /></p>

<h2 id="사용-사례">사용 사례</h2>
<ul>
  <li><strong>사용자 인터페이스</strong> : 버튼 클릭, 마우스 이동 등 사용자 입력에 반응하는 작업을 처리한다.</li>
  <li><strong>실시간 애플리케이션</strong> : 채팅 애플리케이션, 실시간 알림 등에서 이벤트를 기반으로 데이터를 전송한다.</li>
  <li><strong>마이크로서비스 아키텍처</strong> : 각 서비스가 독립적으로 이벤트를 발생시키고 이를 다른 서비스가 수신하여 처리한다.</li>
  <li><strong>IoT 시스템</strong> : 센서 데이터가 변경되거나 특정 조건이 충족될 때 이벤트를 발생시키고, 그에 대응하는 작업을 한다.</li>
</ul>

<p><br /></p>

<h2 id="msa와의-관계">MSA와의 관계</h2>
<p>마이크로서비스 아키텍처는 애플리케이션을 여러 개의 독립적인 서비스로 분리하는 설계 패턴으로 
각 서비스는 특정 비즈니스 기능을 담당하며, 독립적으로 배포, 확장, 유지보수가 가능하다.<br />
이벤트 드리븐 아키텍처는 마이크로 서비스 간 통신을 효과적으로 관리하는 데 유용하다.</p>

<p>서비스 간의 결합도를 낮추고, 서비스들이 더 독립적으로 동작하도록 한다.</p>]]></content><author><name></name></author><category term="Java" /><summary type="html"><![CDATA[일반적으로 API는 클라이언트가 요청한 값에 대해서 응답을 제공한다.]]></summary></entry><entry><title type="html">DB Lock</title><link href="http://localhost:4000/java/2024/08/29/java-dblock.html" rel="alternate" type="text/html" title="DB Lock" /><published>2024-08-29T00:00:00+09:00</published><updated>2024-08-29T00:00:00+09:00</updated><id>http://localhost:4000/java/2024/08/29/java-dblock</id><content type="html" xml:base="http://localhost:4000/java/2024/08/29/java-dblock.html"><![CDATA[<h2 id="동시성-concurrency">동시성 Concurrency</h2>

<p><strong>여러 작업이 동시에 실행되는 것처럼 보이도록 관리되는 상태</strong>로, 하나의 CPU에서 여러 작업이 실행될 때
CPU는 빠르게 작업을 전환하여 <strong>마치 여러 작업이 동시에 실행되는 것처럼</strong> 보이게 한다.</p>

<p>동시성을 활용하면 프로그램의 여러 부분이 동시에 실행되어, 더 많은 작업을 빠르게 처리할 수 있고, 자원을 효율적으로 사용하며,
응답을 향상시킬 수 있다.</p>

<p>데이터베이스는 다수의 사용자가 데이터에 동시에 접근하게된다. 여러 사용자가 데이터베이스에 접근하는 과정에서
사용자에 대한 제어가 적절하게 이루어지지 않으면 데이터의 일관성과 무결성이 깨지게 된다.</p>

<p>따라서 동시성 제어를 통해 여러 사용자가 있는 상황에서 여러 개의 트랜잭션이 동시에 수행될 때, 데이터의 일관성이 깨지지 않도록 해야한다.</p>

<p><br /></p>

<h4 id="락의-범위">락의 범위</h4>
<p>DB, 파일, 테이블, 페이지, 컬럼 등</p>

<p><br /></p>

<h2 id="낙관적-락-optimistic-lock">낙관적 락 (Optimistic Lock)</h2>
<p><img src="https://github.com/user-attachments/assets/a1976ba0-b811-4270-b8c1-6e4fc408e1a5" alt="optimistic.png" />
자원에 락을 걸지 않고, 동시성 문제가 발생하면 그때 그때 처리하는 방식이다.</p>

<p>수정 작업을 할때 수정했다고 명시하여 다른 트랜잭션이 동일한 조건으로 값을 수정할 수 없도록 하는 것이다.<br />
version과 같은 별도의 컬럼을 추가하여 충돌의 발생을 막는다.
version(hashcode/ timestamp)의 상태로 충돌을 확인하며, 충돌된 경우 롤백한다.</p>

<p>데이터 충돌이 자주 일어나지 않을 것이라고 예상되는 경우 주로 사용한다.
조회 작업이 많기 때문에 동시 접근 성능이 중요하다.</p>

<h4 id="장-단점">장 단점</h4>
<p>충돌이 안난다는 가정하에, 동시 요청에 대해서 처리 성능이 좋다.</p>

<p>그러나 충돌이 빈번하게 일어나는 경우, 롤백처리에 대한 비용이 많이 들어 성능에서 손해를 볼 수 있다.
또한, 개발자가 직접 롤백을 구현해야하기 때문에 시스템 구조에 따라 복잡해질 수 있다.</p>

<p><br />
<br />
<br />
<br />
<br /></p>

<h2 id="비관적-락-pessimistic-lock">비관적 락 (Pessimistic Lock)</h2>

<p><img src="https://github.com/user-attachments/assets/a5b7eb4f-082e-49d4-8a4b-013a4dd84d4b" alt="pessimistic.png" />
데이터베이스나 다른 공유 자원에 접근할 때, 데이터 충돌이 발생할 가능성을 미리 고려하고 이를 방지하기 위해
자원에 대해 락을 미리 거는 방법이다.</p>

<p>하나의 트랜잭션이 자원에 접근시 락을 걸고, 다른 트랜잭션이 접근하지 못하게 하여 조회 또는 갱신 처리가 완료될 때까지 락을 유지한다.</p>

<p>데이터베이스에서 Shared Lock(공유, 읽기 잠금) 이나 Exclusive Lock(배타, 쓰기 잠금) 을 걸 수 있다.</p>

<p>충돌이 자주 발생하는 상황에서 유리하며 데이터의 무결성을 보장한다. 하지만 읽기 작업이 많이 이루어지는 경우 성능이 떨어지며
서로 자원이 필요한 경우 데드락에 걸릴 가능성이 있다.</p>

<p><img src="https://github.com/user-attachments/assets/c39ab451-cc23-410c-a80b-5b8e5f9e4c0a" alt="deadlock.png" /></p>

<p>따라서, 조건을 추가하여 대기시간을 주거나 예외처리가 가능하다.</p>

<blockquote>
  <h6 id="no-wiat">NO WIAT</h6>
  <p>잠금을 획득하지 못하면 바로 예외를 발생시킨다. <br />
트랜잭션은 다른 트랜잭션의 잠금이 해제될 때까지 대기하지 않고, 바로 실패한다. <br />
즉각 적인 실패 응답이 필요한 경우 사용</p>

  <h6 id="waitn">WAIT[n]</h6>
  <p>트랜잭션이 잠금을 요청했을 때, 해당 자원이 잠겨있는 경우, 최대 n 초 동안 대기한다.<br />
n 초 동안 잠금이 해제되지 않으면 예외가 발생하며 트랜잭션이 실패한다.</p>
</blockquote>

<p>트랜잭션이 시작될 때 Shared Lock 또는 Exclusive Lock을 걸고 시작한다.</p>

<p><br /></p>

<h3 id="공유-락-shared-lock-read-lock">공유 락 (Shared Lock, Read Lock)</h3>
<p><code class="language-plaintext highlighter-rouge">특정 자원에 대해 여러 트랜잭션이 동시에 읽기 작업을 수행할 수 있도록 허용하는 락</code></p>

<p>여러 트랜잭션이 동시에 접근하여 데이터를 읽을 수 있지만, 쓰기 작업은 제한된다. 주로 데이터 읽기의 동시성을 높이기 위해
사용하며, 어떤 자원에 공유락이 동시에 여러 개 적용될 수 있다.</p>

<p>일반적으로 select 할 때 공유락이 발생하며, 어떤 자원이 공유락에 걸려있는 경우 베타적 락을 걸 수 없다.</p>

<h4 id="공유락의-특징">공유락의 특징</h4>
<ol>
  <li><strong>동시 읽기 허용</strong><br />
공유락이 설정된 자원은 여러 트랜잭션이 동시에 읽을 수 있다. 
데이터를 읽는 작업이 병렬로 수행되기 때문에 성능이 향상된다.</li>
  <li><strong>쓰기 제한</strong><br />
공유락이 설정된 자원에 대해 다른 트랜잭션이 쓰기 작업을 수행하려고 하면
그 트랜잭션은 공유락이 해제될 때까지 대기해야 한다.
데이터를 일관되게 유지하고, 읽기 중인 데이터가 변경되지 않도록 보장한다.</li>
  <li><strong>락 충돌</strong><br />
만약 한 트랜잭션이 공유락을 걸고 데이터를 읽고 있을 때, 다른 트랜잭션이 해당 자원에 배타락을 걸려고 시도하면 충돌이 발생한다.
이 경우 쓰기 작업은 공유락이 해제될 때까지 대기한다.</li>
  <li><strong>데이터 일관성 유지</strong><br />
공유락은 트랜잭션이 데이터를 읽는 동안 해당 데이터가 다른 트랜잭션에 의해 변경되지 않도록 보호한다.</li>
</ol>

<blockquote>
  <h5 id="공유락의-장단점">공유락의 장단점</h5>
  <p>여러 트랜잭션이 동시에 데이터를 읽을 수 있어 읽기 작업의 효율성이 높으며, 데이터를 읽는 동안 데이터의 일관성을 유지할 수 있다.
그러나 여러 트랜잭션이 공유락을 설정한 상태엣서는 쓰기 작업을 기다려야 하기 때문에 성능저하가 발생할 수 있다.
또한 데드락이 발생할 수 있다.</p>
</blockquote>

<p><br /></p>

<h3 id="배타-락-exclusive-lock-write-lock">배타 락 (Exclusive Lock, Write Lock)</h3>
<p><code class="language-plaintext highlighter-rouge">특정 자원(데이터, 행, 테이블 등)에 대해 하나의 트랜잭션이 독점적으로 접근할 수 있도록 설정하는 락</code></p>

<p>배타락이 걸린 자원에는 다른 트랜잭션이 읽기, 쓰기 작업을 수행할 수 없다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">SELECT</span> <span class="o">*</span> <span class="no">FROM</span> <span class="nc">Member</span> <span class="no">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span> <span class="no">FOR</span> <span class="no">UPDATE</span><span class="o">;</span>
</code></pre></div></div>

<p>배타락을 설정하기 위해 사용하는 구문이며, 해당 데이터에 쓰기락을 걸어, 
다른 트랜잭션이 동시에 그 데이터에 접근, 수정하지 못하도록 한다.</p>

<h4 id="배타락의-특징">배타락의 특징</h4>
<ol>
  <li><strong>독점적 접근</strong><br />
자원을 잠근 트랜잭션이 자원을 독점적으로 접그할 수 있다. 다른 트랜잭션은 해당 자원이 잠겨있는 동안 접근할 수 없다.</li>
  <li><strong>쓰기 작업 보호</strong><br />
일반적으로 쓰기(수정, 삭제, 삽입 등) 작업을 수행하기 전에 설정된다.
따라서 다른 트랜잭션이 해당 자원을 동시에 수정하지 못하도록 하여 충돌을 방지한다.</li>
  <li><strong>동시성 제어</strong><br />
데이터를 보호하고 여러 트랜잭션이 동시에 데이터를 처리할 때 발생할 수 있는 문제를 예방한다.</li>
  <li><strong>락 대기</strong><br />
다른 트랜잭션이 배타락이 걸린 자원에 접근하려고 하면, 해당 트랜잭션은 락이 해제될 때까지
대기해야 한다.</li>
</ol>

<p>예를 들어, 은행 시스템에서 특정 계좌의 잔액을 수정하는 트랜잭션이 있다.</p>

<p>트랜잭션 A가 계좌의 잔액을 수정하려고 할 때, 먼저 해당 계좌 데이터에 배타락을 설정한다.
이때, 트랜잭션 A가 작업을 완료하고 락을 해제할 때까지, 트랜잭션 B는 그 계좌에 접근할 수 없게된다.
트랜잭션 A가 작업을 완료한 후 락을 해제하면, 트랜잭션 B가 계좌에 접근할 수 있다.</p>

<p>데이터의 무결성과 일관성을 보장하며 충돌을 미리 방지하여 데이터의 손상과 비 일관성을 방지한다.</p>

<p>그러나 자원이 락이 걸린 동안 다른 트랜잭션이 대기해야 하므로 성능 저하가 발생할 수 있으며,
대기 시간이 길어질 경우, 데드락의 가능성이 증가한다.</p>

<blockquote>
  <h5 id="배타락의-장단점">배타락의 장단점</h5>
  <p>데이터의 무결성과 일관성을 보장하며, 충돌을 사전에 방지하기 때문에 데이터의 손상과 비일관성을 방지할 수 있다.</p>

  <p>그러나 자원이 락에 걸린동안 다른 트랜잭션이 대기해야하기 때문에 성능 저하가 발생할 수 있으며, 대기 시간이 길어질 경우 데드락의 가능성이 증가한다.</p>
</blockquote>]]></content><author><name></name></author><category term="Java" /><summary type="html"><![CDATA[동시성 Concurrency]]></summary></entry><entry><title type="html">Socket</title><link href="http://localhost:4000/java/2024/08/27/java-socket.html" rel="alternate" type="text/html" title="Socket" /><published>2024-08-27T00:00:00+09:00</published><updated>2024-08-27T00:00:00+09:00</updated><id>http://localhost:4000/java/2024/08/27/java-socket</id><content type="html" xml:base="http://localhost:4000/java/2024/08/27/java-socket.html"><![CDATA[<h2 id="socket">Socket</h2>
<p>소켓은 TCP/IP 기반의 네트워크 통신에서 데이터 송수신의 마지막 접점을 말한다ㅣ.
네트워크를 통해 두 컴퓨터 간의 데이터 통신을 하고, 클라이언트와 서버 간의 연결을 관리한다.</p>

<p>클라이언트가 서버에 연결 요청을 보내고, 서버가 이 요청을 수락하면 데이터 전송이 시작된다.</p>

<p>지속적으로 연결을 유지하며 실시간으로 데이터를 주고 받는다.</p>

<p>클라이언트와 서버로 구분되며, 네트워크 상에서 클라이언트와 서버에 해당하는 컴퓨터를 식별하기 위해 IP 주소와 
해당 컴퓨터 내에서 현재 통신에 사용되는 응용프로그램을 식별하기 위한 포트번호가 사용된다.</p>

<p><img src="https://github.com/user-attachments/assets/5ee55c98-b46c-433a-9f66-1285d9a1372e" alt="socket.png" /></p>
<h3 id="server">Server</h3>
<p>데이터 제공</p>

<h3 id="client">Client</h3>
<p>데이터를 요청하여 제공받는 쪽</p>

<p><br /></p>

<h3 id="주요-클래스">주요 클래스</h3>
<h4 id="socket-1">Socket</h4>
<ul>
  <li>클라이언트 측에서 사용하는 클래스로 서버에 연결을 설정하고 데이터를 송수신한다.</li>
</ul>

<h4 id="serversocket">ServerSocket</h4>
<ul>
  <li>서버 측에서 사용되는 클래스로 특정 포트에서 클라이언트의 연결 요청ㅇㄹ 기다리고, 요청이 들어오면 이를 수락하여
Socket 객체를 생성한다.</li>
</ul>

<h4 id="inputstream-outputstream">InputStream/ OutputStream</h4>
<ul>
  <li>소켓을 통해 데이터를 주고 받는데 사용한다.</li>
</ul>

<h4 id="inetaddress">InetAddress</h4>
<ul>
  <li>IP 주소를 다루기 위한 클래스로 특정 호스트의 IP 주소를 얻거나, 호스트 이름을 IP 주소로 변환하는데 사용한다.</li>
</ul>

<p><br /></p>

<h3 id="클라이언트와-서버-간의-연결">클라이언트와 서버 간의 연결</h3>
<ol>
  <li>
    <p>서버 소켓 생성 후 대기
서버가 ServerSocket 를 생성 후, accept() 메서드를 호출하여 클라이언트의 연결 요청을 대기한다.</p>
  </li>
  <li>
    <p>클라이언트 측 설정 후 연결 요청
클라이언트는 서버의 IP 주소와 포트 번호로 Socket 객체를 생성하고, 서버에 연결을 요청한다.</p>
  </li>
  <li>
    <p>서버에서 연결 수락
서버는 클라이언트의 연결 요청을 수락하과, 연결된 클라이언트와 통신하기 위해 Socket 객체를 생성한다.</p>
  </li>
  <li>
    <p>데이터 송수신
클라이언트와 서버는 InputStream, OutputStream을 사용하여 데이터를 주고 받는다.</p>
  </li>
  <li>
    <p>연결 종료
통신이 끝나면 클라이언트와 서버는 각각 소켓을 닫아 연결을 종료한다.</p>
  </li>
</ol>

<p><br /></p>

<h1 id="데이터-처리">데이터 처리</h1>
<p>소켓을 통해 데이터를 주고받는 과정에서 데이터를 적절한 형식으로 변환하고 수신 후 원래의 형싱으로 변환하는 작업이 필요하다.
이 과정을 패킹, 언패킹이라고 한다.</p>

<h3 id="패킹-packing">패킹 Packing</h3>
<p>전송 전 데이터를 바이트 배열이나 스트림으로 변환하는 과정</p>
<ul>
  <li>텍스트 데이터
```java
String message = “Hello”;
byte[] data = message.getBytes(message);</li>
</ul>

<p>outputStream.write(data);</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 객체 데이터
객체를 전송하는 경우, 객체를 직렬화하여 바이트 배열로 변환한다.  
ObjectOutputStream을 사용하여 객체를 직렬화할 수 있다.
```java
ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());

oos.writeObject(myObject);
</code></pre></div></div>

<h3 id="언패킹-unpacking">언패킹 Unpacking</h3>
<p>수신된 바이트 데이터를 원래 형식으로 변환하는 과정</p>
<ul>
  <li>텍스트 데이터
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">byte</span><span class="o">[]</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">1024</span><span class="o">];</span>
<span class="kt">int</span> <span class="n">bytesRead</span> <span class="o">=</span> <span class="n">inputStream</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">buffer</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">receivedMessage</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">bytesRead</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">);</span>
</code></pre></div>    </div>
  </li>
  <li>객체 데이터 
직렬화된 객체를 수신한 경우, 역직렬화를 통해 원래 객체로 복원한다.
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ObjectInputStream</span> <span class="n">ois</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectInputStream</span><span class="o">(</span><span class="n">socket</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">());</span>
<span class="nc">MyObject</span> <span class="n">myObject</span> <span class="o">=</span> <span class="o">(</span><span class="nc">MyObject</span><span class="o">)</span> <span class="n">ois</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
</code></pre></div>    </div>
  </li>
</ul>

<p><br /></p>

<h1 id="예외">예외</h1>
<h4 id="ioexception">IOException</h4>
<p>데이터 전송 중 연결이 끊어지거나, 네트워크 오류가 발생하는 경우 발생한.
 서버가 다운되거나, 클라이언트와 연결이 갑자기 끊어지는 경우</p>

<h4 id="sockettimeoutexception">SocketTimeoutException</h4>
<p>소켓에서 데이터 수신을 대기하는 동안 일정 시간 내에 응답이 없는 경우다 발생한다.<br />
 소켓에서 타임아웃을 설정할 수 있으며, 타임아웃이 지나면 예외가 발생</p>

<h4 id="unknownhostexception">UnknownHostException</h4>
<p>잘못된 호스트 이름이나 IP주소를 사용하여 소켓을 생성할 때 발생한다.
 호스트 이름을 사용하ㅏ여 소켓을 생성할 때 , 도메인 이름이 잘못되었거나 존재하지 않는 경우 발생한다.
 도메인 이름을 IP 주소로 변환하는 DNS 서버에 문제가 있거나, 네트워크 연결이 끊어지 경우 발생할 수 있다.
 소켓을 생성하기 전 호스트 이름으 유효한지 검증하는 방법을 통해 해당 예외를 예방할 수 있다.
 InetAddress클래스를 사용하여 도메인 이름이 IP 주소로 변환될 수 있는지 미리 확인할 수 있다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">{</span>
    <span class="nc">InetAddress</span> <span class="n">address</span> <span class="o">=</span> <span class="nc">InetAddress</span><span class="o">.</span><span class="na">gettByteName</span><span class="o">(</span><span class="s">"invalid.com"</span><span class="o">);</span>
    <span class="nc">Socket</span> <span class="n">socket</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Socket</span><span class="o">(</span><span class="n">address</span><span class="o">,</span> <span class="mi">8080</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">UnknownHostException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Invalid host name: "</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div>
<p>네트워크 연결이 정상적인지, DNS 서버가 올바르게 동작하는지 확인해야 한다.
 서버 측에서 문제가 발생하는 경우, 네트워크 설정을 점검하고, 필요시 DNS 서버를 변경하거나 네트워크 관리자에게 문의할 수 있다.</p>

<h4 id="bindexception">BindException</h4>
<p>서버 소켓이 이미 사용 중인 포트에 바인딩하려고 할 때 발생한다.
 일반적으로 서버 소켓이 열려고하는 포트가 이미 다른 프로세스에서 사용 중 일때 발생
 리눅스/ 유닉스 기반 시스템에서 권한이 없는 사용자가 1024 이하의 포트 번호에 바인딩하려고 할 때 발생할 수 있다.
 서버 소켓을 생성하기 전에 해당 포트가 이미 사용 중인지 확인하여, 다른 포트를 사용하거나, 사용 중인 포트를 해제한 후 포트를 사용할 수 있다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">{</span>
    <span class="nc">ServerSocket</span> <span class="n">serverSocket</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ServerSocket</span><span class="o">(</span><span class="mi">8080</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">BindException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Port 8080 is already in use. Please choose another port."</span><span class="o">);</span>
    <span class="c1">// 대처: 다른 포트를 선택하거나, 현재 사용 중인 포트를 해제 후 재시도</span>
<span class="o">}</span>
</code></pre></div></div>
<p>1024 이하의 포트를 사용하는 경우, 관리자 권한으로 프로그램을 실행하거나, 관리자 권한을 부여받을 수 있다.</p>

<h4 id="eofexception">EOFException</h4>
<p>클라이언트나 서버가 데이터를 더 이상 전송하지 않을 때 발생한다.
 스트림의 끝을 만나는 경우 발생</p>

<h4 id="classnotfoundexception">ClassNotFoundException</h4>
<p>객체를 역렬화할 때, 해당 클래스가 현재 클래스패스에 존재하지 않는 경우 발생
 주로 네트워크 통신에서 클라이언트와 서버 간의 클래스 버전이 일치하지 않거나 클래스가 누락된 경우 발생한다.
 역직렬화하려는 객체의 클래스가 클래스패스에 존재하는지 확인하고, 네트워크 통신을 하는 클라이언트와 서버가
동일한 클래스 버전을 사용하도록 해야 한다.
 서버와 클라이언트의 JAR 파일 또는 클래스파일이 일치하는지 확인하고, 누락된 클래스가 없는지 점검한다.
 동일한 클래스를 포함한 JAR 파일을 클라이언트와 서버에 모두 배포하여 버전 불일치 문제를 방지한다.
 만약 클라이언트와 서버의 환경이 다른 경우, 서버에서 클라이언트로 클래스 파일을 전송하거나, 
  클래스 로더를 사용해 동적으로 로드할 수 있는 방법을 고려해야 한다.</p>

<p>멀티 채팅
<img src="https://github.com/user-attachments/assets/cac5f24b-2938-4931-a823-4906bd41c9b4" alt="multi.png" /></p>

<p>서버 소켓이 루프를 돌면서 클라이언트가 연결될 때마다 새로운 스레드를 생성한다.
이렇게 생성된 스레드는 클라이언트에서 메세지가 들어올때마다 전체 클라이언트에 브로드캐스트한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

</code></pre></div></div>]]></content><author><name></name></author><category term="Java" /><summary type="html"><![CDATA[Socket 소켓은 TCP/IP 기반의 네트워크 통신에서 데이터 송수신의 마지막 접점을 말한다ㅣ. 네트워크를 통해 두 컴퓨터 간의 데이터 통신을 하고, 클라이언트와 서버 간의 연결을 관리한다.]]></summary></entry></feed>