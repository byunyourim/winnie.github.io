<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-08-12T18:40:06+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Winnie’s Blog</title><subtitle>A website with blog posts and pages</subtitle><entry><title type="html">Blocking IO와 Non-Blocking IO , 동기와 비동기</title><link href="http://localhost:4000/java/2024/08/12/java-blocking.html" rel="alternate" type="text/html" title="Blocking IO와 Non-Blocking IO , 동기와 비동기" /><published>2024-08-12T00:00:00+09:00</published><updated>2024-08-12T00:00:00+09:00</updated><id>http://localhost:4000/java/2024/08/12/java-blocking</id><content type="html" xml:base="http://localhost:4000/java/2024/08/12/java-blocking.html"><![CDATA[<h1 id="blocking">Blocking</h1>
<p><img src="https://github.com/user-attachments/assets/1864c95d-e345-43ed-8604-100e30379bfe" alt="blocking.png" />
현재 스레드(또는 프로세스)가 어떤 작업을 수행할 때, <strong>그 작업이 완료될 때까지 다른 작업을 할 수 없도록 대기하는 상태</strong></p>

<p>제어권이 호출된 함수에게 넘어가서, 함수가 작업을 끝낼때까지 제어권을 유지합니다.<br />
따라서 호출한 함수는 호출된 함수가 끝나기 전까지 다른 작업을 하지 못하고 대기합니다.</p>

<ul>
  <li>파일을 읽거나 쓰는 작업에서 파일 읽기/쓰기가 완료될 때까지 스레드가 대기하는 경우</li>
  <li>네트워크에서 데이터를 받을 때까지 응답을 기다리며 다른 작업을 하지 못하는 경우</li>
</ul>

<h4 id="문제">문제</h4>
<p>입출력 작업이 완료될때 까지 다른 스레드가 대기해야하기 때문에, 멀티 스레드 환경에서 대기 시간이 오래 걸릴 수 있습니다. 
많은 클라이언트의 요청을 동시에 처리할 수 없으며 블록 상태가 발생할 수 있습니다.</p>

<p><br /></p>

<h1 id="non-blocking">Non-Blocking</h1>
<p><img src="https://github.com/user-attachments/assets/4fa1e260-068b-4e24-9c73-cd6c4c14baff" alt="non_blocking.png" />
작업이 즉시 처리되거나, 처리할 수 없는 경우에도 스레드가 <strong>대기하지 않고 다른 작업을 계속할 수 있는 상태</strong></p>

<p>제어권이 호출된 함수에게 넘어갔다가, 즉시 호출한 함수로 돌아옵니다.
호출된 함수가 완료되지 않았지만, 제어권을 바로 반환하기 때문에 호출한 함수는 다른 작업을 계속할 수 있습니다.</p>

<p>A 함수가 B 함수를 호출했을 때, B 함수는 바로 A 함수에게 제어권을 돌려주고, A 함수는 B 함수가 끝날 때까지 기다리지 않고 다른 작업을 할 수 있게 됩니다.</p>

<ul>
  <li>파일이나 네트워크 요청을 보내고, 응답이 준비될 때까지 기다리지 않고 바로 다음 작업을 수행하는 경우</li>
  <li>작업이 완료될 때까지 대기하지 않고, 작업 큐에 넣어 두고 다른 작업을 수행하는 경우</li>
</ul>

<h4 id="문제-1">문제</h4>
<p>복잡하며, 콜백 지옥과 같은 문제가 발생할 수 있고, 이벤트를 기반으로 동작하기 때문에 실행 흐름을 추적하거나 디버깅이 어렵습니다.
비동기 작업이 많아질수록 메모리 사용량이 증가할 수 있습니다.</p>

<p>주로 다수의 클라이언트 요청을 비동기로 처리할 때 사용되며, 웹 서버에서 여러 요청을 동시에 처리하고
IO 작업이 완료될 때까지 기다리지 않고 다른 요청을 처리하는데 유용하게 사용됩니다.
대규모 데이터베이스나 파일 처리에서 비동기 IO는 시스템의 처리량을 향상 시키는데 기여할 수 있습니다.</p>

<p>구현 방법에는 자바스크립트에서 콜백함수를 사용하거나 promise 를 사용하는 방법이 있습니다.
또한 자바의 NIO 와 같은 라이브러리를 사용하여 블로킹 IO 를 비동기적으로 처리할 수 있습니다.</p>

<p><br /></p>

<h1 id="동기">동기</h1>

<p><img src="https://github.com/user-attachments/assets/f8be4407-6199-400c-8a7c-8ca2415beb8a" alt="sync.png" />
작업의 완료를 기다리는 방식으로, <strong>순차적으로 실행</strong>되며 한 작업이 끝나야 다음 작업이 시작될 수 있습니다.</p>

<p>작업의 순서가 보장되며, 코드의 실행 순서가 예측 가능합니다.</p>

<p><br /></p>

<h1 id="비동기">비동기</h1>
<p><img src="https://github.com/user-attachments/assets/4e618758-a40c-4aef-87f6-f71af4d6f1d2" alt="async.png" />
작업의 완료를 기다리지 않는 방식입니다.</p>

<p>작업들이 <strong>병렬로 실행</strong>될 수 있으며, 어떤 작업이 끝날 때까지 기다리지 않고 다른 작업을 수행합니다.
작업 완료는 나중에 별도로 처리되며, 작업이 완료되면 그에 대한 콜백을 받거나, 나중에 결과를 확인합니다.</p>

<p><br /></p>

<blockquote>
  <h4 id="blocking-와-non-blocking">Blocking 와 Non-Blocking</h4>
  <p>함수 호출 후 제어권의 반환 시점</p>

  <h4 id="동기-와-비동기">동기 와 비동기</h4>
  <p>작업 완료 시점에 대한 처리 방식</p>
</blockquote>

<p><br /></p>

<h3 id="promise">Promise?</h3>
<p>비동기 작업의 결과를 나중에 처리할 수 있는 객체로, 작업의 성공(fulfilled) 또는 실패(rejected)를 다룹니다.
비동기 코드를 더 읽기 쉽게 작성하고 에러 처리를 간편하게 할 수 있습니다.
코드가 복잡해질 수 있고 디버깅이 어려워질 수 있습니다. 또한 비동기 작업을 작업을 과ㅏㄴ리하기 위해 메모리를 추가로 소비하기 때문에 많은 
Promise 객체가 생성될 경우 메모리 사용량이 증가합니다.</p>

<p>따라서 모든 비동기에 에러 처리를 해야하며, Promise.all()을 사용할 때, 하나의 Promise라도 실패하면 전체가 실패로 간주되므로, 개별적으로 에러 처리를 할 필요가 있습니다.
Promise 내부에서 또 다른 Promise를 반환하는 경우, 코드가 복잡해질 수 있기 때문 async/await를 사용하는 것이 더 적합할 수 있습니다.</p>

<h3 id="nio-new-io">NIO (New I/O)</h3>
<p>자바의 비동기 IO를 지원하는 API로, 네트워크와 파일 작업을 효율적으로 처리할 수 있게 합니다.
Selector와 Channel을 사용하여 비동기적으로 여러 IO 작업을 관리할 수 있습니다.</p>

<p><br />
<br /></p>

<p><br />
<br /></p>

<h1 id="이벤트-통지-방식">이벤트 통지 방식</h1>
<p><img src="https://github.com/user-attachments/assets/c97d033c-e0dc-4825-8e1c-7e5df74b594e" alt="event.png" /></p>

<h3 id="sync-blocking-io">Sync Blocking I/O</h3>
<p>입력 요청 등 제어권과 처리 결과를 동시에 반환</p>

<ol>
  <li>호출</li>
  <li>블로킹</li>
  <li>처리</li>
</ol>

<p>구현이 간단하고 직관적이며, 스레드가 직적 I/O 작업을 기다리기 때문에 비동기 처리가 필요없습니다.</p>

<h3 id="sync-non-blocking-io">Sync Non-Blocking I/O</h3>
<p>자신의 작업을 하면서 결과가 반환됐는지 확인하는 방식</p>

<p>반환됐을 경우 바로 처리합니다.</p>

<ol>
  <li>호출: 스레드가 I/O 작업을 요청합니다. 요청이 즉시 완료되지 않더라도 스레드는 다른 작업을 계속 진행합니다.</li>
  <li>작업 상태 확인: I/O 작업의 상태를 주기적으로 확인하거나, 결과를 체크합니다.</li>
  <li>처리: 작업이 완료되면 결과를 처리합니다. 이 과정은 동기적으로 이루어집니다.</li>
</ol>

<p>스레드가 다른 작업을 계속 수행할 수 있으므로 자원 효율성이 좋으며, 높은 I/O 성능을 요구하는 어플리케이션에서 효과적입니다.</p>

<h3 id="async-blocking-io">Async Blocking I/O</h3>
<p>비동기적으로 I/O 요청을 시작하고, I/O 작업의 완료를 기다리는 블로킹 방식</p>

<ol>
  <li>비동기 I/O 요청: I/O 작업을 비동기적으로 시작합니다. 요청을 보내고 제어권을 즉시 반환받습니다.</li>
  <li>블로킹 대기: I/O 작업의 결과를 기다리는 동안, 스레드가 블로킹되며 대기합니다.</li>
  <li>결과 처리: I/O 작업이 완료되면, 블로킹된 스레드가 결과를 처리합니다. 이 과정에서 비동기적 요소가 작용할 수 있습니다.</li>
</ol>

<p>비동기 I/O 요청을 통해 자원의 사용 효율성을 높일 수 있으며, 스레드의 효율성을 높일 수 있습니다.</p>

<p>스레드가 블로킹되는 동안 다른 작업을 수행할 수 없기 때문에 자원의 활용도가 떨어질 수 있으며,
비동기 요청과 블로킹 대기 사이의 복잡성을 관리하기 어려울 수 있습니다.</p>

<h3 id="async-non-blocking-io">Async Non-Blocking I/O</h3>
<p>I/O 작업의 완료를 기다리지 않고 다른 작업을 동시에 처리할 수 있는 접근 방식</p>

<p>작업 요청 이후 자신의 작업은 그대로 진행. 결과가 반환되어도 바로 처리하는게 아니라 자기 작업이 끝난 이후에 콜백을 통해 추가 작업</p>

<ol>
  <li>I/O 요청: 스레드는 I/O 작업을 요청하고 즉시 제어권을 반환받습니다. 스레드는 I/O 작업의 완료를 기다리지 않습니다.</li>
  <li>작업 완료 대기: I/O 작업은 비동기적으로 처리되며, 완료 시 콜백 함수나 Future/Promise 객체를 통해 결과를 받습니다.</li>
  <li>결과 처리: I/O 작업이 완료되면, 콜백 함수나 Future/Promise 객체를 통해 결과를 비동기적으로 처리합니다.</li>
</ol>

<p>I/O 작업이 완료될 때까지 스레드가 대기하지 않으므로, 자원 활용도가 높고, 많은 I/O 작업을 동시에 처리할 수 있어 성능이 향상됩니다.
응답 시간이 짧고, 높은 처리량을 달성할 수 있습니다.</p>

<p>비동기 코드의 복잡성이 증가할 수 있습니다.
콜백 지옥(callback hell)이나 상태 관리의 복잡함이 발생할 수 있습니다.</p>]]></content><author><name></name></author><category term="Java" /><summary type="html"><![CDATA[Blocking 현재 스레드(또는 프로세스)가 어떤 작업을 수행할 때, 그 작업이 완료될 때까지 다른 작업을 할 수 없도록 대기하는 상태 제어권이 호출된 함수에게 넘어가서, 함수가 작업을 끝낼때까지 제어권을 유지합니다. 따라서 호출한 함수는 호출된 함수가 끝나기 전까지 다른 작업을 하지 못하고 대기합니다. 파일을 읽거나 쓰는 작업에서 파일 읽기/쓰기가 완료될 때까지 스레드가 대기하는 경우 네트워크에서 데이터를 받을 때까지 응답을 기다리며 다른 작업을 하지 못하는 경우]]></summary></entry><entry><title type="html">CI/CD</title><link href="http://localhost:4000/db/2024/08/06/CI-CD.html" rel="alternate" type="text/html" title="CI/CD" /><published>2024-08-06T00:00:00+09:00</published><updated>2024-08-06T00:00:00+09:00</updated><id>http://localhost:4000/db/2024/08/06/CI-CD</id><content type="html" xml:base="http://localhost:4000/db/2024/08/06/CI-CD.html"><![CDATA[<p>CI/CD 는 코드 변경 사항을 자동으로 빌드, 테스트, 배포하여
소프트웨어 개발과 배포 과정을 효율적이고 안정적으로 만드는 자동화 프로세스입니다.</p>

<p><img src="https://github.com/user-attachments/assets/3ade87c6-121c-477b-9dc0-925548ba6ed5" alt="CICDprocess.png" /></p>

<p><br /></p>

<h2 id="ci-continuous-integration-란">CI (Continuous Integration) 란?</h2>
<p>지속적인 통합이라는 의미로 개발자들이 각자의 작업을 자주 병합하여 통합하는 프로세스 입니다.
병합할 때마다 자동화된 빌드와 테스트가 실행됩니다.</p>

<p>개발자들이 작업한 코드를 자주 메인 브랜치에 병합하거나, 각 코드 변경이 올바르게 작동하는지 확인할 때 사용합니다.</p>

<p>정기적인 통합을 통해 버그를 조기에 발견한고 수정할 수 있으며, 통합 빈도가 높아지면 통합의 복잡성과 충돌이 줄어듭니다.</p>

<p><br /></p>

<h2 id="cd-continuous-delivery-deployment-란">CD (Continuous Delivery/ Deployment) 란?</h2>
<h4 id="continuous-delivery">Continuous Delivery</h4>

<p><strong>지속적인 배포</strong>는 코드가 변경될 때마다 자동으로 프로덕션 환경에 배포하는 프로세스입니다.
모든 변경 사항이 자동으로 배포되며, 개발자의 개입 없이 자동화된 테스트를 통과하면 바로 배포됩니다.</p>

<p>배포를 자동화하여 변경 사항이 가능한 빨리 사용자에겍 전달되도록 하는 것입니다.</p>

<p>빈번하게 배포가 이루어지는 상황이나, 자동화된 테스트를 통과하면 바로 배포할 수 있는 경우 사용합니다.
변경 사항이 프로덕션 환경에 빠르게 반영되기 때문에 사용자의 피드백을 필요로하고 신속하게 반영해야 하는 경우 사용합니다.</p>

<p>모든 변경 사항이 자동으로 배포되기 때문에 엄격한 자동화된 테스트와 모니터링이 필요합니다.</p>

<h5 id="시나리오">시나리오</h5>
<blockquote>
  <ol>
    <li>코드 커밋</li>
    <li>CI 서버가 코드를 빌드하고 자동화된 테스트 실행</li>
    <li>테스트 통과시 자동으로 프로덕션 환경에 배포</li>
  </ol>
</blockquote>

<p><br /></p>

<p><strong>지속적 전달</strong> 은 CI 단계에서 통합된 코드를 언제든 프로덕션 환경에 배포될 수 있도록 준비하는 프로세스입니다.
코드 변경 사항은 자동화된 테스트를 통과하고, 프로덕션 환경에 배포되기 전에 수동 검토 또는 승인 단계를 거칩니다.
따라서 배포 시점에 대한 제어가 가능합니다.</p>

<p>항상 배포 가능 상태를 유지하여, 필요한 경우 즉시 배포할 수 있어야 합니다.</p>

<p>자동화된 테스트를 통과한 후 프로덕션에 배포할 준비가 되어있지만, 최종 배포는 수동으로 이루어질 수 있습니다.</p>

<h5 id="시나리오-1">시나리오</h5>
<blockquote>
  <ol>
    <li>코드 커밋</li>
    <li>CI 서버가 코드를 빌드하고 자동화된 테스트 실행</li>
    <li>테스트 통과시 배포 가능한 상태로 준비</li>
    <li>배포 담당자나 승인자가 최종 검토 후 배포 승인</li>
    <li>프로덕션 환경에 배포</li>
  </ol>
</blockquote>

<p>통합과 배포 시간을 줄임으로서 효율성을 높일 수 있으며 코드의 품질을 높이고 안정성을 유지할 수 있습니다.</p>

<p><br /></p>
<h2 id="ci-cd-종류">CI/ CD 종류</h2>
<ul>
  <li>Jenkins : 오픈 소스 자동화 서버로, 다양한 플러그인을 통해 CI/CD 파이프라인 구축 가능</li>
  <li>CircleCI : 클라우드 기반 CI/CD 서비스</li>
  <li>TravisCI : 오픈 소스 프로젝트에 많이 사용되는 클라우드 기반 CI 서비스</li>
  <li>GitLab CI : GitLab에 내장된 CI/CD 도구로, GitLab 프로젝트와 통합하여 사용</li>
  <li>AWS CodePipeline : AWS 서비스와 통합된 CI/CD 서비스, AWS 환경에서의 배포를 자동화</li>
</ul>

<p>위의 도구들은 코드의 변경 사항을 감지하고, 자동으로 빌드 및 테스트를 수행합니다.
성공적으로 테스트를 통과한 코드를 프로덕션 환경에 배포하는 과정을 지원합니다.</p>]]></content><author><name></name></author><category term="DB" /><summary type="html"><![CDATA[CI/CD 는 코드 변경 사항을 자동으로 빌드, 테스트, 배포하여 소프트웨어 개발과 배포 과정을 효율적이고 안정적으로 만드는 자동화 프로세스입니다.]]></summary></entry><entry><title type="html">Redis란?</title><link href="http://localhost:4000/db/2024/08/06/redis.html" rel="alternate" type="text/html" title="Redis란?" /><published>2024-08-06T00:00:00+09:00</published><updated>2024-08-06T00:00:00+09:00</updated><id>http://localhost:4000/db/2024/08/06/redis</id><content type="html" xml:base="http://localhost:4000/db/2024/08/06/redis.html"><![CDATA[<p><img src="https://github.com/user-attachments/assets/d8ce2343-8f9b-44b8-a9e5-2530f8fa6606" alt="redis.png" /></p>

<h2 id="redis-remote-dictionary-server-란">Redis (Remote dictionary server) 란?</h2>

<p>오픈 소스 인메모리 데이터 구조의 저장소로, 주로 데이터베이스, 캐시, 메시지 브로커로 사용됩니다.
빠른 접근 속도와 다양한 데이터 구조를 지원합니다.</p>

<p>데이터를 메모리에 저장하여 빠른 접근 속도를 제공합니다. 데이터를 메모리에 저장함면 디스크 I/O 를 줄이고, 높은 성능을 유지할 수 있습니다.</p>

<p>키와 값의 구조로 저장되며 비정형 데이터를 저장, 관리합니다.</p>

<h5 id="인메모리">인메모리?</h5>

<h2 id="특징">특징</h2>
<ol>
  <li>인 메모리 저장소
    <blockquote>
      <p>데이터를 디스크가 아닌 RAM 에 저장하여 빠르게 접근하고 처리하는 방법입니다.
빠른 접근 속도를 제공하기 때문에 지연이 적고 응답시간이 빠릅니다.<br />
데이터가 서버의 메모리에 유지되기 때문에 서버가 재부팅되거나 종료되면 데이터가 사라질 수 있습니다.<br />
이를 보완하기 위해 스냅샷, 로그 등 영속성 옵션을 사용할 수 있습니다.</p>
    </blockquote>
  </li>
  <li>
    <p>다양한 데이터 구조
문자열(Strings), 리스트(Lists), 집합(Sets), 
정렬된 집합(Sorted Sets), 해시(Hashes), 비트맵(Bitmaps), 
하이퍼로그로그(HyperLogLogs), 지오스페이셜 인덱스(Geospatial Indexes) 등 다양한 데이터 구조 지원하여,
데이터의 저장과 접근을 유연하게 합니다.</p>
  </li>
  <li>
    <p>영속성
기본적으로 인메모리 데이터 저장소이지만, 데이터의 영속성을 보장할 수 있는 옵션을 제공합니다.
데이터 스냅샷을 디스크에 저장하거나(RDB), 변경 사항을 로그에 기록하여(AOF) 데이터 복구를 지원합니다.</p>
  </li>
  <li>
    <p>고급 기능
Pub/Sub : 메시지 브로커 기능을 제공하여 메시지 전달 및 구독 시스템을 구현할 수 있습니다.
트랜잭션 : 여러 명령어를 원자적으로 실행할 수 있는 기능을 제공합니다.
Lua 스크립팅 : Lua 스크립트를 사용하여 서버 측에서 복잡한 작업을 수행할 수 있습니다.</p>
  </li>
  <li>
    <p>분산 및 클러스터링 지원
레디스는 클러스터 모드와 샤딩 기능을 통해 데이터를 분산 저장하고, 대규모 데이터 처리와 고가용성을 지원합니다.
데이터를 샤딩하여 여러 노드에 분산 저장합니다. 클러스터링을 통해 고가용성과 수평적 확장을 지원합니다.
마스터-슬레이브 복제를 지원하여, 데이터를 여러 슬레이브 노드에 복제합니다. 복제를 통해 읽기 성능을 향상시키고 데이터의 고가용성을 보장합니다.</p>
  </li>
  <li>높은 성능과 확장성
단일 노드에서 수백만 개의 요청 처리</li>
</ol>

<h2 id="사용">사용</h2>
<ol>
  <li>캐시
    <ul>
      <li>자주 조회되는 데이터나 결과를 메모리에 저장하여 데이터베이스의 부하를 줄이고 응답 속도를 빠르게 합니다.</li>
    </ul>
  </li>
  <li>세션 스토리지
    <ul>
      <li>웹 애플리케이션에서 사용자 세션 정보를 저장하고 관리합니다.</li>
    </ul>
  </li>
  <li>실시간 데이터 처리
    <ul>
      <li>실시간으로 데이터를 처리하고 분석하는 데 사용됩니다.</li>
      <li>실시간 채팅 애플리케이션에서 메시지를 처리하거나 실시간 분석 대시보드에서 데이터를 스트리밍합니다.</li>
    </ul>
  </li>
  <li>큐 시스템
    <ul>
      <li>작업 큐나 메시지 큐를 구현하여 비동기 작업을 처리합니다.</li>
    </ul>
  </li>
  <li>순위 시스템
    <ul>
      <li>정렬된 집합을 사용하여 순위 시스템을 구현하고, 순위 기반의 데이터를 관리합니다.</li>
    </ul>
  </li>
</ol>]]></content><author><name></name></author><category term="DB" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">SQL Injection</title><link href="http://localhost:4000/db/2024/08/01/java-sqlinjection.html" rel="alternate" type="text/html" title="SQL Injection" /><published>2024-08-01T00:00:00+09:00</published><updated>2024-08-01T00:00:00+09:00</updated><id>http://localhost:4000/db/2024/08/01/java-sqlinjection</id><content type="html" xml:base="http://localhost:4000/db/2024/08/01/java-sqlinjection.html"><![CDATA[<p>전송 계층에서 사용하는 두 가지 주요 프로토콜</p>

<h1 id="sql-injection">SQL Injection</h1>
<p><span style="background-color:#D0E4FC"><strong>공격자가 보안상의 취약점을 노리고 쿼리에 자신이 작성한 sql 문을 입력하여 데이터베이스가 비정상적으로 동작하도록 하는 공격</strong></span></p>

<p>이 공격을 통해 데이터를 유출하거나, 데이터를 조작할 수 있습니다.</p>

<h3 id="과정">과정</h3>
<p>공격자는 웹 사이트의 입력 필드나 url 파라미터에 sql 인젝션 취약점이 있는지 파악 후, 취약점이 확인되면 쿼리에 악의적인 sql 문을 삽입합니다.
예를 들어 “admin; –” 와 같이 입력함으로써 쿼리를 변경합니다.
이로써 데이터베이스가 의도치 않은 동작을 하게 만들어 사용자의 정보를 유출할 수 있습니다.</p>

<p>이러한 작업을 통해 데이터를 유출할 수 있으며, 특정 사용자의 비밀번호를 변경, 관리자 권한을 얻어 시스텡 서버를 장악할 수 있습니다.
또한 로그인시 비밀번호 검증을 피하여 로그인이 가능합니다.</p>

<h2 id="예방하려면">예방하려면?</h2>
<p>PreparedStatement를 사용하면 드라이버가 자동으로 매개변수 값을 이스케이프 처리하여 SQL Injection 공격을 방지할 수 있습니다.</p>

<p>Hibernate와 같은 ORM 프레임워크를 사용하여 SQL 쿼리 작성을 자동화함으로써 위험을 줄일 수 있습니다.
모든 사용자의 입력을 검증하고 특수문자를 이스케이프 처리합니다.
또한 데이터베이스 권한에 최소한의 권한을 부여하는 것이 좋습니다.</p>

<p>하지만 SQL 쿼리를 동적으로 생성하는 코드에서 PreparedStatement의 파라미터 바인딩을 적절히 사용하지 않으면 여전히 취약점이 발생할 수 있습니다.
그리고 개발자가 입력 값을 제대로 검증하지 않거나, 특히 입력 값이 코드 또는 쿼리 구조의 일부로 사용되는 경우 공격에 노출될 수 있습니다.</p>

<p>따라서 입력 값의 유형, 길이, 형식 등을 철저히 검증해야 하며, 모든 변수는 반드시 PreparedStatement의 파라미터로 바인딩해야 합니다.
필요에 따라 특수 문자를 이스케이프 처리하고, 입력 값이 SQL 구조에 영향을 주지 않도록 합니다.</p>

<p>이러한 방법을 통해 Sql injection를 예방할 수 있습니다.</p>]]></content><author><name></name></author><category term="DB" /><summary type="html"><![CDATA[전송 계층에서 사용하는 두 가지 주요 프로토콜]]></summary></entry><entry><title type="html">LIKE 와 full-scan</title><link href="http://localhost:4000/db/2024/07/22/mysql-index.html" rel="alternate" type="text/html" title="LIKE 와 full-scan" /><published>2024-07-22T00:00:00+09:00</published><updated>2024-07-22T00:00:00+09:00</updated><id>http://localhost:4000/db/2024/07/22/mysql-index</id><content type="html" xml:base="http://localhost:4000/db/2024/07/22/mysql-index.html"><![CDATA[<h2 id="like">LIKE</h2>
<p>LIKE 는 SQL에서 문자열 패턴 매칭을 위해서 사용합니다.
주로 where절에서 특정 패턴과 일치하는 문자열을 검색하는데 사용할 수 있습니다.
하지만 데이터가 많아지는 경우 문제가 생길 수 있습니다.<br />
<br /><br />
<br /></p>

<h2 id="어떤-문제가-생길까">어떤 문제가 생길까??</h2>
<p>LIKE 연산자는 와일드 카드를 사용하여 패턴 매칭을 합니다.
와일드 카드가 패턴의 시작 부분에 위치하면 Mysql의 인덱스를 효과적으로 사용할 수 없습니다.
예를 들어 LIKE ‘%123’ 과 같은 패턴으로 사용하는 경우 인덱스를 사용할 수 없어 성능이 떨어질  있습니다.<br />
<br /><br />
<br /></p>

<h2 id="왜-like-abc-패턴은-인덱스를-사용할-수-없을까">왜 LIKE ‘%abc’ 패턴은 인덱스를 사용할 수 없을까?</h2>
<p>인덱스는 데이터가 정렬된 순서대로 값을 찾을 수 있도록 합니다.
인덱스를 사용하여 검색할 때 왼쪽에서 부터 일치하는 값을 찾습니다.
예를 들어 ‘abc%’와 같은 패턴은 인덱스를 사용할 수 있으나 ‘%abc’ 의 패턴의 경우 시작점이 명화하지 않기 때문에 인덱스를 사용할 수 없습니다.</p>

<p>이와 같은 패턴을 사용하는 경우 패턴 매칭을 위해 모든 데이터를 순차적으로 스캔해야 하기 때문에full table scan이 발생합니다.
데이터의 양이 많을수록 성능에 영향을 미치며, I/O 비용이 많이 발생합니다.<br />
<br />
<br /></p>

<h3 id="-으로-완전일치-검색하는-경우">’=’ 으로 완전일치 검색하는 경우</h3>
<p>인덱스를 사용하여 검색하는 것을 확인할 수 있다.
<img src="https://github.com/user-attachments/assets/5793a69e-48b4-4d3d-8044-9afbd22840b8" alt="img1.png" /><br />
<br /></p>

<h3 id="like를-이용해서-검색하는-경우">LIKE를 이용해서 검색하는 경우</h3>
<p>% 으로 시작하는 문자열을 검색하는 경우 인덱스를 사용하지 않는 것을 확인할 수 있다.
<img src="https://github.com/user-attachments/assets/1695099b-8f1e-4c03-b339-764eb26ddc7e" alt="img2.png" /><br />
<br /></p>

<ul>
  <li>%가 위에 있는 문자열을 검색하는 경우 인덱스를 사용하는 것을 확인할 수 있다.
<img src="https://github.com/user-attachments/assets/3884a4ad-1f26-49d8-a27c-63dbbf8bc682" alt="img3.png" />  <br />
<br /><br />
<br /></li>
</ul>

<h5 id="이제-속도-측면에서-확인해보자">이제 속도 측면에서 확인해보자</h5>

<h3 id="을-사용한-경우">’=’을 사용한 경우</h3>
<p><img src="https://github.com/user-attachments/assets/d44d1cbe-f203-42de-9621-5a6aad4fecee" alt="img_4.png" />
<br /><br />
<br /></p>

<h3 id="like을-사용한-경우">LIKE을 사용한 경우</h3>
<ul>
  <li>
    <p>%를 시작 부분에서 사용하는 경우
<img src="https://github.com/user-attachments/assets/5c493e49-75e5-4574-a4f4-dd8889a46733" alt="img_5.png" /> 
<br /></p>
  </li>
  <li>
    <p>%를 마지막 부분에서 사용하는 경우
<img src="https://github.com/user-attachments/assets/7fd3b0fc-179f-455b-8c5a-5f21e8cacfe8" alt="img_6.png" /></p>
  </li>
</ul>

<p>% 가 앞에 나오는 경우가 속도가 떨어지는 것을 볼 수 있다.</p>]]></content><author><name></name></author><category term="DB" /><summary type="html"><![CDATA[LIKE LIKE 는 SQL에서 문자열 패턴 매칭을 위해서 사용합니다. 주로 where절에서 특정 패턴과 일치하는 문자열을 검색하는데 사용할 수 있습니다. 하지만 데이터가 많아지는 경우 문제가 생길 수 있습니다.]]></summary></entry><entry><title type="html">Transaction 격리수준</title><link href="http://localhost:4000/spring/2024/07/18/transaction-%EA%B2%A9%EB%A6%AC%EC%88%98%EC%A4%80.html" rel="alternate" type="text/html" title="Transaction 격리수준" /><published>2024-07-18T00:00:00+09:00</published><updated>2024-07-18T00:00:00+09:00</updated><id>http://localhost:4000/spring/2024/07/18/transaction-%EA%B2%A9%EB%A6%AC%EC%88%98%EC%A4%80</id><content type="html" xml:base="http://localhost:4000/spring/2024/07/18/transaction-%EA%B2%A9%EB%A6%AC%EC%88%98%EC%A4%80.html"><![CDATA[]]></content><author><name></name></author><category term="Spring" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Transactional과 Proxy</title><link href="http://localhost:4000/spring/2024/07/17/transactional-proxy.html" rel="alternate" type="text/html" title="Transactional과 Proxy" /><published>2024-07-17T00:00:00+09:00</published><updated>2024-07-17T00:00:00+09:00</updated><id>http://localhost:4000/spring/2024/07/17/transactional-proxy</id><content type="html" xml:base="http://localhost:4000/spring/2024/07/17/transactional-proxy.html"><![CDATA[<p>좌석을 선택하고 결제하는 api를 구현하는데 트랜잭션에 대하여 이해가 떨어져서 공부하게 되었다.
개념은 익히 들어서 알고 있지만 온전히 내 것으로 만들지는 못했다.</p>

<p><br /></p>
<h1 id="트랜잭션">트랜잭션?</h1>

<p>일련의 작업들을 하나로 묶어서 처리하는 단위.
트랜잭션이 성공적으로 완료되면 모든 작업이 영구적으로 반영되고, 하나라도 실패하면 모든 작업이 취소됩니다.
데이터의 일관성과 결성을 유지하는 중요한 개념입니다.</p>

<p>트랜잭션의 개념은 많이 들어서 알고 있었지만 내가 완전하게 이해하기는 어려웠다.</p>

<p>콘서트 티켓 예매를 예로 들어보자</p>

<p><br /></p>
<h4 id="상품을-구매하려면-어떻게-해야할까">상품을 구매하려면 어떻게 해야할까?</h4>
<ol>
  <li>상품의 재고를 확인한 후 장바구니에 추가합니다.</li>
  <li>상품을 결제합니다.</li>
  <li>결제가 성공하면 주문을 생성하고 재고를 업데이트합니다.</li>
</ol>

<p><br /></p>
<h3 id="이-과정에서-트랜잭션을-사용하지-않는다고-하면-어떤-문제가-발생할까">이 과정에서 트랜잭션을 사용하지 않는다고 하면 어떤 문제가 발생할까?</h3>
<p>재고가 부족한 상황에서 동시에 여러 사용자가 같은 상품을 구매하려고 하면 재고가 음수가 될 수 있습니다.
또한 결제가 성공했지만 주문 생성이 실패하거나 재고 업데이트가 실패하면 데이터의 일관성이 깨질 수 있습니다.
그리고 결제에는 성공했지만 재고가 부족한 상황에서 주문생성에 실패하면, 사용자는 돈을 지불했지만 주문이 완료되지 않을 수 있습니다.</p>

<p>상품 구매 시스템에서 트랜잭션을 사용하면 여러 단계의 구매 과정을 하나의 단위로 묶어서 처리할 수 있습니다.
모든 단계가 성공적으로 완료됙거나, 도중에 실패하는 경우 모든 변경 사항이 롤백되어 데이터의 무결성과 일관성을 보장할 수 있습니다.
스프링에서는 @Transactional 어노테이션을 사용하여 트랜잭션을 관리할 수 있습니다.</p>

<h3 id="java">Java</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderService</span> <span class="o">{</span>

    <span class="c1">// 코드 생략</span>
    
    <span class="nd">@Transactional</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">orderProcess</span><span class="o">(</span><span class="nc">Long</span> <span class="n">productId</span><span class="o">,</span> <span class="kt">int</span> <span class="n">quantity</span><span class="o">,</span> <span class="nc">PaymentInfo</span> <span class="n">paymentInfo</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Product</span> <span class="n">product</span> <span class="o">=</span> <span class="n">productRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">productId</span><span class="o">).</span><span class="na">orElseThrow</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">(</span><span class="s">"Product not found"</span><span class="o">));</span>

        <span class="c1">// 재고 확인</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">product</span><span class="o">.</span><span class="na">getStock</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">quantity</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"Not enough stock"</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// 결제 처리</span>
        <span class="n">paymentService</span><span class="o">.</span><span class="na">processPayment</span><span class="o">(</span><span class="n">paymentInfo</span><span class="o">);</span>

        <span class="c1">// 재고 감소</span>
        <span class="n">product</span><span class="o">.</span><span class="na">setStock</span><span class="o">(</span><span class="n">product</span><span class="o">.</span><span class="na">getStock</span><span class="o">()</span> <span class="o">-</span> <span class="n">quantity</span><span class="o">);</span>
        <span class="n">productRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">product</span><span class="o">);</span>

        <span class="c1">// 주문 생성</span>
        <span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Order</span><span class="o">();</span>
        <span class="n">order</span><span class="o">.</span><span class="na">setProduct</span><span class="o">(</span><span class="n">product</span><span class="o">);</span>
        <span class="n">order</span><span class="o">.</span><span class="na">setQuantity</span><span class="o">(</span><span class="n">quantity</span><span class="o">);</span>
        <span class="n">order</span><span class="o">.</span><span class="na">setTotalPrice</span><span class="o">(</span><span class="n">product</span><span class="o">.</span><span class="na">getPrice</span><span class="o">()</span> <span class="o">*</span> <span class="n">quantity</span><span class="o">);</span>
        <span class="n">orderRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">order</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>클래스나 메서드에 붙여 해당 범위 내 메서드가 트랜잭션이 되도록 보장합니다.
직접 객체를 생성할 필요없이 선언만으로 관리가 가능합니다.</p>

<p><br /></p>
<h3 id="transactional은-어떻게-동작할까">@Transactional은 어떻게 동작할까?</h3>
<p>메서드의 실행이 시작될 때 트랜잭션이 시작되고, 메서드가 정상적으로 종료되면 트랜잭션이 커밋되며,
예외가 발생하면 트랜잭션이 롤백됩니다.</p>

<ol>
  <li>
    <p>스프링은 @Transactional 어노테이션이 적용된 빈을 프록시 객체로 감쌉니다. <br />
이 프록시는 실제 빈의 메서드를 호출하기 전에 트랜잭션 관련 로직을 처리합니다.</p>
  </li>
  <li>
    <p>프록시는 메서드 호출 전에 트랜잭션을 시작합니다. 이 과정에서 트랜잭션 매니저가 트랜잭션 경계를 설정합니다.</p>
  </li>
  <li>
    <p>실제 메서드가 실행됩니다.</p>
  </li>
  <li>
    <p>메서드가 정상적으로 종료되면 트랜잭션이 커밋되고, 예외가 발생하면 트랜잭션이 롤백됩니다.</p>
  </li>
</ol>

<p>그러면 프록시란 무엇일까?</p>

<p><br /></p>
<h2 id="proxy">Proxy</h2>
<p>프록시는 다른 객체의 대리자로서 동작하는 객체로 실제 객체를 감싸서 부가 기능을 제공합니다. 스프링은 주로 AOP를 통해 트랜잭션 관리를 위해 프록시를 사용합니다.</p>

<p><br /></p>
<h3 id="프록시의-역할">프록시의 역할</h3>
<p>프록시는 실제 객체의 호출 전후에 부가 기능을 추가할 수 있습니다. 예를 들어, 트랜잭션 시작과 종료, 예외 발생 시 롤백 등을 처리합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">public</span> <span class="kd">interface</span> <span class="nc">MyService</span> <span class="o">{</span>
        <span class="kt">void</span> <span class="nf">performTransaction</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Service</span>
    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyServiceImpl</span> <span class="kd">implements</span> <span class="nc">MyService</span> <span class="o">{</span>
        <span class="nd">@Transactional</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">performTransaction</span><span class="o">()</span> <span class="o">{</span>
            <span class="c1">// 트랜잭션 내에서 수행할 작업</span>
         <span class="o">}</span>
    <span class="o">}</span>

       <span class="c1">// 프록시 객체 생성 및 사용</span>
    <span class="nc">MyService</span> <span class="n">myService</span> <span class="o">=</span> <span class="o">(</span><span class="nc">MyService</span><span class="o">)</span> <span class="n">context</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"myService"</span><span class="o">);</span>
    <span class="n">myService</span><span class="o">.</span><span class="na">performTransaction</span><span class="o">();</span>
</code></pre></div></div>
<p>프록시 객체는 실제 MyServiceImpl 객체를 감싸서 트랜잭션 관리를 추가합니다. 클라이언트는 프록시 객체를 통해 트랜잭션이 적용된 메서드를 호출합니다.</p>

<p><br /></p>
<h3 id="프록시-생성-방식">프록시 생성 방식</h3>
<ul>
  <li>
    <p>인터페이스 기반 프록시: 기본적으로 스프링은 JDK 동적 프록시를 사용하여 인터페이스를 구현하는 프록시 객체를 생성합니다.</p>
  </li>
  <li>
    <p>클래스 기반 프록시 (CGLIB): 만약 빈이 인터페이스를 구현하지 않았다면, 스프링은 CGLIB를 사용하여 클래스 기반 프록시를 생성합니다.</p>
  </li>
</ul>

<p><br /></p>
<h3 id="트랜잭션-경계-설정">트랜잭션 경계 설정</h3>
<ul>
  <li>트랜잭션 시작: 프록시는 메서드 실행 전에 PlatformTransactionManager를 사용하여 트랜잭션을 시작합니다.</li>
  <li>트랜잭션 커밋: 메서드가 정상적으로 완료되면 TransactionManager는 트랜잭션을 커밋합니다.</li>
  <li>트랜잭션 롤백: 메서드 실행 중에 체크드 예외 이외의 예외(런타임 예외, 오류)가 발생하면 트랜잭션이 롤백됩니다.</li>
</ul>

<p><br /></p>
<h3 id="트랜잭션-속성">트랜잭션 속성</h3>
<p>@Transactional 어노테이션은 다양한 속성을 통해 트랜잭션의 동작 방식을 조정할 수 있습니다.</p>
<ul>
  <li>propagation: 트랜잭션 전파 방식 (예: REQUIRED, REQUIRES_NEW 등)</li>
  <li>isolation: 트랜잭션 격리 수준 (예: READ_COMMITTED, SERIALIZABLE 등)</li>
  <li>timeout: 트랜잭션이 완료되어야 하는 최대 시간</li>
  <li>readOnly: 읽기 전용 트랜잭션 여부</li>
  <li>rollbackFor: 롤백할 예외 타입</li>
  <li>noRollbackFor: 롤백하지 않을 예외 타입</li>
</ul>

<p><br />
프록시는 @Transactional이 적용된 메서드 호출을 가로채서 트랜잭션 관련 처리를 수행합니다. 이를 통해 개발자는 트랜잭션 관리 로직을 직접 작성하지 않아도 됩니다.
프록시는 다음과 같은 방식으로 트랜잭션을 처리합니다.</p>

<ol>
  <li>메서드 호출 가로채기: 클라이언트가 @Transactional이 적용된 메서드를 호출할 때, 프록시가 이 호출을 가로챕니다.</li>
  <li>트랜잭션 시작: 프록시는 PlatformTransactionManager를 사용하여 트랜잭션을 시작합니다.</li>
  <li>메서드 실행: 실제 메서드를 실행합니다.</li>
  <li>트랜잭션 커밋/롤백: 메서드 실행이 성공하면 트랜잭션을 커밋하고, 예외가 발생하면 트랜잭션을 롤백합니다.
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderService</span> <span class="o">{</span>
    
 <span class="nd">@Autowired</span>
 <span class="kd">private</span> <span class="nc">OrderRepository</span> <span class="n">orderRepository</span><span class="o">;</span>

 <span class="nd">@Transactional</span>
 <span class="kd">public</span> <span class="kt">void</span> <span class="nf">placeOrder</span><span class="o">(</span><span class="nc">Order</span> <span class="n">order</span><span class="o">)</span> <span class="o">{</span>
     <span class="c1">// 트랜잭션 시작</span>
     <span class="n">orderRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">order</span><span class="o">);</span>
     <span class="c1">// 추가 로직</span>
     <span class="c1">// 트랜잭션 커밋</span>
 <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ol>

<p>위의 OrderService 클래스에서 placeOrder 메서드는 @Transactional 애노테이션을 사용하여 트랜잭션 경계를 정의하고 있습니다.<br />
스프링은 이 클래스의 프록시를 생성하여 placeOrder 메서드 호출을 가로채고 트랜잭션을 관리합니다.</p>

<p><br /></p>
<h3 id="프록시가-트랜잭션을-처리하는-과정">프록시가 트랜잭션을 처리하는 과정</h3>
<ol>
  <li>프록시 생성: 스프링이 애플리케이션 컨텍스트를 초기화할 때, OrderService 빈에 대한 프록시를 생성합니다.</li>
  <li>메서드 호출 가로채기: 클라이언트가 placeOrder 메서드를 호출하면 프록시가 이 호출을 가로챕니다.</li>
  <li>트랜잭션 시작: 프록시는 TransactionManager를 사용하여 트랜잭션을 시작합니다.</li>
  <li>실제 메서드 실행: 프록시는 실제 placeOrder 메서드를 호출합니다.</li>
  <li>트랜잭션 커밋/롤백: 메서드가 정상적으로 종료되면 프록시는 트랜잭션을 커밋하고, 예외가 발생하면 트랜잭션을 롤백합니다.</li>
</ol>

<p><br /></p>
<h3 id="트랜잭션이-하는-일을-프록시가-대신하는-이유">트랜잭션이 하는 일을 프록시가 대신하는 이유</h3>
<ol>
  <li>일관성 유지: 트랜잭션은 데이터베이스의 일관성과 무결성을 유지하는 데 중요한 역할을 합니다. 프록시를 사용하면 이러한 트랜잭션 관리 로직을 쉽게 적용할 수 있습니다.</li>
  <li>코드 간결화: 트랜잭션 관리를 코드에서 직접 구현하지 않아도 되므로 코드가 간결해집니다.</li>
  <li>중복 방지: 동일한 트랜잭션 관리 로직을 여러 곳에서 반복해서 작성할 필요가 없습니다.</li>
  <li>AOP 지원: 프록시는 스프링 AOP(Aspect-Oriented Programming)를 사용하여 트랜잭션 관리와 같은 횡단 관심사를 쉽게 구현할 수 있게 해줍니다.</li>
</ol>

<p>프록시는 트랜잭션을 투명하게 처리하여 개발자가 비즈니스 로직에만 집중할 수 있게 해줍니다.</p>

<p>프록시 없이 트랜잭션을 관리하려면, 트랜잭션 시작, 커밋, 롤백을 수동으로 처리해야 합니다. 이것은 상당히 번거롭고 오류가 발생하기 쉬운 작업입니다.</p>

<p><br /></p>
<h4 id="트랜잭션-관리-직접-구현">트랜잭션 관리 직접 구현</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderService</span> <span class="o">{</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">OrderRepository</span> <span class="n">orderRepository</span><span class="o">;</span>
    
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">PlatformTransactionManager</span> <span class="n">transactionManager</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">placeOrder</span><span class="o">(</span><span class="nc">Order</span> <span class="n">order</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">TransactionStatus</span> <span class="n">status</span> <span class="o">=</span> <span class="n">transactionManager</span><span class="o">.</span><span class="na">getTransaction</span><span class="o">(</span><span class="k">new</span> <span class="nc">DefaultTransactionDefinition</span><span class="o">());</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">// 트랜잭션 시작</span>
            <span class="n">orderRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">order</span><span class="o">);</span>
            <span class="c1">// 추가 비즈니스 로직 수행</span>
            
            <span class="c1">// 트랜잭션 커밋</span>
            <span class="n">transactionManager</span><span class="o">.</span><span class="na">commit</span><span class="o">(</span><span class="n">status</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 예외 발생 시 트랜잭션 롤백</span>
            <span class="n">transactionManager</span><span class="o">.</span><span class="na">rollback</span><span class="o">(</span><span class="n">status</span><span class="o">);</span>
            <span class="k">throw</span> <span class="n">ex</span><span class="o">;</span>  <span class="c1">// 예외 재발생</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="프록시-없이-트랜잭션-관리의-문제점">프록시 없이 트랜잭션 관리의 문제점</h3>
<ol>
  <li>복잡성 증가: 트랜잭션을 시작하고, 커밋하거나 롤백하는 코드가 모든 트랜잭션 메서드에 반복적으로 작성되어야 합니다.</li>
  <li>오류 가능성: 트랜잭션 시작, 커밋, 롤백 로직을 수동으로 관리하다 보면 실수로 빠뜨리거나 잘못 구현할 가능성이 높습니다.</li>
  <li>비즈니스 로직과 트랜잭션 로직의 혼합: 비즈니스 로직과 트랜잭션 관리 로직이 같은 메서드에 섞여 있어 코드가 지저분해지고 유지보수가 어려워집니다.</li>
  <li>재사용성 부족: 트랜잭션 관리 로직을 재사용하기 어렵고, 모든 트랜잭션이 필요한 메서드에서 중복 코드가 발생합니다.</li>
</ol>

<h3 id="프록시를-사용할-때의-장점">프록시를 사용할 때의 장점</h3>
<ol>
  <li>코드 간결성: 트랜잭션 관리 로직을 각 메서드에 작성할 필요 없이 @Transactional 애노테이션을 사용하여 트랜잭션 경계를 지정할 수 있습니다.</li>
  <li>오류 감소: 스프링이 트랜잭션 관리를 대신 처리하므로, 개발자가 실수로 트랜잭션 관리 로직을 잘못 구현할 가능성이 줄어듭니다.</li>
  <li>비즈니스 로직 집중: 트랜잭션 관리 로직이 분리되어 비즈니스 로직에 집중할 수 있습니다.</li>
  <li>재사용성 향상: 트랜잭션 관리 로직을 재사용할 수 있고, 코드 중복이 줄어듭니다.
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderService</span> <span class="o">{</span>

 <span class="nd">@Autowired</span>
 <span class="kd">private</span> <span class="nc">OrderRepository</span> <span class="n">orderRepository</span><span class="o">;</span>

 <span class="nd">@Transactional</span>
 <span class="kd">public</span> <span class="kt">void</span> <span class="nf">placeOrder</span><span class="o">(</span><span class="nc">Order</span> <span class="n">order</span><span class="o">)</span> <span class="o">{</span>
     <span class="n">orderRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">order</span><span class="o">);</span>
     <span class="c1">// 추가 비즈니스 로직 수행</span>
 <span class="o">}</span>
<span class="o">}</span> 
</code></pre></div>    </div>
  </li>
</ol>

<p>스프링이 프록시를 통해 트랜잭션 시작, 커밋, 롤백을 자동으로 처리하므로 개발자는 비즈니스 로직에만 집중할 수 있습니다.</p>

<p>@Transactional 애노테이션을 이용하면 스프링 프레임워크가 프록시를 통해 트랜잭션 관리를 대신해 줍니다. 
이를 이해하기 위해서는 스프링의 AOP (Aspect-Oriented Programming) 개념과 프록시 패턴을 이해하는 것이 중요합니다.</p>

<p><br /></p>
<h3 id="transactional과-프록시의-관계">@Transactional과 프록시의 관계</h3>
<ol>
  <li>
    <p>AOP와 프록시 패턴: 스프링은 AOP를 이용하여 @Transactional 애노테이션을 적용할 때 프록시 패턴을 사용합니다. <br />
AOP는 관점 지향 프로그래밍을 의미하며, 코드의 특정 관점에서의 공통된 기능을 분리하여 관리하는 기술입니다.</p>
  </li>
  <li>
    <p>프록시의 역할: @Transactional 애노테이션이 붙은 메서드가 호출될 때, 스프링 프레임워크는 그 메서드를 호출하기 전후에 추가적인 작업을 수행하기 위해 프록시 객체를 생성합니다. <br />
이 프록시 객체는 원본 객체(서비스 클래스)를 감싸며, 트랜잭션 관리와 같은 공통된 기능을 제공합니다.</p>
  </li>
  <li>
    <p>트랜잭션 관리: @Transactional 애노테이션이 붙은 메서드에서는 트랜잭션을 시작하고, 메서드 실행을 감싸는 프록시가 트랜잭션을 커밋 또는 롤백합니다. <br />
이 과정에서 데이터베이스 연산의 성공 또는 실패에 따라 트랜잭션을 적절하게 처리합니다.</p>
  </li>
  <li>
    <p>간편한 설정: 개발자는 @Transactional 애노테이션을 사용하여 간편하게 트랜잭션 경계를 정의할 수 있습니다. <br />
이는 개발자가 직접 트랜잭션을 시작하고, 커밋 또는 롤백하는 코드를 작성하지 않아도 되게 만듭니다.</p>
  </li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderService</span> <span class="o">{</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">OrderRepository</span> <span class="n">orderRepository</span><span class="o">;</span>

    <span class="nd">@Transactional</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">placeOrder</span><span class="o">(</span><span class="nc">Order</span> <span class="n">order</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 비즈니스 로직 수행</span>
        <span class="n">orderRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">order</span><span class="o">);</span>
        <span class="c1">// 추가적인 데이터베이스 작업 등</span>
    <span class="o">}</span>

    <span class="c1">// 다른 트랜잭션 메서드</span>
    <span class="nd">@Transactional</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">cancelOrder</span><span class="o">(</span><span class="nc">Order</span> <span class="n">order</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">order</span><span class="o">.</span><span class="na">setStatus</span><span class="o">(</span><span class="nc">OrderStatus</span><span class="o">.</span><span class="na">CANCELED</span><span class="o">);</span>
        <span class="n">orderRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">order</span><span class="o">);</span>
        <span class="c1">// 추가적인 로직 수행</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이 예시에서 @Transactional 애노테이션이 붙은 placeOrder()와 cancelOrder() 메서드는 스프링 프록시가 관리하는 트랜잭션 범위에서 실행됩니다. <br />
메서드 내의 모든 데이터베이스 연산은 하나의 트랜잭션으로 묶이며, 이 트랜잭션은 메서드 실행 완료 후 자동으로 커밋 또는 롤백됩니다.</p>

<p>따라서 @Transactional을 이용하면 개발자는 트랜잭션 관리에 대한 복잡한 코드를 작성하지 않아도 되며, 스프링 프록시가 이를 대신 처리하여 코드의 간결성과 유지보수성을 높여줍니다.</p>]]></content><author><name></name></author><category term="Spring" /><summary type="html"><![CDATA[좌석을 선택하고 결제하는 api를 구현하는데 트랜잭션에 대하여 이해가 떨어져서 공부하게 되었다. 개념은 익히 들어서 알고 있지만 온전히 내 것으로 만들지는 못했다.]]></summary></entry><entry><title type="html">Transaction</title><link href="http://localhost:4000/spring/2024/07/17/transaction.html" rel="alternate" type="text/html" title="Transaction" /><published>2024-07-17T00:00:00+09:00</published><updated>2024-07-17T00:00:00+09:00</updated><id>http://localhost:4000/spring/2024/07/17/transaction</id><content type="html" xml:base="http://localhost:4000/spring/2024/07/17/transaction.html"><![CDATA[<h1 id="트랜잭션">트랜잭션?</h1>

<p>일련의 작업들을 하나로 묶어서 처리하는 단위.
트랜잭션이 성공적으로 완료되면 모든 작업이 영구적으로 반영되고, 하나라도 실패하면 모든 작업이 취소됩니다.
데이터의 일관성과 결성을 유지하는 중요한 개념입니다.</p>

<p>트랜잭션의 개념은 많이 들어서 알고 있었지만 내가 완전하게 이해하기는 어려웠다.</p>

<p>콘서트 티켓 예매를 예로 들어보자</p>

<h3 id="상품을-구매하려면-어떻게-해야할까">상품을 구매하려면 어떻게 해야할까?</h3>
<ol>
  <li>상품의 재고를 확인한 후 장바구니에 추가합니다.</li>
  <li>상품을 결제합니다.</li>
  <li>결제가 성공하면 주문을 생성하고 재고를 업데이트합니다.</li>
</ol>

<h3 id="이-과정에서-트랜잭션을-사용하지-않는다고-하면-어떤-문제가-발생할까">이 과정에서 트랜잭션을 사용하지 않는다고 하면 어떤 문제가 발생할까?</h3>
<p>재고가 부족한 상황에서 동시에 여러 사용자가 같은 상품을 구매하려고 하면 재고가 음수가 될 수 있습니다.
또한 결제가 성공했지만 주문 생성이 실패하거나 재고 업데이트가 실패하면 데이터의 일관성이 깨질 수 있습니다.
그리고 결제에는 성공했지만 재고가 부족한 상황에서 주문생성에 실패하면, 사용자는 돈을 지불했지만 주문이 완료되지 않을 수 있습니다.</p>

<p>상품 구매 시스템에서 트랜잭션을 사용하면 여러 단계의 구매 과정을 하나의 단위로 묶어서 처리할 수 있습니다.
모든 단계가 성공적으로 완료됙거나, 도중에 실패하는 경우 모든 변경 사항이 롤백되어 데이터의 무결성과 일관성을 보장할 수 있습니다.
스프링에서는 @Transactional 어노테이션을 사용하여 트랜잭션을 관리할 수 있습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderService</span> <span class="o">{</span>

    <span class="c1">// 코드 생략</span>
    
    <span class="nd">@Transactional</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">orderProcess</span><span class="o">(</span><span class="nc">Long</span> <span class="n">productId</span><span class="o">,</span> <span class="kt">int</span> <span class="n">quantity</span><span class="o">,</span> <span class="nc">PaymentInfo</span> <span class="n">paymentInfo</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Product</span> <span class="n">product</span> <span class="o">=</span> <span class="n">productRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">productId</span><span class="o">).</span><span class="na">orElseThrow</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">(</span><span class="s">"Product not found"</span><span class="o">));</span>

        <span class="c1">// 재고 확인</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">product</span><span class="o">.</span><span class="na">getStock</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">quantity</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"Not enough stock"</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// 결제 처리</span>
        <span class="n">paymentService</span><span class="o">.</span><span class="na">processPayment</span><span class="o">(</span><span class="n">paymentInfo</span><span class="o">);</span>

        <span class="c1">// 재고 감소</span>
        <span class="n">product</span><span class="o">.</span><span class="na">setStock</span><span class="o">(</span><span class="n">product</span><span class="o">.</span><span class="na">getStock</span><span class="o">()</span> <span class="o">-</span> <span class="n">quantity</span><span class="o">);</span>
        <span class="n">productRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">product</span><span class="o">);</span>

        <span class="c1">// 주문 생성</span>
        <span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Order</span><span class="o">();</span>
        <span class="n">order</span><span class="o">.</span><span class="na">setProduct</span><span class="o">(</span><span class="n">product</span><span class="o">);</span>
        <span class="n">order</span><span class="o">.</span><span class="na">setQuantity</span><span class="o">(</span><span class="n">quantity</span><span class="o">);</span>
        <span class="n">order</span><span class="o">.</span><span class="na">setTotalPrice</span><span class="o">(</span><span class="n">product</span><span class="o">.</span><span class="na">getPrice</span><span class="o">()</span> <span class="o">*</span> <span class="n">quantity</span><span class="o">);</span>
        <span class="n">orderRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">order</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>클래스나 메서드에 붙여 해당 범위 내 메서드가 트랜잭션이 되도록 보장합니다.
직접 객체를 생성할 필요없이 선언만으로 관리가 가능합니다.</p>

<h3 id="트랜잭션의-특징">트랜잭션의 특징</h3>
<ol>
  <li>
    <p>Atomicity 원자성 <br />
한 트랜잭션 내의 모든 연산들이 완전히 수행되거나 전혀 수행되지 않습니다. ( All or Nothing )</p>
  </li>
  <li>
    <p>Consistency 일관성 <br />
어떤 트랜잭션이 수행되기 전에 데이터베이스가 일관된 상태를 가졌다면 트랜잭션이 수행된 후에 일관된 상태를 갖습니다.</p>
  </li>
  <li>
    <p>Isolation 격리성 or 고립 <br />
여러 트랜잭션이 동시에 실행될 때 각 트랜잭션은 다른 트랜잭션의 영향을 받지않고 독립적으로 실행되어야 합니다.</p>
  </li>
  <li>
    <p>Durability 영속성 <br />
성공적으로 완료된 트랜잭션의 결과를 영구적으로 보존해야 합니다.</p>
  </li>
</ol>

<h3 id="영속성-컨텍스트persistence-context">영속성 컨텍스트(Persistence Context)</h3>
<p>영속성 컨텍스트는 엔티티(Entity) 객체를 관리하는 환경</p>

<p>주로 ORM 프레임워크에서 사용되며, 데이터베이스로부터 엔티티를 읽어올 때 영속성 컨텍스트에 저장하고, 엔티티의 상태 변경을 추적하여 데이터베이스에 동기화하는 기능을 제공합니다.</p>

<ol>
  <li>
    <p>엔티티의 생명주기<br />
영속성 컨텍스트는 엔티티의 생명주기를 관리합니다. 엔티티 객체가 생성되어 영속성 컨텍스트에 저장되면 ‘영속 상태’가 되며, 데이터베이스와 동기화됩니다. 수정된 엔티티는 트랜잭션이 커밋될 때 자동으로 데이터베이스에 반영됩니다.</p>
  </li>
  <li>
    <p>지연 로딩(Lazy Loading)<br />
영속성 컨텍스트는 지연 로딩을 지원하여, 연관된 엔티티 객체를 실제로 사용할 때까지 데이터베이스 조회를 지연시킬 수 있습니다. 이는 성능 최적화에 도움을 줍니다.</p>
  </li>
  <li>
    <p>동일성 보장<br />
영속성 컨텍스트는 동일한 엔티티 식별자를 가진 객체에 대해 같은 인스턴스를 반환하여 동일성을 보장합니다.</p>
  </li>
</ol>

<h3 id="트랜잭션과-영속성-컨텍스트의-상호작용">트랜잭션과 영속성 컨텍스트의 상호작용</h3>
<p>트랜잭션과 영속성 컨텍스트는 서로 긴밀하게 연결되어 있습니다</p>

<ol>
  <li>
    <p>트랜잭션 범위: 트랜잭션은 데이터베이스 작업을 논리적 단위로 묶어주며, 트랜잭션 내에서 영속성 컨텍스트는 엔티티의 상태 변경을 추적합니다. 
트랜잭션 커밋 시 영속성 컨텍스트는 데이터베이스에 변경 사항을 반영하고, 롤백 시 변경 사항을 취소합니다.</p>
  </li>
  <li>
    <p>트랜잭션의 격리 수준: 트랜잭션 격리 수준(Transaction Isolation Level)은 여러 트랜잭션이 동시에 실행될 때의 동작을 제어합니다. 
높은 격리 수준일수록 동시성 문제를 줄일 수 있지만, 성능 저하가 발생할 수 있습니다.</p>
  </li>
  <li>
    <p>플러시(Flushing): 영속성 컨텍스트의 변경 사항을 데이터베이스에 동기화하는 작업을 플러시라고 합니다. 
일반적으로 트랜잭션 커밋 시 자동으로 플러시가 발생합니다.</p>
  </li>
</ol>

<p>결론적으로 영속성 컨텍스트는 엔티티의 생명주기를 관리하고, 트랜잭션은 데이터베이스 작업을 단위로 묶어 원자적인 실행을 보장합니다. 
이 두 개념을 잘 이해하고 활용함으로써 데이터베이스 작업의 일관성과 동시성을 유지할 수 있습니다.</p>

<h3 id="트랜잭션의-활용">트랜잭션의 활용</h3>
<ul>
  <li>
    <p>데이터베이스 상태 변경 
예를 들어, 사용자가 새로운 주문을 생성할 때, 주문 내역을 데이터베이스에 반영하는 작업은 하나의 트랜잭션으로 묶입니다.
이 경우 주문 생성, 결제 정보 저장, 재고 조정 등 여러 개의 데이터베이스 작업이 하나의 원자적인 작업 단위로 묶이게 됩니다.</p>
  </li>
  <li>
    <p>예외 처리와 롤백 
트랜잭션은 예외 상황이 발생했을 때 데이터베이스 상태를 롤백하여 이전 상태로 복원하는 데 사용됩니다. 
예를 들어, 주문 생성 중 결제 과정에서 오류가 발생하면, 주문과 관련된 모든 변경 사항을 취소하고 이전 상태로 돌아가게 됩니다.</p>
  </li>
  <li>
    <p>동시성 제어 
트랜잭션은 동시에 여러 사용자가 동일한 데이터에 접근할 때 발생할 수 있는 문제를 방지합니다. 
여러 사용자가 동시에 주문을 생성하려고 할 때, 트랜잭션을 이용하여 충돌을 방지하고 일관성 있는 데이터 처리를 보장할 수 있습니다.</p>
  </li>
  <li>
    <p>복잡한 비즈니스 로직 처리 
복잡한 비즈니스 로직을 처리할 때도 트랜잭션을 활용할 수 있습니다. 
여러 개의 서비스 호출이나 데이터 조작 작업을 하나의 트랜잭션으로 묶어서 실행하면, 데이터 일관성을 유지하면서 원자적으로 처리할 수 있습니다.</p>
  </li>
  <li>
    <p>권한 관리 및 보안 
트랜잭션을 이용하여 데이터베이스 접근 권한을 관리할 수 있습니다. 
트랜잭션을 시작할 때 권한을 확인하고, 트랜잭션이 종료될 때 권한을 제거하는 등의 작업을 통해 보안을 강화할 수 있습니다.</p>
  </li>
</ul>]]></content><author><name></name></author><category term="Spring" /><summary type="html"><![CDATA[트랜잭션?]]></summary></entry><entry><title type="html">JWT</title><link href="http://localhost:4000/spring/2024/07/02/spring-jwt.html" rel="alternate" type="text/html" title="JWT" /><published>2024-07-02T00:00:00+09:00</published><updated>2024-07-02T00:00:00+09:00</updated><id>http://localhost:4000/spring/2024/07/02/spring-jwt</id><content type="html" xml:base="http://localhost:4000/spring/2024/07/02/spring-jwt.html"><![CDATA[<p>프로젝트 중에 JWT를 사용하여서
잘 몰라서.. 공부하고자</p>

<h2 id="이전에는">이전에는?</h2>
<p>JWT가 보급되기 전에는 주로 세션 기반 인증 방식이 사용되었습니다.</p>

<p>세션의 Stateful 로 상태를 유지하는 것이 특징입니다.
세션 기반 인증은 사용자의 정보를 서버에 저장하고, 클라이언트는 세션ID를 통해
인증 상태를 유지하는 방식입니다.</p>

<p>세션은 서버 메모리나 데이터베이스에 저장되어야하기 때문에 서버 측에서 상태를 유지해야합니다.
매 요청맏마 서버와 통신해야하기 때문에 부하가 초래됩니다.</p>

<p>이러한 문제로 등장한 것이 JWT로 Stateless 인 것이 특징입니다.</p>

<h2 id="jwt">JWT</h2>
<p>JSON Web Token의 약자로 정보를 JSON 형태로 클라이언트에 저장하고 서버는 해당 토큰을 검증하여
인증을 처리하는 방식입니다.</p>

<p>토큰 안에 미리 인증에 필요한 정보를 넣어두며 매 요청마다 서버와 통신할 필요가 없습니다.
이로 인해 서버 부하와 같은 문제를 해결할 수 있습니다.</p>

<h2 id="구조">구조</h2>
<p>헤더, 페이로드, 서명 세 부분으로 구성됩니다.
헤더 부분은 알고리즘 방식과 토큰의 타입을 지합니다. 서명 생성을 위해 어떤 알고리즘을 사용할지 식별하는 부분입니다.
페이로드는 클레임이라고 불리는 정보 조각을 포함합니다.
클레임은 토큰에 추가할 정보를 의미하며 사용자 ID, 권한 정보등이 포함될 수 있습니다.
하지만 디코딩을 통해 들어있는 정보를 확이할 수 있기 때문에 민감한 정보는 포함하지 않는 것이 좋습니다.</p>

<p>서명은 토큰을 인코딩하거나 유효성 검증을 위해서 사용되는 부분으로,
헤더와 페이로드를 합친 후 비밀키를 사용하여 생성합니다.</p>

<p>서버는 클라이언트로부터 받은 토큰을 검증하기 위해 서명 부분을 해싱알고리즘과 비밀키로 다시 생성하고
이를 클라이언트가 전달한 서명과 비교합니다.
일치라면 인증이 유요한 것으로 판단합니다.</p>]]></content><author><name></name></author><category term="Spring" /><summary type="html"><![CDATA[프로젝트 중에 JWT를 사용하여서 잘 몰라서.. 공부하고자]]></summary></entry><entry><title type="html">영속성 컨텍스</title><link href="http://localhost:4000/jpa/2024/07/01/jpa-%EC%98%81%EC%86%8D%EC%84%B1%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8.html" rel="alternate" type="text/html" title="영속성 컨텍스" /><published>2024-07-01T00:00:00+09:00</published><updated>2024-07-01T00:00:00+09:00</updated><id>http://localhost:4000/jpa/2024/07/01/jpa-%EC%98%81%EC%86%8D%EC%84%B1%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8</id><content type="html" xml:base="http://localhost:4000/jpa/2024/07/01/jpa-%EC%98%81%EC%86%8D%EC%84%B1%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8.html"><![CDATA[<h2 id="영속성-컨텍스트">영속성 컨텍스트</h2>
<p>JPA 는 영속성 컨텍스트라는 작은 메모리 공간을 가지고 있습니다. 이 영속성 컨텍스트는 엔티티 매니저의 생명주기와 일치하며, 엔티티를 관리하고 데이터베이스와 통신을 처리합니다.</p>

<p>하나의 영속성 컨텍스트는 트랜잭션 단위로 관리되며, 엔티티의 상태를 추적하고 엔티티를 데이터베이스와 동기화합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Service</span>
<span class="nd">@Transactional</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserService</span> <span class="o">{</span>
    
    <span class="nd">@PersistenceContext</span>
    <span class="kd">private</span> <span class="nc">EntityManager</span> <span class="n">em</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">saveUser</span><span class="o">(</span><span class="nc">User</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 엔티티를 영속성 컨텍스트에 저장</span>
        <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="nc">User</span> <span class="nf">findUser</span><span class="o">(</span><span class="nc">Long</span> <span class="n">userId</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// 1차 캐시에서 엔티티를 조회 (데이터베이스 조회 필요 없음)em.find(User.class, user.getId()) 는 JPA 에서 제공하는 메서드로 데이터베이스에 접근하여</span>
      <span class="k">return</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">User</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">userId</span><span class="o">);</span>
      <span class="n">지정된</span> <span class="n">엔티티</span> <span class="n">클래스와</span> <span class="n">키를</span> <span class="n">기반으로</span> <span class="n">엔티티를</span> <span class="n">조회합니다</span><span class="o">.</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">updateUser</span><span class="o">(</span><span class="nc">User</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// 엔티티의 상태 변경 (Dirty Checking)</span>
      <span class="nc">User</span> <span class="n">managedUser</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">User</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">user</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
      <span class="n">managedUser</span><span class="o">.</span><span class="na">setUsername</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">getUsername</span><span class="o">());</span>
      <span class="n">managedUser</span><span class="o">.</span><span class="na">setEmail</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">getEmail</span><span class="o">());</span>

      <span class="c1">// 트랜잭션이 커밋될 때 데이터베이스에 자동으로 반영됨이로써 반복적으로 조죄할 때 데이터베이스에 대한 추가적인 조회를 피할 수 있으며 성능이 향상됩니다.</span>
    <span class="o">}</span>    
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">deleteUser</span><span class="o">(</span><span class="nc">Long</span> <span class="n">userId</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 1캐시는 영속성 컨텍스트의 생명주기에 의존하기 때문에 트랜잭션이 종료되면 1차 캐시도 함께 종료됩니다. </span>
        <span class="c1">// 엔티티를 영속성 컨텍스트에서 제거</span>
        <span class="c1">// 이후에 같은 엔티티를 조회할 경 다시 데이터베이스에서 조회해야 합니다.</span>
        <span class="nc">User</span> <span class="n">user</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">User</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">userId</span><span class="o">);</span>
        <span class="n">em</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>
        <span class="c1">// 트랜잭션이 커밋될 때 데이터베이스에서 삭제됨</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="1차-캐시">1차 캐시</h4>
<p>영속성 컨텍스트의 일부로 JVM 메모리에 위치합니다. 따라서 데이터베이스에 접근하는 것보다 훨씬 빠른 접근이 가능합니다다.
엔티티의 식별자를 키로 사용하여 엔티티를 저장합니다. 이 식별자를 사용하여 빠르게 엔티티를 조회할 수 있습니다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">public</span> <span class="nc">User</span> <span class="nf">findUser</span><span class="o">(</span><span class="nc">Long</span> <span class="n">userId</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 1차 캐시에서 엔티티를 조회 (데이터베이스 조회 필요 없음)</span>
        <span class="k">return</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">User</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">userId</span><span class="o">);</span>
    <span class="o">}</span>
</code></pre></div></div>
<p>em.find(User.class, user.getId()) 메서드는 데이터베이스에서 엔티티를 조회하고 이 엔티티를 영속성 컨텍스트에 저장합니다.
이때 저장된 엔티티는 1차 캐시에 저장됩니다.
이후 동일한 엔티티를 다시 조회하는 경우 영속성 컨텍스트에서 먼저 조회하여 데이터베이스에 접근하지 않고 1차 캐시에 저장된 엔티티를 반환합니다.</p>

<p>1차 캐시를 통해 동일한 엔티티를 반복적으로 조회할 때 데이터베이스에 대한 추가적인 조회를 피할 수 있습니다
영속성 컨텍스트는 트랜잭션 범위 내에서 관리되기 때문 동일한 엔티티에 대해 일관된 상태를 유지할 수 있습니다.</p>

<p>하지만 컨텍스트의 생명주기에 의존하기 때문에 트랜잭션이 종료되면 1차 캐시도 함께 종료됩니다.
따라섯 이후에 같은 엔티티를 조회할 때는 다시 데이터베이스에서 조회해야 합니다.</p>

<p>1차 캐시는 멤모리에 저장되기 때문에 많은 수의 엔티티를 동시에 처리하 할 때 메모리 사용에 주의해야 합니다.</p>

<h4 id="지연-로딩">지연 로딩</h4>
<p>연관된 엔티티나 컬렉션을 실제로 사용할 때까지 데이터베이스에서 로딩하지 않고 필요한 시점에 로딩하는 기능입니다.</p>

<p>지연로딩은 FetchType.LAZY로 설정하며, 실제 엔티티가 필요한 시점에 데이터베이스에서 조회합니다.</p>

<p>반면에 즉시로딩(FetchType.EAGER)은 엔티티를 조회할 때 연관된 엔티티들을 즉시 한번에 조회합니다. 이는 성능 저하를 초래할 수 있으므로 주의해서 사용해야 합니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Entity
@Table(name = "orders")
public class Order {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "order_id")
    private Long id;

    @ManyToOne(fetch = LAZY)
    @JoinColumn(name = "user_id")
    private User user;

}
</code></pre></div></div>
<p>단순한 관계나 적은 데이터 양을 다룰 때는 즉시로딩을 사용하는 것이 좋습니다.
대규모 데이터를 다루거나 성능 최적화가 필요한 경우에는 지연로딩을 고려해야 합니다.
기본적으로는 지연로딩을 사용하고, 성능 문제나 데이터 접근 패턴에 따라 필요할 때 즉시로딩으로 변경하는 것이 바람직합니다.</p>

<h4 id="변경-감지">변경 감지</h4>
<p>트랜잭션 내에서 엔티티의 상태 변경을 감지하여 자동으로 데이터베이스와 동기화합니다.</p>

<p>트랜잭션 내에서 엔티티의 수정이 이루어져야 변경 감지가 동작합니다. 트랜잭션이 커밋될 때 변경 사항이 데이터베이스에 반영됩니다.
트랜잭션이 커밋되기 전까지는 데이터베이스에 변경 사항이 반영되지 않습니다.</p>
<pre><code class="language-java{">    @PersistenceContext
    private EntityManager entityManager;

    public void updateProduct(Long productId, String newName, double newPrice) {
        // 엔티티 조회
        Product product = entityManager.find(Product.class, productId);

        // 엔티티 수정
        product.setName(newName);
        product.setPrice(newPrice);

        // 변경 감지가 발생하여 자동으로 데이터베이스에 반영됨
    }
}
</code></pre>
<p>별도의 save 메서드 호출이 필요하지 않습니다.</p>

<h4 id="트랜잭션-범위">트랜잭션 범위</h4>
<p>영속성 컨텍스트는 트랜잭션 범위 내에서 엔티티를 관리하므로, 트랜잭션이 커밋되거나 롤백되기 전까
엔티티의 변경 사항을 추적하고 커밋할 때 최종적으로 데이터베이스에 반영합니다.</p>]]></content><author><name></name></author><category term="JPA" /><summary type="html"><![CDATA[영속성 컨텍스트 JPA 는 영속성 컨텍스트라는 작은 메모리 공간을 가지고 있습니다. 이 영속성 컨텍스트는 엔티티 매니저의 생명주기와 일치하며, 엔티티를 관리하고 데이터베이스와 통신을 처리합니다.]]></summary></entry></feed>