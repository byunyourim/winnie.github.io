<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-08-22T13:15:51+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Winnie’s Blog</title><subtitle>A website with blog posts and pages</subtitle><entry><title type="html">프로세스의 상태</title><link href="http://localhost:4000/os/2024/08/20/os-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4.html" rel="alternate" type="text/html" title="프로세스의 상태" /><published>2024-08-20T00:00:00+09:00</published><updated>2024-08-20T00:00:00+09:00</updated><id>http://localhost:4000/os/2024/08/20/os-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4</id><content type="html" xml:base="http://localhost:4000/os/2024/08/20/os-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4.html"><![CDATA[<h2 id="process">Process</h2>
<p>실행 중인 프로그램으로 CPU에서 명령을 수행하기 위한 데이터와 상태 정보를 포함한다.
하나의 프로그램은 여러 개의 프로세스를 가질 수 있고, 각 프로세스는 독립적으로 실행된다.</p>

<p><br /></p>

<h2 id="상태">상태</h2>
<p><img src="https://github.com/user-attachments/assets/61b814de-ba75-4f83-bf4d-6b1203d57ac8" alt="process_status.png" /></p>

<h3 id="new">New</h3>
<p>프로세스가 생성된 상태</p>
<h3 id="ready">Ready</h3>
<p>프로세스가 CPU에 실행되기 위해 대기하는 상태로, CPU자원이 할당되지 않은 상태</p>
<h3 id="running">Running</h3>
<p>프로세스가 CPU를 할당받아 실제로 실행 중인 상태</p>
<h3 id="waiting">Waiting</h3>
<p>프로세스가 특정 자원이나 이벤트를 기다리는 상태</p>
<h3 id="terminated">Terminated</h3>
<p>프로세스가 실행이 완료되거나 종료된 상태</p>

<p><br /></p>

<h2 id="상태-전이-동작">상태 전이 동작</h2>
<h3 id="dispatch">Dispatch</h3>
<p>우선순위가 높은 프로세스를 선정하여 명령어를 실행한다</p>
<h3 id="timeout">Timeout</h3>
<p>클럭이 인터럽트를 발생시켜 제어권을 빼앗는다.(Preemption:독점방지)</p>
<h3 id="block">Block</h3>
<p>프로세서가 입출력, 자원 등을 기다리기 위해 대기상태로 전환한다.</p>
<h3 id="wake-up">Wake up</h3>
<p>입출력이 완료되거나 자원이 할당되어 다시 실행한다.</p>

<p><br /></p>

<h2 id="스케줄링">스케줄링</h2>
<p>운영체제는 여러 프로세스가 CPU를 공유할 수 있도록 프로세스를 스케줄링한다.<br />
스케줄러는 준비 상태의 프로세스 중 하나를 선택하여 CPU를 할당한다. 프로세스가 작업을 완료하거나 대기 상태로
전환되면 다음 프로세스에 CPU를 할당한다.</p>]]></content><author><name></name></author><category term="OS" /><summary type="html"><![CDATA[Process 실행 중인 프로그램으로 CPU에서 명령을 수행하기 위한 데이터와 상태 정보를 포함한다. 하나의 프로그램은 여러 개의 프로세스를 가질 수 있고, 각 프로세스는 독립적으로 실행된다.]]></summary></entry><entry><title type="html">ThreadLocal</title><link href="http://localhost:4000/java/2024/08/20/java-threadlocal.html" rel="alternate" type="text/html" title="ThreadLocal" /><published>2024-08-20T00:00:00+09:00</published><updated>2024-08-20T00:00:00+09:00</updated><id>http://localhost:4000/java/2024/08/20/java-threadlocal</id><content type="html" xml:base="http://localhost:4000/java/2024/08/20/java-threadlocal.html"><![CDATA[<h1 id="threadlocal">ThreadLocal</h1>
<p>각각의 스레드 별로 별도의 저장 공간을 제공하는 컨테이너</p>

<p>각 스레드는 자신만의 별도의 데이터를 가질 수 있고, 다른 스레드와 독립적으로 데이터를 설정하고 조회할 수 있다.</p>

<p>각 인스턴스는 특정 스레드에 연결되어 있는 데이터를 참조하며 다른 스레드에 영향을 주지 않는다.
이를 통해 멀티 스레드 환경에서도 스레드 간 데이터 공유와 동기화 문제를 해결할 수 있다.</p>

<p>각 요청마다 사용자 인증 정보를 threadLocal 에 저장하여 스레드 별로 관리할 수 있고, 이를 통해 여러 요청 간 사용자 정보를 명시적으로 전달하지 않고도 사용할 수 있다.</p>

<p>또한 데이터베이스 트랜잭션에서 Connection 객체를 ThreadLocal에 저장하여 각 스레드가 독립적으로 데이터베이스 연결을 관리하고, 트랜잭션 내에서 데이터베이스 연결을 공유하여 스레드 간의 충돌을 방지할 수 있.
한 번 계산된 결과를 스레드별로 캐시해서 다시 계산하지 않고 재사용할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadLocalExample</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">ThreadLocal</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">threadLocalValue</span> <span class="o">=</span> <span class="nc">ThreadLocal</span><span class="o">.</span><span class="na">withInitial</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="o">);</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Runnable</span> <span class="n">task</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">threadLocalValue</span><span class="o">.</span><span class="na">set</span><span class="o">((</span><span class="kt">int</span><span class="o">)</span> <span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">random</span><span class="o">()</span> <span class="o">*</span> <span class="mi">100</span><span class="o">));</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Thread local value: "</span> <span class="o">+</span> <span class="n">threadLocalValue</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
        <span class="o">};</span>

        <span class="nc">Thread</span> <span class="n">thread1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">task</span><span class="o">);</span>
        <span class="nc">Thread</span> <span class="n">thread2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">task</span><span class="o">);</span>
        <span class="nc">Thread</span> <span class="n">thread3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">task</span><span class="o">);</span>

        <span class="n">thread1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">thread2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">thread3</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">threadLocalValue</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p>하지만 메모리 누수를 유발할 수 있으며 ThreadLocal에 저장된 데이터는 스레드가 종료되어도 자동으로 해제되지 않는다. 따라서 사용이 끝난 후 remove() 메서드를 호출해서 데이터를 삭제해야 한다.</p>

<p><br /></p>

<h2 id="threadlocal-클래스의-initialvalue-메서드">ThreadLocal 클래스의 initialValue() 메서드</h2>
<p>ThreadLocal 변수가 처음 사용될 때 호출하며 각 스레드 별로 별도의 초기값을 반환한다.</p>

<p>각 스레드가 독립적으로 관리해야 하는 데이터의 초기값을 설정할 때 사용되며 로그인 사용자 정보, 트랜잭션 관리를 위한 초기 상태등을 초기화 한다.</p>

<p><br /></p>

<h2 id="스레드-재사용과-remove">스레드 재사용과 remove()</h2>
<p>데이터를 해제하는 메서드</p>

<p>스레드가 재사용되는 겨우 이전에 설정된 데이터가 존재하기 때문에 이전의 데이터와 공유될 수 있다.</p>

<p>ThreadLocal 변수의 데이터는 스레드마다 독립적으로 관리되지만, 스레드 풀에서 스레드가 재사용되는 동안
여러 스레드가 동시에 같은 변수에 접근하면 데이터의 일관성에 문제가 발생할 수 있다.</p>

<p>따라서 remove()를 이용하여 이전의 데이터를 해제해 주어야 한다.
사용하지 않는 경우 해당 스레드의 생명 주기 동안 메모리 리소스가 유지되기 때문에 메모리 누수가 발생할 수 있다.</p>

<p>또한, 스레드 풀의 사용을 제한할 수 있다. 스레드 풀을 사용하지 않으면 스레드가 작업을 완료한 후 종료되기 때문에 자동으로 ThreadLocal 변수가 제거된.
사용자 정의 스레드 팩토리를 사용하여 스레드가 종료될 때 ThreadLocal 변수를 명시적으로 제거할 수 있도록 구현하는 방법도 있습니다.다</p>

<p><br /></p>

<h3 id="remove">remove()</h3>
<p>ThreadLocal의 remove() 메서드를 호출하면, 현재 스레드와 연결된 ThreadLocal 값이 ThreadLocalMap에서 제거됩니다. 이때 변수의 삭제와 관련된 중요한 포인트는 다음과 같습니다:</p>

<ol>
  <li>remove() 메서드 호출 시점
실제 동작: remove() 메서드가 호출되면, 현재 스레드에 할당된 ThreadLocalMap에서 해당 ThreadLocal 객체에 대한 참조가 삭제됩니다. 이로 인해 해당 스레드와 연결된 ThreadLocal 값은 더 이상 접근할 수 없게 됩니다.</li>
</ol>

<p>메모리 정리: ThreadLocal에 저장된 값에 대한 참조가 사라지므로, 해당 값은 더 이상 사용되지 않으며, JVM의 Garbage Collector(GC)에 의해 수거될 수 있는 상태가 됩니다. 즉, 메모리에서 실제로 제거되는 시점은 GC가 이 객체를 수거할 때입니다.</p>

<ol>
  <li>실제 메모리에서의 삭제 시점
GC에 의해 수거: ThreadLocalMap에서 참조가 제거되면, ThreadLocal 객체와 그 값은 다른 곳에서 참조되지 않는 한 메모리에서 수거될 수 있는 상태가 됩니다. 하지만 실제로 메모리에서 언제 삭제될지는 GC의 작동 시점에 달려 있습니다.</li>
</ol>

<p>강제 수거: 메모리 누수를 방지하기 위해, ThreadLocal.remove()를 호출한 후에는 가능한 ThreadLocal 객체가 가비지 컬렉션 대상이 되도록 강제로 참조를 해제하는 것이 좋습니다.</p>

<ol>
  <li>가비지 컬렉션과의 관계
약한 참조(Weak Reference): ThreadLocalMap은 ThreadLocal 키를 약한 참조로 저장합니다. 이는 ThreadLocal 객체가 더 이상 강한 참조를 가지고 있지 않으면 GC에 의해 수거될 수 있음을 의미합니다. 하지만, ThreadLocal에 연결된 값은 여전히 강한 참조로 유지되기 때문에 remove()를 호출해 해당 참조를 해제하지 않으면 메모리 누수가 발생할 수 있습니다.</li>
</ol>

<p><br /></p>

<h2 id="스레드-팩토리">스레드 팩토리</h2>
<p>스레드 클래스의 run 메서드에섯 ThreadLocal.remove()를 호출하여 스레드 종료 전에 변수를 제거할 수 있다.
ThreadFactory 인터페이스를 구현해 새로운 스레드를 생성하고 생성된 스레드에서 remove() 메서드를 호출해 자원의 누수를 방지해야한다. 
스레드 풀은 스레드를 재사용하기 때문에 재사용 이전에 ThreadLocal 값이 남아있지 않도록, 사용후 값을 제거해주어야 한다.
remove()메서드를 이용하여 변수를 정리하여 메모리 누수를 방지해야 한다.</p>

<p><br /></p>

<h2 id="set-메서드">set() 메서드?</h2>
<p>변수를 제거한 후 해당 변수를 다시 사용하기 위해 set() 메서드를 사용해 새로운 값을 설정할 수 있다.</p>

<p><br /></p>

<h2 id="스레드가-종료">스레드가 종료</h2>
<p>ThreadLocal 변수를 제거하지 않고도 스레드가 종료될 때 자동으로 제거되는 방법은 스레드가 짧은 생명주기를 갖는 경우에 실행될 수 있습니다. ㅎ</p>

<p>스레드가 종료되면 스레드에 바인딩된 ThreadLocal 변수들도 함께 제거된다.</p>

<p>단위테스트나 통합 테이스에서도 일반적으로 테스트가 완료되면 종료되기 때문에 제거할 필요가 없다.</p>

<p><br /></p>

<h2 id="threadlocalwithinitial">ThreadLocal.withInitial()</h2>
<p>초기값을 설정하는 메서드로 변수의 초기화 로직을 간소화할 수 있다.</p>

<p>모든 스레드가 동일한 초기값을 갖기 때문에 일관성을 유지할 수 있으며 초기값 설정이 변수 선언과 동시에 일어나기 때문에 코드가 가독성이 좋다.</p>

<p><br /></p>

<h2 id="제거한-변수를-다시-사용하려면">제거한 변수를 다시 사용하려면?</h2>
<h3 id="1-get-또는-set-메서드를-호출하여-초기화">1. get() 또는 set() 메서드를 호출하여 초기화</h3>
<p><strong>get() 메서드 호출</strong></p>

<p>remove() 메서드가 호출된 후에 get() 메서드를 호출하면, ThreadLocal 변수는 초기화된다. 만약 ThreadLocal이 기본값 초기화 로직을 가지고 있다면, get() 메서드를 호출할 때 이 로직이 실행되어 새로운 값이 설정된다.
만약 초기화 로직이 없다면, get() 메서드는 null을 반환한다.</p>

<p><strong>set() 메서드 호출</strong></p>

<p>set(T value) 메서드를 사용하여 ThreadLocal 변수에 새로운 값을 명시적으로 설정할 수 있다. 이렇게 하면 해당 스레드에 대해 새로운 값이 할당된다.</p>

<p><br /></p>

<h2 id="사용자-정의-스레드-팩토리">사용자 정의 스레드 팩토리</h2>
<p>스레드 클래스의 run 메서드에섯 ThreadLocal.remove()를 호출하여 스레드 종료 전에 변수를 제거할 수 있다.</p>

<p>ThreadFactory 인터페이스를 구현해 새로운 스레드를 생성하고 생성된 스레드에서 remove() 메서드를 호출해 자원의 누수를 방지해야한다.
스레드 풀은 스레드를 재사용하기 때문에 재사용 이전에 ThreadLocal 값이 남아있지 않도록, 사용후 값을 제거해주어야 한다.
remove()메서드를 이용하여 변수를 정리하여 메모리 누수를 방지해야 한다.</p>

<p><br /></p>

<p>remove() 메서드를 호출하는 것이 중요한 이유는 스레드가 종료되도 변수값이 메모리에 남아있기 때문에 제거해주어야한다… 메모리 누수가 발생하지 않도록
다른 방법으로는 변수를 초기화하거나 제거하여  데이터가 남지않도록 하거나 beforeExecute(), afterExecute() 메서드에서 threadLocal 변수의 값을 초기화하는 방법이 있다.</p>

<p><br /></p>

<h3 id="beforeexecute-afterexecute">beforeExecute(), afterExecute()</h3>
<p>beforeExecute()와 afterExecute() 메서드를 이용 스레드가 작업을 시작하고 종료할 때 ThreadLocal 변수의 상태를 관리할 수 있다. 
주의할 점은 메서드 내부에서의 동기화 문제와, 스레드가 재사용될 때 데이터가 남지않도록 해야한다.
또한 스레드 종료 후 변수를 제거하여 메모리 누수를 방지해야 한다.</p>

<p><br /></p>

<h3 id="threadpoolexecutor의-execute-submit">ThreadPoolExecutor의 execute(), submit()</h3>
<p>execute는 Runnable 작업을 제출하고 결과를 반환하지 않는다
submit는 Runnable 또는 Callable 작업을 제출하고 Future를 통해 결과를 얻을 수 있다.</p>]]></content><author><name></name></author><category term="Java" /><summary type="html"><![CDATA[ThreadLocal 각각의 스레드 별로 별도의 저장 공간을 제공하는 컨테이너]]></summary></entry><entry><title type="html">운영체제의 동작</title><link href="http://localhost:4000/os/2024/08/19/os-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C.html" rel="alternate" type="text/html" title="운영체제의 동작" /><published>2024-08-19T00:00:00+09:00</published><updated>2024-08-19T00:00:00+09:00</updated><id>http://localhost:4000/os/2024/08/19/os-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C</id><content type="html" xml:base="http://localhost:4000/os/2024/08/19/os-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C.html"><![CDATA[<h2 id="operating-system">Operating System</h2>

<p><img src="https://github.com/user-attachments/assets/5046e1fc-6800-43ab-9a5a-eb55b6637427" alt="os.png" />
컴퓨터의 하드웨어와 소프트웨어 간에 중재 역할을 하는 시스템 소프트웨어</p>

<p>사용자와 컴퓨터 시스템 간의 인터페이스를 제공하며, 하드웨어 자원을 관리하고, 프로그램을 효율적으로 실행하도록 한다.</p>

<p>크게 사용자 영역과 커널 영역으로 이루어진다.</p>

<p><br /></p>

<h1 id="사용자-영역">사용자 영역</h1>
<ul>
  <li>응용 프로그램이 실행되는 메모리 공간</li>
  <li>사용자 프로그램이 실행되며, 운영체제의 서비스에 대한 요청을 시스템 콜을 통해 수행한다.</li>
  <li>하드웨어 자원에 직접 접근할 수 없으며, 운영체제의 커널을 통해서만 접근한다.</li>
  <li>하나의 프로그램의 오류가 다른 프로그램이나 운영체제에 영향을 미치지 않는다.</li>
  <li>다양한 사용자 프로그램이 실행된다.</li>
</ul>

<h3 id="1-인터페이스">1. 인터페이스</h3>
<ul>
  <li>사용자와 운영체제 간 상호작용을 담당한다.</li>
  <li>GUI, CLI 형태로 제공된다.</li>
</ul>

<p><br /></p>

<h1 id="커널-영역">커널 영역</h1>
<ul>
  <li>커널이 실행되는 메모리 공간</li>
  <li>하드웨어와 소프트웨어 간의 상호작용을 관리하고 시스템 자원을 직접 제어한다.</li>
  <li>커널은 모든 하드웨어 자원에 대한 직접적인 접근 권한을 가지며, 이를 통해 시스템 자원을 관리한다.</li>
  <li>사용자 프로그램의 요청을 처리하고, 시스템 보안 유지, 자원 관리 및 프로세스 관리 등의 기능을 수행한다.</li>
</ul>

<h3 id="커널의-역할">커널의 역할</h3>
<ul>
  <li><strong>프로세스 관리</strong> : 프로세스에 CPU를 배분하고 작업에 필요한 환경을 제공한다.</li>
  <li><strong>메모리 관리</strong> : 프로세스에 작업 공간을 배치하고 실제 메모리보다 큰 가상 공간을 제공한다.</li>
  <li><strong>파일 시스템 관리</strong> : 데이터를 저장하고 접근할 수 있는 인터페이스를 제공한다.</li>
  <li><strong>입출력 관리</strong> : 필요한 입출력 서비스를 제공한다.</li>
  <li><strong>프로세스 간 통신 관리</strong> : 공동 작업을 위한 각 프로세스 간 통신 환경을 제공한다.</li>
</ul>

<p><br /></p>

<h1 id="system-call">System Call</h1>

<p><img src="https://github.com/user-attachments/assets/2540c268-1f30-4a15-baac-b5e580215dee" alt="system.png" />
사용자나 프로그램이 직접적으로 하드웨어 자원에 접근하는 것을 막고 커널을 보호하기 위한 인터페이스</p>

<p>사용자 프로그램이 커널 서비스이 필요할 때 시스템 콜을 사용하여 커널 영역으로 전환한다.
CPU는 사용자 모드에서 커널 모드로 전환되며, 커널은 요청된 작업을 수행한 후 결과를 사용자 프로그램에 반환한다.</p>

<p><br /></p>

<h1 id="driver">Driver</h1>
<p>프린터, 키보드 및 디스크 드라이브와 같은 하드웨어 장치와 운영체제 간의 동신을 가능하게 하는 소프트웨어</p>

<h1 id="운영체제-동작-순서">운영체제 동작 순서</h1>

<h3 id="1-부팅">1. 부팅</h3>
<ul>
  <li>컴퓨터에 전원이 공급되면, 하드웨어 장치가 초기화 됩니다.</li>
  <li>하드웨어의 기본적인 기능을 점검하는 테스트(POS)가 실행되며, 이 과정에서 메모리, CPU, 키보드 등 정상적으로 동작하는지 확인한다.</li>
  <li>성공시 부트로더를 실행합니다.</li>
  <li>부트로더는 하드디스크나 SSD에 저장된 운영체제를 메모리로 불러온다. (이때, 커널이 메모리로 로드된다.)</li>
</ul>

<blockquote>
  <p><strong>bootloader</strong>
운영체제를 메모리에 로드하는 프로그램</p>
</blockquote>

<h3 id="2-커널-초기화">2. 커널 초기화</h3>
<ul>
  <li>커널은 하드웨어 장치를 제어하기 위한 장치 드라이버를 초기화한다.</li>
  <li>커널은 프로세스 관리 시스템을 설정하여 CPU 자원을 효율적으로 배분할 수 있도록 준비한다.</li>
  <li>커널은 메모리 관리 시스템을 초기화하여 프로그램들이 사용할 수 있는 메모리 영역을 설정하고 관리한다.</li>
  <li>운영체제는 파일 시스템을 마운트하여, 하드디스크 등에서 데이터를 읽고 쓸 수 있게 한다.</li>
</ul>

<h3 id="3-서비스-및-데몬-실행">3. 서비스 및 데몬 실행</h3>
<ul>
  <li>네트워크, 프린터, 사용자 인증 등과 관련된 서비스가 실행된다.</li>
  <li>백그라운드에서 지속적으로 실행되는 프로그램들로, 로그 관리, 네트워크 연결 관리 등을 처리한다.</li>
</ul>

<h3 id="4-사용자-인터페이스-제공">4. 사용자 인터페이스 제공</h3>
<ul>
  <li>사용자에게 로그인 화면을 제공한다. ID, PWD를 입력하여 인증 절차를 거친다.</li>
  <li>사용자 인증 후, 데스크탑 환경(윈도우 시슷템, 아이콘, 메뉴 등)이 로드된다.</li>
</ul>

<h3 id="5-프로그램-실행-및-관리">5. 프로그램 실행 및 관리</h3>
<ul>
  <li>사용자가 프로그램을 실행하면, 운영체제는 해당 프로그램을 메모리에 로드하고 CPU를 할당하여 실행한다.</li>
  <li>운영체제는 프로세스를 관리하며, 필요한 경우 멀티태스킹을 통해 여러 프로그램이 동시에 실행할 수 있도록 한다.</li>
  <li>파일 저장, 프린터 출력, 네트워크 연결등 모든 입출력 작업을 운영체제가 관리한다.</li>
</ul>

<h3 id="6-종료-및-셧다운">6. 종료 및 셧다운</h3>
<ul>
  <li>사용자가 프로그램을 종료하면, 운영체제는 해당 프로그램에 할당된 메모리와 리소스를 해제한다.</li>
  <li>사용자가 시스템 종료를 선택하면, 운영체제는 실행중인 모든 프로그램과 서비스를 종료하고, 파일 시스템을 안전하게 언마운트 한 뒤 전원을 끈다.</li>
</ul>]]></content><author><name></name></author><category term="OS" /><summary type="html"><![CDATA[Operating System]]></summary></entry><entry><title type="html">NIO</title><link href="http://localhost:4000/java/2024/08/14/java-NIO.html" rel="alternate" type="text/html" title="NIO" /><published>2024-08-14T00:00:00+09:00</published><updated>2024-08-14T00:00:00+09:00</updated><id>http://localhost:4000/java/2024/08/14/java-NIO</id><content type="html" xml:base="http://localhost:4000/java/2024/08/14/java-NIO.html"><![CDATA[<p>Java NIO 는 JDK 1.4 에 적용된 패키지로 기존의 Java I/O 느린 단점을 보완</p>

<p><img src="https://github.com/user-attachments/assets/88f0cd4c-4989-4155-a8de-3ac6f32bbb53" alt="IO.png" /></p>

<h1 id="java-io">Java IO</h1>
<ol>
  <li>파일의 경로와 이름 등의 메타 데이터를 포함한 InputStream, OutputStream 객체 생성</li>
  <li>InputStream 및 OutputStream 객체를 사용하여 read(), write() 등의 메서드 호출<br />
이 메서드들은 JVM을 통해 해당 플랫폼의 운영체제와 상호 작용한다.</li>
  <li>JVM은 운영 체제의 파일 시스템 API를 사용하여 파일에 대한 실제 읽기 및 쓰기 작업을 한다. 
이 때, 운영 체제는 해당 파일을 찾아 디스크에서 읽기 작업을 수행하거나, 쓰기 작업을 수행하여 디스크에 데이터를 저장한다.</li>
  <li>운영 체제는 파일로부터 읽은 데이터를 커널의 버퍼에 저장한 뒤 JVM의 사용자 공간 버퍼로 복사하거나, 사용자 공간 버퍼의 데이터를 파일 시스템으로 전달한다.
이 과정에서 대체로 Thread 를 block 시킨다.</li>
</ol>

<p><br /></p>

<h1 id="java-io-와-nio">Java IO 와 NIO</h1>
<h3 id="io">IO</h3>
<ul>
  <li><strong>동기 방식, 블로킹 방식, 단방향 전송, 스트림</strong></li>
  <li>입력 스트림과 출력 스트림이 구분되어 있으며 별도로 생성해야 한다.</li>
  <li>버퍼를 사용하지 않으며 1바이트씩 읽고 출력하기 때문에 속도가 느리다.</li>
  <li>BufferdInputStream, BufferedOutputStream, BufferedReader, BufferedWriter와 같은 보조 스트림을 별도로 제공하여 버퍼 기능을 지원한다.</li>
  <li>스트림으로부터 입력된 전체 데이터를 별도로 저장하지 않으면, 입력 데이터의 위치를 이동하면서 자유롭게 이용할 수 없다.</li>
  <li>블로킹을 빠져나오려면 스트림을 닫아야 한다.</li>
  <li>연결 클라이언트 수가 적고 전송되는 데이터가 대용량이며 순차적으로 처리될 필요가 있는 경우 사용</li>
</ul>

<h3 id="nio">NIO</h3>
<ul>
  <li><strong>채널, 스트림, 동기, 비동기, 블로킹, 넌블로킹, 양방향, 버퍼</strong></li>
  <li>하나의 채널로 데이터를 읽고 쓰기가 가능한 양방향 전송</li>
  <li>버퍼를 사용해서 입출력 성능이 좋으며 버퍼에 저장하기 때문에 버퍼 내에서 데이터 위치를 이동해가며 필요한 부분을 읽고 쓸 수 있다.</li>
  <li>interrupt를 사용해 블로킹을 빠져나올 수 있다.</li>
  <li>연결 클라이언트 수가 많고 전송되는 데이터 용량이 적으며, 입출력 작업 처리가 빨리 끝나는 경우 사용</li>
</ul>

<p><img src="https://github.com/user-attachments/assets/7d83ad17-5621-4f21-82e9-103de76a5aeb" alt="nio_process.pno" />
<br /></p>

<p><img src="https://github.com/user-attachments/assets/6b87720f-d5c0-4c1d-b540-de5bc09a2003" alt="nio.png" /></p>

<h3 id="selector">Selector</h3>
<p>여러 채널을 동시에 감시하여 데이터가 읽거나 쓸 준비가 되어있는지 확인</p>

<p>여러 채널에서 발생하는 I/O 이벤트를 동시에 처리할 수 있게 하여 단일 스레드로 여러 I/O 연산을 처리한다.
이를 통해 하나의 스레드가 여러 I/O 작업을 비동기로 처리할 수 있다.</p>

<h3 id="channel">Channel</h3>
<p>파일이나 소켓과 같은 I/O 대상과 연결되어 있는, 데이터가 읽고 쓰이는 통로<br />
실제 데이터 전송을 담당하며 파일, 네트워크 소켓 등 다양한 데이터 소스와 연결되고, 데이터는 채널을 통해 읽거나 쓸 수 있다. 
실제로 read, write 를 수행하는 주체이다.</p>

<h3 id="buffer">Buffer</h3>
<p>채널에서 읽거나 쓴 데이터를 임시로 저장하는 메모리 블록
NIO의 모든 데이터는 버퍼를 통해 처리되며, 채널과 버퍼 간 데이터 이동이 발생한다. 
채널과 상호작용하여 데이터를 저장하는 메모리 블록을 데이터는 채널에서 버퍼로 읽히거나, 버퍼에서 채널로 쓰인다.</p>

<p>Selector는 여러 Channel을 등록하여 감시한다.
데이터가 준비된 채널이 있으면 셀렉터가 이것을 확인하고 해당 채널에 관련된 버퍼를 통해 데이터를 처리한다.
이를 통해서 하나의 스레드가 여러 I/O 작업을 처리합니다.</p>

<p><br /></p>

<p>Blocking은 채널에서 데이터가 준비될 때까지 스레드가 대기한다. 
Non-blocking 의 경우 채널에서 데이터가 준비되지 않은 경우 블로킹 되지 않고 다른 작업을 수행하고, 데이터가 준비되면 나중에 다시 확인한다.</p>

<p>Non-blocking 구현하기 위해서는 configureBlocking(false)를 사용하여 non-blocking 모드로 설정한다. 
그러면 채널의 I/O 작업이 블로킹되지 않고 반환한다.</p>

<p>즉 데이터가 준비되지 않은 경우 read(), write() 호출이 블로킹 되지 않고 -1, 0을 반환하여 바로 다른 작업을 할 수 있다.</p>

<p>Selector의 select() 메서드를 호출해서 준비된 채널을 확인 한다.
채널이 준비될때까지 블로킹되거나, 준비된 채널이 없으면 반환됩니다.</p>

<p>준비된 채널을 얻으면 해당 채널을 통해서 read(), write() 통해 데이터를 읽거나 사용할 수 있다.</p>

<p>select()가 반환한 값 중 0은 준비된 채널이 없음을 의미하며, 양수가 나오는 경우 준비된 채널의 수를 의미한다.</p>

<h3 id="selectedkeys">selectedKeys()</h3>
<p>selectedKeys() 메서드 호출을 통해 준비된 채널의 집합을 얻을 수 있으며, 
각 selectedKey를 확인해 준비된 작업을 수행할 수 있다.</p>

<p>작업 완료 후 selectionKey를 selectedKeys에서 제거하여 다음 select() 호출에서 중복으로 처리되지 않도록 한다.</p>

<blockquote>
  <p><strong>interest set</strong><br />
 SelectionKey에서 감시하고 싶은 채널의 I/O 읽기 또는 쓰기 이벤트를 감시하도록 설정</p>

  <p><strong>ready set</strong><br />
Selector가 select() 또는 selectNow()로 감지한 채널의 현재 상태
Selector가 현재 준비된 I/O 작업을 가진 채널의 SelectionKey 객체들을 가지고 있으며 이 값은 select(), selectNow() 호출을 통해 받은 채널의 수와 동일하.</p>
</blockquote>

<p><br /></p>

<h3 id="select-와-selectnow">select() 와 selectNow()</h3>
<p>두 메서드의 차이는 블로킹 여부와 대기시간에 있다.</p>

<h4 id="select">select()</h4>
<p>select()는 채널이 준비될 때까지 블로킹된다. 지정된 시간 동안 대기하며, 준비된 채널의 수를 반환한다.
준비된 채널이 없는 경우 스레드를 대기 상태로 두어 준비된 채널이 있을때까지 기다린다.</p>

<h4 id="selectnow">selectNow()</h4>
<p>블로킹 없이 현재 준비된 채널의 상태를 실시간으로 확인하는 메서드로 비동기로 채널 상태를 검사할 때 유용하다.
스레드를 대기시키지 않고 빠르게 상태를 확인할 수 있지만 호출이 빈번하게 일어나느 경우 CPU 사용률이 증가할 수 있다.
준비된 채널이 없으면 즉시 반환되며, 대기하지 않는다.</p>

<p>select()에서 블로킹을 피하기 위한 대안으로 타임아웃을 설정하여 지정된 시간동안만 대기하거나, selectNow()를 사용할 수 있다.
또는 여러 개의 selector()을 사용하면 여러 개의 채널을 동시에 관리할 수 있.</p>]]></content><author><name></name></author><category term="Java" /><summary type="html"><![CDATA[Java NIO 는 JDK 1.4 에 적용된 패키지로 기존의 Java I/O 느린 단점을 보완]]></summary></entry><entry><title type="html">Blocking IO와 Non-Blocking IO , 동기와 비동기</title><link href="http://localhost:4000/java/2024/08/12/java-blocking.html" rel="alternate" type="text/html" title="Blocking IO와 Non-Blocking IO , 동기와 비동기" /><published>2024-08-12T00:00:00+09:00</published><updated>2024-08-12T00:00:00+09:00</updated><id>http://localhost:4000/java/2024/08/12/java-blocking</id><content type="html" xml:base="http://localhost:4000/java/2024/08/12/java-blocking.html"><![CDATA[<h1 id="blocking">Blocking</h1>
<p><img src="https://github.com/user-attachments/assets/1864c95d-e345-43ed-8604-100e30379bfe" alt="blocking.png" />
현재 스레드(또는 프로세스)가 어떤 작업을 수행할 때, <strong>그 작업이 완료될 때까지 다른 작업을 할 수 없도록 대기하는 상태</strong></p>

<p>제어권이 호출된 함수에게 넘어가서, 함수가 작업을 끝낼때까지 제어권을 유지합니다.<br />
따라서 호출한 함수는 호출된 함수가 끝나기 전까지 다른 작업을 하지 못하고 대기합니다.</p>

<ul>
  <li>파일을 읽거나 쓰는 작업에서 파일 읽기/쓰기가 완료될 때까지 스레드가 대기하는 경우</li>
  <li>네트워크에서 데이터를 받을 때까지 응답을 기다리며 다른 작업을 하지 못하는 경우</li>
</ul>

<h4 id="문제">문제</h4>
<p>입출력 작업이 완료될때 까지 다른 스레드가 대기해야하기 때문에, 멀티 스레드 환경에서 대기 시간이 오래 걸릴 수 있습니다. 
많은 클라이언트의 요청을 동시에 처리할 수 없으며 블록 상태가 발생할 수 있습니다.</p>

<p><br /></p>

<h1 id="non-blocking">Non-Blocking</h1>
<p><img src="https://github.com/user-attachments/assets/4fa1e260-068b-4e24-9c73-cd6c4c14baff" alt="non_blocking.png" />
작업이 즉시 처리되거나, 처리할 수 없는 경우에도 스레드가 <strong>대기하지 않고 다른 작업을 계속할 수 있는 상태</strong></p>

<p>제어권이 호출된 함수에게 넘어갔다가, 즉시 호출한 함수로 돌아옵니다.
호출된 함수가 완료되지 않았지만, 제어권을 바로 반환하기 때문에 호출한 함수는 다른 작업을 계속할 수 있습니다.</p>

<p>A 함수가 B 함수를 호출했을 때, B 함수는 바로 A 함수에게 제어권을 돌려주고, A 함수는 B 함수가 끝날 때까지 기다리지 않고 다른 작업을 할 수 있게 됩니다.</p>

<ul>
  <li>
    <h6 id="파일이나-네트워크-요청을-보내고-응답이-준비될-때까지-기다리지-않고-바로-다음-작업을-수행하는-경우">파일이나 네트워크 요청을 보내고, 응답이 준비될 때까지 기다리지 않고 바로 다음 작업을 수행하는 경우</h6>
  </li>
  <li>작업이 완료될 때까지 대기하지 않고, 작업 큐에 넣어 두고 다른 작업을 수행하는 경우</li>
</ul>

<h4 id="문제-1">문제</h4>
<p>복잡하며, 콜백 지옥과 같은 문제가 발생할 수 있고, 이벤트를 기반으로 동작하기 때문에 실행 흐름을 추적하거나 디버깅이 어렵습니다.
비동기 작업이 많아질수록 메모리 사용량이 증가할 수 있습니다.</p>

<p>주로 다수의 클라이언트 요청을 비동기로 처리할 때 사용되며, 웹 서버에서 여러 요청을 동시에 처리하고
IO 작업이 완료될 때까지 기다리지 않고 다른 요청을 처리하는데 유용하게 사용됩니다.
대규모 데이터베이스나 파일 처리에서 비동기 IO는 시스템의 처리량을 향상 시키는데 기여할 수 있습니다.</p>

<p>구현 방법에는 자바스크립트에서 콜백함수를 사용하거나 promise 를 사용하는 방법이 있습니다.
또한 자바의 NIO 와 같은 라이브러리를 사용하여 블로킹 IO 를 비동기적으로 처리할 수 있습니다.</p>

<p><br /></p>

<h1 id="동기">동기</h1>

<p><img src="https://github.com/user-attachments/assets/f8be4407-6199-400c-8a7c-8ca2415beb8a" alt="sync.png" />
작업의 완료를 기다리는 방식으로, <strong>순차적으로 실행</strong>되며 한 작업이 끝나야 다음 작업이 시작될 수 있습니다.</p>

<p>작업의 순서가 보장되며, 코드의 실행 순서가 예측 가능합니다.</p>

<p><br /></p>

<h1 id="비동기">비동기</h1>
<p><img src="https://github.com/user-attachments/assets/4e618758-a40c-4aef-87f6-f71af4d6f1d2" alt="async.png" />
작업의 완료를 기다리지 않는 방식입니다.</p>

<p>작업들이 <strong>병렬로 실행</strong>될 수 있으며, 어떤 작업이 끝날 때까지 기다리지 않고 다른 작업을 수행합니다.
작업 완료는 나중에 별도로 처리되며, 작업이 완료되면 그에 대한 콜백을 받거나, 나중에 결과를 확인합니다.</p>

<p><br /></p>

<blockquote>
  <h4 id="blocking-와-non-blocking">Blocking 와 Non-Blocking</h4>
  <p>함수 호출 후 제어권의 반환 시점</p>

  <h4 id="동기-와-비동기">동기 와 비동기</h4>
  <p>작업 완료 시점에 대한 처리 방식</p>
</blockquote>

<p><br /></p>

<h3 id="promise">Promise?</h3>
<p>비동기 작업의 결과를 나중에 처리할 수 있는 객체로, 작업의 성공(fulfilled) 또는 실패(rejected)를 다룹니다.
비동기 코드를 더 읽기 쉽게 작성하고 에러 처리를 간편하게 할 수 있습니다.
코드가 복잡해질 수 있고 디버깅이 어려워질 수 있습니다. 또한 비동기 작업을 작업을 과ㅏㄴ리하기 위해 메모리를 추가로 소비하기 때문에 많은 
Promise 객체가 생성될 경우 메모리 사용량이 증가합니다.</p>

<p>따라서 모든 비동기에 에러 처리를 해야하며, Promise.all()을 사용할 때, 하나의 Promise라도 실패하면 전체가 실패로 간주되므로, 개별적으로 에러 처리를 할 필요가 있습니다.
Promise 내부에서 또 다른 Promise를 반환하는 경우, 코드가 복잡해질 수 있기 때문 async/await를 사용하는 것이 더 적합할 수 있습니다.</p>

<h3 id="nio-new-io">NIO (New I/O)</h3>
<p>자바의 비동기 IO를 지원하는 API로, 네트워크와 파일 작업을 효율적으로 처리할 수 있게 합니다.
Selector와 Channel을 사용하여 비동기적으로 여러 IO 작업을 관리할 수 있습니다.</p>

<p><br />
<br /></p>

<p><br />
<br /></p>

<h1 id="이벤트-통지-방식">이벤트 통지 방식</h1>
<p><img src="https://github.com/user-attachments/assets/c97d033c-e0dc-4825-8e1c-7e5df74b594e" alt="event.png" /></p>

<h3 id="sync-blocking-io">Sync Blocking I/O</h3>
<p>입력 요청 등 제어권과 처리 결과를 동시에 반환</p>

<ol>
  <li>호출</li>
  <li>블로킹</li>
  <li>처리</li>
</ol>

<p>구현이 간단하고 직관적이며, 스레드가 직적 I/O 작업을 기다리기 때문에 비동기 처리가 필요없습니다.</p>

<h3 id="sync-non-blocking-io">Sync Non-Blocking I/O</h3>
<p>자신의 작업을 하면서 결과가 반환됐는지 확인하는 방식</p>

<p>반환됐을 경우 바로 처리합니다.</p>

<ol>
  <li>호출: 스레드가 I/O 작업을 요청합니다. 요청이 즉시 완료되지 않더라도 스레드는 다른 작업을 계속 진행합니다.</li>
  <li>작업 상태 확인: I/O 작업의 상태를 주기적으로 확인하거나, 결과를 체크합니다.</li>
  <li>처리: 작업이 완료되면 결과를 처리합니다. 이 과정은 동기적으로 이루어집니다.</li>
</ol>

<p>스레드가 다른 작업을 계속 수행할 수 있으므로 자원 효율성이 좋으며, 높은 I/O 성능을 요구하는 어플리케이션에서 효과적입니다.</p>

<h3 id="async-blocking-io">Async Blocking I/O</h3>
<p>비동기적으로 I/O 요청을 시작하고, I/O 작업의 완료를 기다리는 블로킹 방식</p>

<ol>
  <li>비동기 I/O 요청: I/O 작업을 비동기적으로 시작합니다. 요청을 보내고 제어권을 즉시 반환받습니다.</li>
  <li>블로킹 대기: I/O 작업의 결과를 기다리는 동안, 스레드가 블로킹되며 대기합니다.</li>
  <li>결과 처리: I/O 작업이 완료되면, 블로킹된 스레드가 결과를 처리합니다. 이 과정에서 비동기적 요소가 작용할 수 있습니다.</li>
</ol>

<p>비동기 I/O 요청을 통해 자원의 사용 효율성을 높일 수 있으며, 스레드의 효율성을 높일 수 있습니다.</p>

<p>스레드가 블로킹되는 동안 다른 작업을 수행할 수 없기 때문에 자원의 활용도가 떨어질 수 있으며,
비동기 요청과 블로킹 대기 사이의 복잡성을 관리하기 어려울 수 있습니다.</p>

<h3 id="async-non-blocking-io">Async Non-Blocking I/O</h3>
<p>I/O 작업의 완료를 기다리지 않고 다른 작업을 동시에 처리할 수 있는 접근 방식</p>

<p>작업 요청 이후 자신의 작업은 그대로 진행. 결과가 반환되어도 바로 처리하는게 아니라 자기 작업이 끝난 이후에 콜백을 통해 추가 작업</p>

<ol>
  <li>I/O 요청: 스레드는 I/O 작업을 요청하고 즉시 제어권을 반환받습니다. 스레드는 I/O 작업의 완료를 기다리지 않습니다.</li>
  <li>작업 완료 대기: I/O 작업은 비동기적으로 처리되며, 완료 시 콜백 함수나 Future/Promise 객체를 통해 결과를 받습니다.</li>
  <li>결과 처리: I/O 작업이 완료되면, 콜백 함수나 Future/Promise 객체를 통해 결과를 비동기적으로 처리합니다.</li>
</ol>

<p>I/O 작업이 완료될 때까지 스레드가 대기하지 않으므로, 자원 활용도가 높고, 많은 I/O 작업을 동시에 처리할 수 있어 성능이 향상됩니다.
응답 시간이 짧고, 높은 처리량을 달성할 수 있습니다.</p>

<p>비동기 코드의 복잡성이 증가할 수 있습니다.
콜백 지옥(callback hell)이나 상태 관리의 복잡함이 발생할 수 있습니다.</p>]]></content><author><name></name></author><category term="Java" /><summary type="html"><![CDATA[Blocking 현재 스레드(또는 프로세스)가 어떤 작업을 수행할 때, 그 작업이 완료될 때까지 다른 작업을 할 수 없도록 대기하는 상태 제어권이 호출된 함수에게 넘어가서, 함수가 작업을 끝낼때까지 제어권을 유지합니다. 따라서 호출한 함수는 호출된 함수가 끝나기 전까지 다른 작업을 하지 못하고 대기합니다. 파일을 읽거나 쓰는 작업에서 파일 읽기/쓰기가 완료될 때까지 스레드가 대기하는 경우 네트워크에서 데이터를 받을 때까지 응답을 기다리며 다른 작업을 하지 못하는 경우]]></summary></entry><entry><title type="html">JVM 내부 동작 원리</title><link href="http://localhost:4000/java/2024/08/12/jvm.html" rel="alternate" type="text/html" title="JVM 내부 동작 원리" /><published>2024-08-12T00:00:00+09:00</published><updated>2024-08-12T00:00:00+09:00</updated><id>http://localhost:4000/java/2024/08/12/jvm</id><content type="html" xml:base="http://localhost:4000/java/2024/08/12/jvm.html"><![CDATA[<p><img src="https://github.com/user-attachments/assets/f87e0921-47a3-4170-a951-abdb68ffbb6d" alt="jdk.png" /></p>
<h3 id="jdk-java-development-kit">JDK (Java Development Kit)</h3>
<p>소프트웨어 개발 도구</p>

<h3 id="jre-java-runtime-environment">JRE (Java Runtime Environment)</h3>
<p>소프트웨어 번들로 자바 클래스와 라이브러리, 그 외 필수적인 컴포넌트</p>
<ul>
  <li>(=운영체제)</li>
</ul>

<p>JDK 를 설치하면 JRE도 같이 설치됨 (JDK = JRE + a)</p>

<h3 id="jvm-javaa-virtual-machine">JVM (Javaa Virtual Machine)</h3>
<ul>
  <li>
    <p>Write once, Run everyWhere</p>
  </li>
  <li>
    <p>컴파일된 바이트 코드를 실행하고 실행에 필요한 환경을 제공</p>
  </li>
  <li>
    <p>자바를 실행하기 위한 가상 컴퓨터로 자바와 운영체제 사이에서 중계자 역할을 하며 자바가 운영체제에 구애받지 않고 프로그램을 실행할 수 있도록 도와주는 역할</p>
  </li>
</ul>

<blockquote>
  <h5 id="특징">특징</h5>
  <ul>
    <li>
      <p>컴파일된 바이트 코드를 기계어로 변환</p>
    </li>
    <li>
      <p>스택 기반의 가상 머신</p>
    </li>
    <li>
      <p>메모리 관리와 GC 수행</p>
    </li>
  </ul>
</blockquote>

<p>예로 C는 바로 기계어로 컴파일 하므로 HW 기종에 맞게 각각 컴파일 되어야 한다.</p>

<p>자바 프로그램은 중간 단계 언어( *.class )로 컴파일 하여 JVM만 각 OS에 설치되어 있다면 HW 기종에 관계 없이 한 번만 컴파일 하면 된다.</p>

<blockquote>
  <h4 id="바이너리-코드-바이트-코드-기계어">바이너리 코드/ 바이트 코드/ 기계어</h4>
  <p>컴퓨터가 바로 인식할 수 있는 “바이너리 코드”가 아닌 “바이트 코드”로 변환</p>

  <p><strong>바이너리 코드</strong></p>
  <ul>
    <li>컴퓨터가 인식할 수 있는 0과 1로 구성된 이진코드</li>
  </ul>

  <p><strong>바이트 코드</strong></p>
  <ul>
    <li>JVM 이 이해할 수 있는 코드</li>
    <li>고급 언어로 작성된 소스 코드를 가상 머신이 이해할 수 있는 중간 코드로 컴파일하여 어떤 플랫폼에도 종속되지 않고 독립적으로 실행 될 수 있는 가상머신용 기계어 코드</li>
    <li>바이트 코드는 다시 실시간 번역기 또는 JIT(Just-in-time)컴파일러에 의해 네이티브 코드로 변환</li>
  </ul>

  <p><strong>기계어</strong></p>
  <ul>
    <li>CPU가 직접 해독할 수 있고 실행할 수 있는 바이너리 코드</li>
    <li>
      <p>모든 이진 코드가 기계어인 것은 아니다. (바이너리코드 != 기계어)</p>
    </li>
    <li>기계어는 특정 언어가 아니다.</li>
    <li>CPU 제조사에서 CPU를 만들 때 CPU에서 사용하는 명령어 집합을 공개하는데, 이것을 기계어라 부른다.</li>
    <li>CPU가 변경되면 기계어가 달라진다. (같은 동작을 하는 명령어지만 완전히 다른 0과 1이 나열될 수도 있다.)</li>
  </ul>

  <p>즉, 소스 파일(<em>.java)은 컴파일된 자바 클래스 파일(</em>.clss)을 이해 중간단계 언어(바이트 코드)로 컴파일 되고, JVM이 이러한 컴파일된 자바 클래스파일(*class)을 OS에 맞는 기계어로 변환(인터프리터와 JIT 컴파일러를 통해)하여 실행되는 것이다.</p>
</blockquote>

<p><br /></p>

<h2 id="java-실행-방식">Java 실행 방식</h2>
<p><img src="https://github.com/user-attachments/assets/055a1d07-4329-4f1f-8fff-59548609b68f" alt="compile.png" /></p>

<p><strong>JVM</strong> 은 java 클래스 파일을 <strong>class loader</strong> 를 통해 로드하고 클래스 파일들은 <strong>execution engine</strong>를 통해 해석된다
이때 JVM이 컴파일을 마친 .class 파일을 읽어서 운영체제에서 실행시킨다. 더 정확히 말하면 JVM의 Class Loader가 동적 로딩을 통해 필요한 클래스들을 로딩 및 링크하여 Runtime Data Area에 적재한다. 그리고 Runtime Data Area에 로딩된 바이트 코드는 Excution Engine을 통해 실행된다.</p>

<p>이렇게 해석된 프로그램은 <strong>runtime data area</strong>에 배치되어 수행이 이루어진다</p>

<p>이 과정에서 JVM은 필요에 따라 <strong>garbage collection</strong> 등의 작업을 수행한다.</p>

<ol>
  <li>
    <p>자바 컴파일러가 자바 소스 파일을 바이트 코드(.class) 파일로 컴파일 한다</p>
  </li>
  <li>
    <p>JVM 은 Class Loader를 통해 클래스 파일을
메모리(Runtime Data Area의 메서드 영역)에 로드한다</p>

    <ul>
      <li>Class Loader : 프로그램을 수행하기 위해 OS로부터 할당받은 메모리 영역</li>
    </ul>
  </li>
  <li>
    <p>JVM 은 클래스 파일을 검증하여 자바 언어 명세에 따라 유효한지 확인한다
이를 통해 잘못된 클래스 파일이 실행되는 것을 방지한다</p>
  </li>
  <li>
    <p>JVM 은 클래스의 메모리를 할당하고, 클래스 변수를 기본 값으로 초기화 한다
이 단계에서 정적 변수 및 정적 메서드가 준비된다</p>
  </li>
  <li>
    <p>JVM 은 execution engine 통해 클래스 파일을 해석하여 기계어로 변환하고 실행
이 과정에서 JIT 컴파일러 사용
JIT 컴파일러는 프로그램을 실행 하는 동안 반복되는 코드 블록을 식별하고 이를 네이티브
기계 코드로 컴파일하여 실행 속도를 향상시킨다</p>

    <ul>
      <li>execution engine : Loading 된 클래스의 바이트코드를 해석 (바이트-&gt;바이너리)</li>
    </ul>
  </li>
  <li>
    <p>JVM 은 더 이상 필요하지 않은 객체를 감지하고 메모리에서 해제하는 GC을 수행
자동으로 수행되며 개발자가 명시적으로 메모리 관리를 수행할 필요가 없다</p>
  </li>
  <li>
    <p>프로그램이 종료되거나 JVM 이 종료될 때, JVM 은 사용한 리소스를 해제하고 종료</p>
  </li>
</ol>

<p><br /></p>

<h1 id="jvm-구성요소">JVM 구성요소</h1>
<p><img src="https://github.com/user-attachments/assets/6a10be91-d22a-4322-ab3e-a5c303bc4965" alt="jvm.png" /></p>

<p>JVM은 크게 아래과 같이 구성되어 있다.</p>

<ul>
  <li><strong>Class Loader</strong></li>
  <li><strong>Runtime Data Area</strong>
    <ul>
      <li>PC register</li>
      <li>Stack Area</li>
      <li>Native Method Stack</li>
      <li>Heap Area</li>
      <li>Method Area</li>
    </ul>
  </li>
  <li><strong>Execution Engine</strong>
    <ul>
      <li>Interpreter</li>
      <li>JIT Compiler</li>
      <li>Garbage Collector</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="class-loader-system">Class Loader System</h3>
<p><img src="https://github.com/user-attachments/assets/a78d1ccb-31d2-446a-96e0-9ff63eb3c960" alt="classloader.png" />
자바 클래스 파일(.class)을 실행 시점(Runtime)에 읽어 메모리(Runtime Data Area)에 로드하고 실행하기 위해 사용하는 메커니</p>

<p>자바 프로그램의 실행 중 필요한 클래스를 동적으로 로드하고, 연결하고 초기화하는 역할을 한다.
자바의 클래스들은 한 번에 모든 클래스가 메모리에 올라가지않으며, 필요할때 메모리에 올라간다.</p>

<p>로딩 -&gt; 링크 -&gt; 초기화의 순서를 거친다</p>

<h4 id="로딩">로딩</h4>
<p>클래스 로더가 클래스 파일을 찾아 메모리에 로드한다.<br />
이때 클래스 로더는 .class 파일을 바이너리 형식으로 읽어, JVM의 메모리 영역인 메서드 영역에 저장한다.</p>

<p>로딩이 끝나면 해당 클래스 타입의 Class 객체를 생성하여 Heap 영역에 저장한다.
클래스, 인터페이스 , ENUM, 변수, 메소드 정보들을 저장한다. 
한번에 메모리에 모두 로드하지 않고, 필요한 경우 동적으로 메모리에 로드한다</p>

<h5 id="bootstrap-class-loader">Bootstrap Class Loader</h5>
<p>JVM의 핵식 클래스 로더로 rt.jar와 같은 핵심 자바 API를 로드한다.
네이티브 코드로 구현되어 있으며, Java로 접근할 수 없고 가장 높은 우선순위를 갖는다.</p>

<h5 id="extension-class-loader">Extension Class Loader</h5>
<p>lib/ext 디렉터리나 java.ext.dirs 시스템 속성에 지정된 위치에서 확장 클래스들을 로드한다.
부트스트랩 클래스 로더 다음의 계층에 위치하며, 사용자 정의 클래스 로더보다 우선적으로 사용한다.</p>

<h5 id="application-class-loader">Application Class Loader</h5>
<p>애플리케이션 클래스패스(classpath)에 지정된 클래스, 애플리케이션에서 작성한 클래스와 라이브러리를 로드한다.</p>

<p>자바 응용 프로그램의 기본 클래스 로더로, 대부분의 사용자 클래스와 라이브러리를 로드하는데 사용된다.</p>

<h4 id="링크">링크</h4>
<p>로드된 클래스 파일을 JVM이 사용할 수 있도록 준비하는 단</p>

<ul>
  <li>Verify -&gt; Prepare -&gt; Resolve</li>
</ul>

<h5 id="verification">Verification</h5>
<p>.class 파일 형식이 유효한지 검사한다. 로드된 클래스가 자바 언어 명세에 부한한지 확인한다.
유효하지 않은 경우 런타입에러(java.lang.VerifyError)가 발생 한다.</p>

<h5 id="preparation">Preparation</h5>
<p>클래스 변수(static 변수)와 같은 메모리를 할당하고 초기화한다.</p>

<h5 id="resolution">Resolution</h5>
<p>클래스의 심볼릭 메모리 레퍼런스를 메모리 영역에 존재하는 실제 메모리 주소로 변경한다.</p>

<blockquote>
  <h5 id="심볼릭-메모리-레퍼런스">심볼릭 메모리 레퍼런스</h5>
  <p>클래스의 특정 메모리 주소를 참조 관계로 구성한 것이 아닌 참조 대상의 이름만 갖는 것<br />
즉, 실제 메모리 주소가 아니라 이름만 갖는다.</p>
</blockquote>

<h4 id="initialization">Initialization</h4>
<p>클래스 변수의 초기화 코드가 실행된다. static 초기화 블록이 실행되며, 변수가 초기화된다.<br />
링크의 prepare 단계에서 확보한 메모리 영역에 클래스 변수들 (= static 변수)를 적절한 값으로 초기화한다.</p>

<h4 id="using">Using</h4>
<p>초기화된 클래스는 이제 JVM에서 사용될 준비가 되어 있으며, 인스턴스 생성이나 메서드 호출과 같은 작업이 가능하다.</p>

<h4 id="unloading">Unloading</h4>
<p>클래스 로더가 클래스를 메모리에서 제거한다.
JVM이 필요하지 않은 클래스를 GC를 통해 언로드한다.</p>

<p><br /></p>

<h3 id="runtime-data-area">Runtime Data Area</h3>
<p><img src="https://github.com/user-attachments/assets/80920538-c003-49ff-ba3a-e68d9f3c9a5f" alt="runtimedata.png" /></p>

<p>JVM이 프로세스로 수행되기 위해 OS로 부터 할당받는 메모리 영역</p>

<p>데이터 저장, 스레드 관리, 메서드 실행, 객체 관리 등 수행</p>

<p>프로그램 실행시, 메서듣 호출에 딷라 스택 프레임이 생성되고, 메서드 호출이 완료되면 해당 스택 프레임이 제거됩니다..
객체는 힙에 동적으로 생성되며, 가비지 컬렉션을 통해 메모리를 관리합니다.</p>

<p>클래스는 처음 참조될 때 메서드 영역에 로드되며, 이후 해당 클래스 정보는 메서드 영역에서 재사용됩니다.
JVM은 런타임 데이터 영역을 효율적으로 관리하기 위해 가비지 컬렉터를 사용하여 힙 메모리를 정리하고, 필요하지 않은 객체를 제거합니닫.</p>

<h4 id="method-area">Method Area</h4>
<ul>
  <li>JVM이 시작될 때 생성되며, 모든 스레드가 공유하는 영역</li>
  <li>여기에 스태틱 영역(정적 변수들이 저장되는 공간)이 포함됨</li>
  <li>클래스정보, 변수정보, Method, static 변수, 상수풀 등이 저장되는 영역</li>
  <li>GC의 대상</li>
</ul>

<h4 id="heap-area">Heap Area</h4>
<ul>
  <li>모든 스레드에 공유</li>
  <li>new 명령어로 생성된 인스턴스와 객체가 저장되는 구역</li>
  <li>GC의 대상</li>
</ul>

<blockquote>
  <p><strong>Young Generation</strong>
객체가 처음 할당되는 영역
객체가 생성되고, 살아남은 객체는 Survivor 영역으로 이동</p>
</blockquote>

<blockquote>
  <p><strong>Old Generation</strong>
Young Generation을 거쳐 오래 살아남은 객체들이 할당되는 영역
메모리에서 생존 기간이 긴 객체들이 이곳에 저장된다.</p>
</blockquote>

<blockquote>
  <p><strong>Permanent Generation (PermGen, JDK 8 이전)</strong>
클래스 메타데이터, 상수, 메서드, 클래스 정보 등 저장</p>
</blockquote>

<blockquote>
  <p><strong>Metaspace (JDK 8 이후)</strong>
메타 데이터를 저장하는 공간
메서드 영역과 유사한 역할이나 네이티브 메모리 영역에서 관리</p>
</blockquote>

<p>힙은 JVM에서 가장 큰 메모리 영역이며, 모든 스레드가 공유한다.<br />
GC가 주기적으로 힙 메모리를 청소하여 사용되지 않는 객체를 제거한다.</p>

<h4 id="pc-register">PC Register</h4>
<ul>
  <li><strong>각 스레드마다 하나씩 생성</strong></li>
  <li>현재 실행 중인 JVM 명령어의 주소를 가리킴(포인터 역할로 메서드가 호출될 때마다 갱신)</li>
  <li>자바 바이트코드의 각 명령어는 PC 레지스터에 의해 추적되며, JVM이 다음에 실행할 명령어를 결정하는데 사용한다.</li>
  <li>JVM 은 스택 기반의 가상 머신으로 CPU에 직접 접근하지 않고 Stack에서 주소를 가져온다</li>
</ul>

<p>일반적으로 프로그램의 실행은 CPU에서 명령어를 수행하는 과정으로 이루어진다. CPU는 컴퓨터의 연산을 실행하고 제어하는 가장 중요한 일을 맡고 있다. 이 CPU가 연산을 수행하는 동안 필요한 정보를 CPU 내의 기억장치를 이용해 기억하는데 이를 PC register라고 한다.
하지만 자바는 OS 입장에서 단순히 하나의 프로세스이기때문에 JVM을 사용한다. 그래서 CPU에 직접 연산을 수행하는 것이 아닌 현재 작업하는 내용을 CPU에게 연산으로 제공해야하며, 이때 필요한 공간으로 PC register 라는 메모리 영역을 만든 것이다. 
따라서 JVM은 스택프레임에 있는 Operand라는 스택 영역에서 명령어를 뽑아서 PC regtster에 저장한 후 CPU에게 명령을 전달한다.</p>

<h4 id="stack-area">Stack Area</h4>
<ul>
  <li><strong>각 스레드마다 하나씩 생성</strong></li>
  <li>호출된 메소드의 파라미터, 지역 변수, 리턴 값 및 연산 값 등이 저장되는 영역</li>
  <li>메소드가 호출될때마다 스택 프레임이라 불리는 블럭이 하나씩 생성되고 메서드 실행이 종료되면 삭제된다.</li>
  <li>스택 오버플로우 발생시 JVM은 해당 스레드에 대해 예외를 발생시킨다.</li>
  <li>LIFO</li>
</ul>

<blockquote>
  <h5 id="구성요소">구성요소</h5>
  <p><strong>스택 프레임</strong>
각 메서드 호출마다 스택 프레임이 생성되며, 메서드 실행이 끝나면 제거된다.<br />
각 스택 프레임은 메서드 호출에 대한 정보를 담는다.</p>

  <p><strong>지역 변수 배열</strong>
메서드에서 선언된 지역 변수와 매개 변수 저장</p>

  <p><strong>오퍼랜드 스택</strong>
메서드 실행 중에 연산에 필요한 값을 저장하는 공간</p>

  <p><strong>프레임 데이터</strong>
메서드의 실행 상태 저장(메서드 호출자, 리턴 주소 등)</p>
</blockquote>

<h4 id="native-method-stack">Native Method Stack</h4>
<ul>
  <li><strong>각 스레드마다 하나씩 생성</strong></li>
  <li>Java 이외의 언어에 제공되는 메소드의 정보가 저장되는 공간</li>
  <li>Java Native Interface 를 통해 바이트 코드로 저장</li>
  <li>Kernel 이 자체적으로 Stack 을 잡아 독자적으로 프로그램을 실행시키는 영역</li>
  <li>JNI 표준 규약 제공</li>
</ul>

<p>자바는 멀티 스레드 환경으로 모든 스레드는 힙 스택 영역을 공유한다.</p>

<p><br /></p>

<h3 id="execution-engine">Execution Engine</h3>
<p><img src="https://github.com/user-attachments/assets/e242ebf2-7234-47bb-8afd-6e06f7961c4f" alt="engine.png" /></p>

<p>클래스로더를 통해 Runtime Data Area에 적재된 자바 바이트 코드를 명령어 단위로 읽어서 실행하는 역할을 한다.<br />
즉, 메모리에 할당된 바이트 코드를 실행한다.</p>

<h4 id="1-인터프리터">1. 인터프리터</h4>
<p>자바 컴파일러로 변환된 자바 바이트 코드를 컴퓨터가 이해할 수 있는 Native Code로 변환하는 작업.<br />
한 줄씩 순차적으로 컴파일 하여 Native로 변환하는 작업을 하는데, 매번 컴파일을 할 때 비효율적이다.
중복된 바이트 코드에 대해서는 JIT 컴파일러를 사용한다.</p>

<h4 id="2-jit-compiler-just-in-time">2. JIT Compiler (Just-In-Time)</h4>
<p>인터프리터의 단점을 개선하기 위해 등장<br />
인터프리터가 반복되는 코드를 발견하면 JIT 컴파일러로 반복되는 코드를 모두 Native Code로 변환한다.
그 후 이것을 캐싱하고 동일한 부분이 호출되면 캐싱한 코드를 가져온다.<br />
따라서 한 번 바꾼 Native Code는 인터프리터가 더 이상 컴파일하지 않아도 된다.</p>

<p>즉, 자바 바이트코드에서 Native Code로 바꾸는 과정을 JIT에서 수행하는 것이다.</p>

<h4 id="3-garbage-collections">3. Garbage Collections</h4>
<p>JVM 상에서 더 이상 참조되지않는 객체를 메모리에서 해제시켜주는 장치</p>]]></content><author><name></name></author><category term="Java" /><summary type="html"><![CDATA[JDK (Java Development Kit) 소프트웨어 개발 도구]]></summary></entry><entry><title type="html">Redis란?</title><link href="http://localhost:4000/db/2024/08/06/redis.html" rel="alternate" type="text/html" title="Redis란?" /><published>2024-08-06T00:00:00+09:00</published><updated>2024-08-06T00:00:00+09:00</updated><id>http://localhost:4000/db/2024/08/06/redis</id><content type="html" xml:base="http://localhost:4000/db/2024/08/06/redis.html"><![CDATA[<p><img src="https://github.com/user-attachments/assets/d8ce2343-8f9b-44b8-a9e5-2530f8fa6606" alt="redis.png" /></p>

<h2 id="redis-remote-dictionary-server-란">Redis (Remote dictionary server) 란?</h2>

<p>오픈 소스 인메모리 데이터 구조의 저장소로, 주로 데이터베이스, 캐시, 메시지 브로커로 사용됩니다.
빠른 접근 속도와 다양한 데이터 구조를 지원합니다.</p>

<p>데이터를 메모리에 저장하여 빠른 접근 속도를 제공합니다. 데이터를 메모리에 저장함면 디스크 I/O 를 줄이고, 높은 성능을 유지할 수 있습니다.</p>

<p>키와 값의 구조로 저장되며 비정형 데이터를 저장, 관리합니다.</p>

<h5 id="인메모리">인메모리?</h5>

<h2 id="특징">특징</h2>
<ol>
  <li>인 메모리 저장소
    <blockquote>
      <p>데이터를 디스크가 아닌 RAM 에 저장하여 빠르게 접근하고 처리하는 방법입니다.
빠른 접근 속도를 제공하기 때문에 지연이 적고 응답시간이 빠릅니다.<br />
데이터가 서버의 메모리에 유지되기 때문에 서버가 재부팅되거나 종료되면 데이터가 사라질 수 있습니다.<br />
이를 보완하기 위해 스냅샷, 로그 등 영속성 옵션을 사용할 수 있습니다.</p>
    </blockquote>
  </li>
  <li>
    <p>다양한 데이터 구조
문자열(Strings), 리스트(Lists), 집합(Sets), 
정렬된 집합(Sorted Sets), 해시(Hashes), 비트맵(Bitmaps), 
하이퍼로그로그(HyperLogLogs), 지오스페이셜 인덱스(Geospatial Indexes) 등 다양한 데이터 구조 지원하여,
데이터의 저장과 접근을 유연하게 합니다.</p>
  </li>
  <li>
    <p>영속성
기본적으로 인메모리 데이터 저장소이지만, 데이터의 영속성을 보장할 수 있는 옵션을 제공합니다.
데이터 스냅샷을 디스크에 저장하거나(RDB), 변경 사항을 로그에 기록하여(AOF) 데이터 복구를 지원합니다.</p>
  </li>
  <li>
    <p>고급 기능
Pub/Sub : 메시지 브로커 기능을 제공하여 메시지 전달 및 구독 시스템을 구현할 수 있습니다.
트랜잭션 : 여러 명령어를 원자적으로 실행할 수 있는 기능을 제공합니다.
Lua 스크립팅 : Lua 스크립트를 사용하여 서버 측에서 복잡한 작업을 수행할 수 있습니다.</p>
  </li>
  <li>
    <p>분산 및 클러스터링 지원
레디스는 클러스터 모드와 샤딩 기능을 통해 데이터를 분산 저장하고, 대규모 데이터 처리와 고가용성을 지원합니다.
데이터를 샤딩하여 여러 노드에 분산 저장합니다. 클러스터링을 통해 고가용성과 수평적 확장을 지원합니다.
마스터-슬레이브 복제를 지원하여, 데이터를 여러 슬레이브 노드에 복제합니다. 복제를 통해 읽기 성능을 향상시키고 데이터의 고가용성을 보장합니다.</p>
  </li>
  <li>높은 성능과 확장성
단일 노드에서 수백만 개의 요청 처리</li>
</ol>

<h2 id="사용">사용</h2>
<ol>
  <li>캐시
    <ul>
      <li>자주 조회되는 데이터나 결과를 메모리에 저장하여 데이터베이스의 부하를 줄이고 응답 속도를 빠르게 합니다.</li>
    </ul>
  </li>
  <li>세션 스토리지
    <ul>
      <li>웹 애플리케이션에서 사용자 세션 정보를 저장하고 관리합니다.</li>
    </ul>
  </li>
  <li>실시간 데이터 처리
    <ul>
      <li>실시간으로 데이터를 처리하고 분석하는 데 사용됩니다.</li>
      <li>실시간 채팅 애플리케이션에서 메시지를 처리하거나 실시간 분석 대시보드에서 데이터를 스트리밍합니다.</li>
    </ul>
  </li>
  <li>큐 시스템
    <ul>
      <li>작업 큐나 메시지 큐를 구현하여 비동기 작업을 처리합니다.</li>
    </ul>
  </li>
  <li>순위 시스템
    <ul>
      <li>정렬된 집합을 사용하여 순위 시스템을 구현하고, 순위 기반의 데이터를 관리합니다.</li>
    </ul>
  </li>
</ol>]]></content><author><name></name></author><category term="DB" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">CI/CD</title><link href="http://localhost:4000/db/2024/08/06/CI-CD.html" rel="alternate" type="text/html" title="CI/CD" /><published>2024-08-06T00:00:00+09:00</published><updated>2024-08-06T00:00:00+09:00</updated><id>http://localhost:4000/db/2024/08/06/CI-CD</id><content type="html" xml:base="http://localhost:4000/db/2024/08/06/CI-CD.html"><![CDATA[<p>CI/CD 는 코드 변경 사항을 자동으로 빌드, 테스트, 배포하여
소프트웨어 개발과 배포 과정을 효율적이고 안정적으로 만드는 자동화 프로세스입니다.</p>

<p><img src="https://github.com/user-attachments/assets/3ade87c6-121c-477b-9dc0-925548ba6ed5" alt="CICDprocess.png" /></p>

<p><br /></p>

<h2 id="ci-continuous-integration-란">CI (Continuous Integration) 란?</h2>
<p>지속적인 통합이라는 의미로 개발자들이 각자의 작업을 자주 병합하여 통합하는 프로세스 입니다.
병합할 때마다 자동화된 빌드와 테스트가 실행됩니다.</p>

<p>개발자들이 작업한 코드를 자주 메인 브랜치에 병합하거나, 각 코드 변경이 올바르게 작동하는지 확인할 때 사용합니다.</p>

<p>정기적인 통합을 통해 버그를 조기에 발견한고 수정할 수 있으며, 통합 빈도가 높아지면 통합의 복잡성과 충돌이 줄어듭니다.</p>

<p><br /></p>

<h2 id="cd-continuous-delivery-deployment-란">CD (Continuous Delivery/ Deployment) 란?</h2>
<h4 id="continuous-delivery">Continuous Delivery</h4>

<p><strong>지속적인 배포</strong>는 코드가 변경될 때마다 자동으로 프로덕션 환경에 배포하는 프로세스입니다.
모든 변경 사항이 자동으로 배포되며, 개발자의 개입 없이 자동화된 테스트를 통과하면 바로 배포됩니다.</p>

<p>배포를 자동화하여 변경 사항이 가능한 빨리 사용자에겍 전달되도록 하는 것입니다.</p>

<p>빈번하게 배포가 이루어지는 상황이나, 자동화된 테스트를 통과하면 바로 배포할 수 있는 경우 사용합니다.
변경 사항이 프로덕션 환경에 빠르게 반영되기 때문에 사용자의 피드백을 필요로하고 신속하게 반영해야 하는 경우 사용합니다.</p>

<p>모든 변경 사항이 자동으로 배포되기 때문에 엄격한 자동화된 테스트와 모니터링이 필요합니다.</p>

<h5 id="시나리오">시나리오</h5>
<blockquote>
  <ol>
    <li>코드 커밋</li>
    <li>CI 서버가 코드를 빌드하고 자동화된 테스트 실행</li>
    <li>테스트 통과시 자동으로 프로덕션 환경에 배포</li>
  </ol>
</blockquote>

<p><br /></p>

<p><strong>지속적 전달</strong> 은 CI 단계에서 통합된 코드를 언제든 프로덕션 환경에 배포될 수 있도록 준비하는 프로세스입니다.
코드 변경 사항은 자동화된 테스트를 통과하고, 프로덕션 환경에 배포되기 전에 수동 검토 또는 승인 단계를 거칩니다.
따라서 배포 시점에 대한 제어가 가능합니다.</p>

<p>항상 배포 가능 상태를 유지하여, 필요한 경우 즉시 배포할 수 있어야 합니다.</p>

<p>자동화된 테스트를 통과한 후 프로덕션에 배포할 준비가 되어있지만, 최종 배포는 수동으로 이루어질 수 있습니다.</p>

<h5 id="시나리오-1">시나리오</h5>
<blockquote>
  <ol>
    <li>코드 커밋</li>
    <li>CI 서버가 코드를 빌드하고 자동화된 테스트 실행</li>
    <li>테스트 통과시 배포 가능한 상태로 준비</li>
    <li>배포 담당자나 승인자가 최종 검토 후 배포 승인</li>
    <li>프로덕션 환경에 배포</li>
  </ol>
</blockquote>

<p>통합과 배포 시간을 줄임으로서 효율성을 높일 수 있으며 코드의 품질을 높이고 안정성을 유지할 수 있습니다.</p>

<p><br /></p>
<h2 id="ci-cd-종류">CI/ CD 종류</h2>
<ul>
  <li>Jenkins : 오픈 소스 자동화 서버로, 다양한 플러그인을 통해 CI/CD 파이프라인 구축 가능</li>
  <li>CircleCI : 클라우드 기반 CI/CD 서비스</li>
  <li>TravisCI : 오픈 소스 프로젝트에 많이 사용되는 클라우드 기반 CI 서비스</li>
  <li>GitLab CI : GitLab에 내장된 CI/CD 도구로, GitLab 프로젝트와 통합하여 사용</li>
  <li>AWS CodePipeline : AWS 서비스와 통합된 CI/CD 서비스, AWS 환경에서의 배포를 자동화</li>
</ul>

<p>위의 도구들은 코드의 변경 사항을 감지하고, 자동으로 빌드 및 테스트를 수행합니다.
성공적으로 테스트를 통과한 코드를 프로덕션 환경에 배포하는 과정을 지원합니다.</p>]]></content><author><name></name></author><category term="DB" /><summary type="html"><![CDATA[CI/CD 는 코드 변경 사항을 자동으로 빌드, 테스트, 배포하여 소프트웨어 개발과 배포 과정을 효율적이고 안정적으로 만드는 자동화 프로세스입니다.]]></summary></entry><entry><title type="html">SQL Injection</title><link href="http://localhost:4000/db/2024/08/01/java-sqlinjection.html" rel="alternate" type="text/html" title="SQL Injection" /><published>2024-08-01T00:00:00+09:00</published><updated>2024-08-01T00:00:00+09:00</updated><id>http://localhost:4000/db/2024/08/01/java-sqlinjection</id><content type="html" xml:base="http://localhost:4000/db/2024/08/01/java-sqlinjection.html"><![CDATA[<p>전송 계층에서 사용하는 두 가지 주요 프로토콜</p>

<h1 id="sql-injection">SQL Injection</h1>
<p><span style="background-color:#D0E4FC"><strong>공격자가 보안상의 취약점을 노리고 쿼리에 자신이 작성한 sql 문을 입력하여 데이터베이스가 비정상적으로 동작하도록 하는 공격</strong></span></p>

<p>이 공격을 통해 데이터를 유출하거나, 데이터를 조작할 수 있습니다.</p>

<h3 id="과정">과정</h3>
<p>공격자는 웹 사이트의 입력 필드나 url 파라미터에 sql 인젝션 취약점이 있는지 파악 후, 취약점이 확인되면 쿼리에 악의적인 sql 문을 삽입합니다.
예를 들어 “admin; –” 와 같이 입력함으로써 쿼리를 변경합니다.
이로써 데이터베이스가 의도치 않은 동작을 하게 만들어 사용자의 정보를 유출할 수 있습니다.</p>

<p>이러한 작업을 통해 데이터를 유출할 수 있으며, 특정 사용자의 비밀번호를 변경, 관리자 권한을 얻어 시스텡 서버를 장악할 수 있습니다.
또한 로그인시 비밀번호 검증을 피하여 로그인이 가능합니다.</p>

<h2 id="예방하려면">예방하려면?</h2>
<p>PreparedStatement를 사용하면 드라이버가 자동으로 매개변수 값을 이스케이프 처리하여 SQL Injection 공격을 방지할 수 있습니다.</p>

<p>Hibernate와 같은 ORM 프레임워크를 사용하여 SQL 쿼리 작성을 자동화함으로써 위험을 줄일 수 있습니다.
모든 사용자의 입력을 검증하고 특수문자를 이스케이프 처리합니다.
또한 데이터베이스 권한에 최소한의 권한을 부여하는 것이 좋습니다.</p>

<p>하지만 SQL 쿼리를 동적으로 생성하는 코드에서 PreparedStatement의 파라미터 바인딩을 적절히 사용하지 않으면 여전히 취약점이 발생할 수 있습니다.
그리고 개발자가 입력 값을 제대로 검증하지 않거나, 특히 입력 값이 코드 또는 쿼리 구조의 일부로 사용되는 경우 공격에 노출될 수 있습니다.</p>

<p>따라서 입력 값의 유형, 길이, 형식 등을 철저히 검증해야 하며, 모든 변수는 반드시 PreparedStatement의 파라미터로 바인딩해야 합니다.
필요에 따라 특수 문자를 이스케이프 처리하고, 입력 값이 SQL 구조에 영향을 주지 않도록 합니다.</p>

<p>이러한 방법을 통해 Sql injection를 예방할 수 있습니다.</p>]]></content><author><name></name></author><category term="DB" /><summary type="html"><![CDATA[전송 계층에서 사용하는 두 가지 주요 프로토콜]]></summary></entry><entry><title type="html">LIKE 와 full-scan</title><link href="http://localhost:4000/db/2024/07/22/mysql-index.html" rel="alternate" type="text/html" title="LIKE 와 full-scan" /><published>2024-07-22T00:00:00+09:00</published><updated>2024-07-22T00:00:00+09:00</updated><id>http://localhost:4000/db/2024/07/22/mysql-index</id><content type="html" xml:base="http://localhost:4000/db/2024/07/22/mysql-index.html"><![CDATA[<h2 id="like">LIKE</h2>
<p>LIKE 는 SQL에서 문자열 패턴 매칭을 위해서 사용합니다.
주로 where절에서 특정 패턴과 일치하는 문자열을 검색하는데 사용할 수 있습니다.
하지만 데이터가 많아지는 경우 문제가 생길 수 있습니다.<br />
<br /><br />
<br /></p>

<h2 id="어떤-문제가-생길까">어떤 문제가 생길까??</h2>
<p>LIKE 연산자는 와일드 카드를 사용하여 패턴 매칭을 합니다.
와일드 카드가 패턴의 시작 부분에 위치하면 Mysql의 인덱스를 효과적으로 사용할 수 없습니다.
예를 들어 LIKE ‘%123’ 과 같은 패턴으로 사용하는 경우 인덱스를 사용할 수 없어 성능이 떨어질  있습니다.<br />
<br /><br />
<br /></p>

<h2 id="왜-like-abc-패턴은-인덱스를-사용할-수-없을까">왜 LIKE ‘%abc’ 패턴은 인덱스를 사용할 수 없을까?</h2>
<p>인덱스는 데이터가 정렬된 순서대로 값을 찾을 수 있도록 합니다.
인덱스를 사용하여 검색할 때 왼쪽에서 부터 일치하는 값을 찾습니다.
예를 들어 ‘abc%’와 같은 패턴은 인덱스를 사용할 수 있으나 ‘%abc’ 의 패턴의 경우 시작점이 명화하지 않기 때문에 인덱스를 사용할 수 없습니다.</p>

<p>이와 같은 패턴을 사용하는 경우 패턴 매칭을 위해 모든 데이터를 순차적으로 스캔해야 하기 때문에full table scan이 발생합니다.
데이터의 양이 많을수록 성능에 영향을 미치며, I/O 비용이 많이 발생합니다.<br />
<br />
<br /></p>

<h3 id="-으로-완전일치-검색하는-경우">’=’ 으로 완전일치 검색하는 경우</h3>
<p>인덱스를 사용하여 검색하는 것을 확인할 수 있다.
<img src="https://github.com/user-attachments/assets/5793a69e-48b4-4d3d-8044-9afbd22840b8" alt="img1.png" /><br />
<br /></p>

<h3 id="like를-이용해서-검색하는-경우">LIKE를 이용해서 검색하는 경우</h3>
<p>% 으로 시작하는 문자열을 검색하는 경우 인덱스를 사용하지 않는 것을 확인할 수 있다.
<img src="https://github.com/user-attachments/assets/1695099b-8f1e-4c03-b339-764eb26ddc7e" alt="img2.png" /><br />
<br /></p>

<ul>
  <li>%가 위에 있는 문자열을 검색하는 경우 인덱스를 사용하는 것을 확인할 수 있다.
<img src="https://github.com/user-attachments/assets/3884a4ad-1f26-49d8-a27c-63dbbf8bc682" alt="img3.png" />  <br />
<br /><br />
<br /></li>
</ul>

<h5 id="이제-속도-측면에서-확인해보자">이제 속도 측면에서 확인해보자</h5>

<h3 id="을-사용한-경우">’=’을 사용한 경우</h3>
<p><img src="https://github.com/user-attachments/assets/d44d1cbe-f203-42de-9621-5a6aad4fecee" alt="img_4.png" />
<br /><br />
<br /></p>

<h3 id="like을-사용한-경우">LIKE을 사용한 경우</h3>
<ul>
  <li>
    <p>%를 시작 부분에서 사용하는 경우
<img src="https://github.com/user-attachments/assets/5c493e49-75e5-4574-a4f4-dd8889a46733" alt="img_5.png" /> 
<br /></p>
  </li>
  <li>
    <p>%를 마지막 부분에서 사용하는 경우
<img src="https://github.com/user-attachments/assets/7fd3b0fc-179f-455b-8c5a-5f21e8cacfe8" alt="img_6.png" /></p>
  </li>
</ul>

<p>% 가 앞에 나오는 경우가 속도가 떨어지는 것을 볼 수 있다.</p>]]></content><author><name></name></author><category term="DB" /><summary type="html"><![CDATA[LIKE LIKE 는 SQL에서 문자열 패턴 매칭을 위해서 사용합니다. 주로 where절에서 특정 패턴과 일치하는 문자열을 검색하는데 사용할 수 있습니다. 하지만 데이터가 많아지는 경우 문제가 생길 수 있습니다.]]></summary></entry></feed>