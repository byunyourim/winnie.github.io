<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/Type-on-Strap/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/Type-on-Strap/" rel="alternate" type="text/html" /><updated>2024-07-18T04:30:25+09:00</updated><id>http://localhost:4000/Type-on-Strap/feed.xml</id><title type="html">Type on Strap</title><subtitle>A website with blog posts and pages</subtitle><entry><title type="html"></title><link href="http://localhost:4000/Type-on-Strap/2024/07/18/2024-06-27-annotation-configuration.html" rel="alternate" type="text/html" title="" /><published>2024-07-18T04:30:25+09:00</published><updated>2024-07-18T04:30:25+09:00</updated><id>http://localhost:4000/Type-on-Strap/2024/07/18/2024-06-27-annotation-configuration</id><content type="html" xml:base="http://localhost:4000/Type-on-Strap/2024/07/18/2024-06-27-annotation-configuration.html"><![CDATA[<h2 id="configuration">@Configuration</h2>
<blockquote>
  <p>설정 클랫스를 정의할 때 사용합니다.</p>
</blockquote>

<p>해당 클래스가 스프링 Bean 구성 클래스임을 나타내며, 스프링 컨테이너에 의해 빈으로 관리됩니다.</p>]]></content><author><name></name></author></entry><entry><title type="html"></title><link href="http://localhost:4000/Type-on-Strap/2024/07/18/2024-06-27-annotation-allargsconstructor-requiredargsconstructor.html" rel="alternate" type="text/html" title="" /><published>2024-07-18T04:30:25+09:00</published><updated>2024-07-18T04:30:25+09:00</updated><id>http://localhost:4000/Type-on-Strap/2024/07/18/2024-06-27-annotation-allargsconstructor-requiredargsconstructor</id><content type="html" xml:base="http://localhost:4000/Type-on-Strap/2024/07/18/2024-06-27-annotation-allargsconstructor-requiredargsconstructor.html"><![CDATA[<p>프로젝트 진행 중 계속해서 의존성 주입 문제가 생겼다.</p>

<p>도대체 뭘까..</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Service</span>
<span class="nd">@RequiredArgsConstructor</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SmsSenderService</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">SmsCertification</span> <span class="n">smsCertification</span><span class="o">;</span>

    <span class="nd">@Value</span><span class="o">(</span><span class="s">"${coolsms.apikey}"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">apiKey</span><span class="o">;</span>

    <span class="nd">@Value</span><span class="o">(</span><span class="s">"${coolsms.apisecret}"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">apiSecret</span><span class="o">;</span>

    <span class="nd">@Value</span><span class="o">(</span><span class="s">"${coolsms.fromnumber}"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">fromNumber</span><span class="o">;</span>
    
    <span class="c1">// 코드 생략</span>
<span class="o">}</span>


</code></pre></div></div>

<p>@RequiredArgsConstructor 와 @AllArgsConstructor 를 알아보자</p>

<p>둘 다 Lombok 에서 제공하는 어노테이션으로 코드를 간결하게 작성할 수 있도록 도와주는 역할을 합니다.</p>

<h2 id="requiredargsconstructor">@RequiredArgsConstructor</h2>
<p>클래스의 final로 선언된 필드나 @NonNull 로 표시된 필드를 기반으로 생성자를 생성합니다.
생성자는 이러한 필드들을 매개변수로 받아 초기화합니다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RequiredArgsConstructor</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>  <span class="c1">// final로 선언</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
    
    
    <span class="cm">/* 아래와 같은 생성자가 자동으로 생성됩니다.
    public User(String name, int age) {
      this.name = name;
      this.age = age;
    }
     */</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li>즉, 초기화되지 않은 final 필드의 생성자를 생성합니다.</li>
</ul>

<h2 id="allargsconstructor">@AllArgsConstructor</h2>
<p>모든 필드를 기반으로 생성자를 생성합니다.
final로 선언되지 않은 필드도 포함하여 모든 필드를 매개변수로 받는 생성자를 생성합니다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@AllArgsConstructor</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
    
    <span class="cm">/* 아래와 같은 생성자가 자동으로 생성됩니다.
    public User(String name, int age) {
      this.name = name;
      this.age = age;
    }
     */</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="value-와-requiredargsconstructor">@Value 와 @RequiredArgsConstructor?</h2>
<p>@Value 이 뭘까?</p>

<p>final 로 선언한 필드에 @Value를 사용하면?
스프링이 빈을 생성할 때 해당 필드를 초기화할 수 없기 때문에 에러가 발생합니다.
@Value 을 사용할 때는 생성자 인젝션을 사용하지 않기 때문에 @RequiredArgsConstructor 를 사용하여
생성자를 자동을 생성할 수 없습니다.</p>

<h2 id="value-와-allargsconstructor">@Value 와 @AllArgsConstructor?</h2>
<p>스프링은 빈을 초기화 할 때 @Value 어노테이션을 사용하여 외부 프로퍼티 파일에서 값을 주입할 수 있습니다.
이것은 생성자 인젝션을 지원하지 않습니다.
따라서 @AllArgsConstructor을 사용할 때는 스프링이 @Value 어노테이션을 통해 초기화할 수 없는 필드에 대해서는 생성자를 자동으로 생성하지 않습니다. 
이로 인해 apiKey, apiSecret, fromNumber 필드는 @Value 어노테이션을 통해 초기화할 수 없어서 에러가 발생합니다.</p>]]></content><author><name></name></author></entry><entry><title type="html">JWT</title><link href="http://localhost:4000/Type-on-Strap/spring/2024/07/02/spring-jwt.html" rel="alternate" type="text/html" title="JWT" /><published>2024-07-02T13:30:00+09:00</published><updated>2024-07-02T13:30:00+09:00</updated><id>http://localhost:4000/Type-on-Strap/spring/2024/07/02/spring-jwt</id><content type="html" xml:base="http://localhost:4000/Type-on-Strap/spring/2024/07/02/spring-jwt.html"><![CDATA[<p>프로젝트 중에 JWT를 사용하여서
잘 몰라서.. 공부하고자</p>

<h2 id="이전에는">이전에는?</h2>
<p>JWT가 보급되기 전에는 주로 세션 기반 인증 방식이 사용되었습니다.</p>

<p>세션의 Stateful 로 상태를 유지하는 것이 특징입니다.
세션 기반 인증은 사용자의 정보를 서버에 저장하고, 클라이언트는 세션ID를 통해
인증 상태를 유지하는 방식입니다.</p>

<p>세션은 서버 메모리나 데이터베이스에 저장되어야하기 때문에 서버 측에서 상태를 유지해야합니다.
매 요청맏마 서버와 통신해야하기 때문에 부하가 초래됩니다.</p>

<p>이러한 문제로 등장한 것이 JWT로 Stateless 인 것이 특징입니다.</p>

<h2 id="jwt">JWT</h2>
<p>JSON Web Token의 약자로 정보를 JSON 형태로 클라이언트에 저장하고 서버는 해당 토큰을 검증하여
인증을 처리하는 방식입니다.</p>

<p>토큰 안에 미리 인증에 필요한 정보를 넣어두며 매 요청마다 서버와 통신할 필요가 없습니다.
이로 인해 서버 부하와 같은 문제를 해결할 수 있습니다.</p>

<h2 id="구조">구조</h2>
<p>헤더, 페이로드, 서명 세 부분으로 구성됩니다.
헤더 부분은 알고리즘 방식과 토큰의 타입을 지합니다. 서명 생성을 위해 어떤 알고리즘을 사용할지 식별하는 부분입니다.
페이로드는 클레임이라고 불리는 정보 조각을 포함합니다.
클레임은 토큰에 추가할 정보를 의미하며 사용자 ID, 권한 정보등이 포함될 수 있습니다.
하지만 디코딩을 통해 들어있는 정보를 확이할 수 있기 때문에 민감한 정보는 포함하지 않는 것이 좋습니다.</p>

<p>서명은 토큰을 인코딩하거나 유효성 검증을 위해서 사용되는 부분으로,
헤더와 페이로드를 합친 후 비밀키를 사용하여 생성합니다.</p>

<p>서버는 클라이언트로부터 받은 토큰을 검증하기 위해 서명 부분을 해싱알고리즘과 비밀키로 다시 생성하고
이를 클라이언트가 전달한 서명과 비교합니다.
일치라면 인증이 유요한 것으로 판단합니다.</p>]]></content><author><name>winnie</name></author><category term="Spring" /><summary type="html"><![CDATA[프로젝트 중에 JWT를 사용하여서 잘 몰라서.. 공부하고자]]></summary></entry><entry><title type="html">Blocking vs Non-Blocking</title><link href="http://localhost:4000/Type-on-Strap/java/2024/07/01/java-%EB%B8%94%EB%A1%9C%ED%82%B9-%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9.html" rel="alternate" type="text/html" title="Blocking vs Non-Blocking" /><published>2024-07-01T21:40:00+09:00</published><updated>2024-07-01T21:40:00+09:00</updated><id>http://localhost:4000/Type-on-Strap/java/2024/07/01/java-%EB%B8%94%EB%A1%9C%ED%82%B9-%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9</id><content type="html" xml:base="http://localhost:4000/Type-on-Strap/java/2024/07/01/java-%EB%B8%94%EB%A1%9C%ED%82%B9-%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9.html"><![CDATA[<h2 id="blocking-vs-non-blocking">Blocking vs Non-Blocking</h2>
<p>Blocking IO는 작업이 완료될 때까지 스레드가 대기하는 방식</p>

<p>Non-Blocking IO는 작업이 완료되지 않더라도 대기하지 않고 다른 작업을 처리하는 방식</p>

<h2 id="blocking-io에서의-문제점">Blocking IO에서의 문제점</h2>
<p>입출력 작업이 완료될때 까지 다른 스레드가 대기하여야한다. 따라서 멀티 스레드 환경에서 대기시간이 오래걸릴수있다. 
많은 클라이언트의 요청을 동시에 처리할 수 없으며 블록상태가 발생할 수 있습니다.</p>

<h2 id="non-blocking-io에서의-장단점">Non-Blocking IO에서의 장단점</h2>
<p>작업이 완료될 때까지 기다리지 않고 해당 작업을 수행하는 동안 다른 작업을 수행할 수 있는 방식입니다.
요청한 작업이 완료되면, 결과를 처리할 수 있도록 콜백함수 등을 통해 알림을 받습니다.
병렬적으로 여러 작업을 처리할 수 있는 장점이 있습니다.</p>

<p>대기시간이 최소화되어 시스템이 더 효율적을 자원을 이용할 수 있으며 여러 작업을 동시에 처리하기 때문에 응답성이 향상됩니다.
비교적 적은 스레드로 많은 요청을 처리할 수 있어 스케일링에 유리합니다.
IO 작업이 많이 발생하는 환경에 효과적입니다.</p>

<p>하지만 비동기 프로그래밍으로 동기적 프로그래밍보다 복잡하며 콜백 지옥과 같은 문제가 발생할 수 있습니다.
또한 이벤트를 기반으로 동작하기 때문에 실행 흐름을 추적하거나 디버깅이 어렵습니다.</p>

<p>비동기 작업이 많아질수록 메모리 사용량이 증가할 수 있습니다.</p>

<p>주로 다수의 클라이언트 요청을 비동기로 처리할 때 사용됩니다. 또한 웹 서버에서 여러 요청을 동시에 처리하고
IO 작업이 완료될 때까지 기다리지 않고 다른 요청을 처리하는데 유용하게 사용됩니다.
대규모 데이터베이스나 파일 처리에서 비동기 IO는 시스템의 처리량을 향상 시키는데 기여할 수 있습니다.</p>

<p>구현방법에는 
가장 기본적인 방법으로 자바스크립트에서 콜백함수를 사용하거나 promise 를 사용하는 방법이 있습니다.
또한 자바의 NIO 와 같은 라이브러리를 사용하여 블로킹 IO 를 비동기적으로 처리할 수 있습니다.</p>]]></content><author><name>winnie</name></author><category term="Java" /><summary type="html"><![CDATA[Blocking vs Non-Blocking Blocking IO는 작업이 완료될 때까지 스레드가 대기하는 방식]]></summary></entry><entry><title type="html">영속성 컨텍스</title><link href="http://localhost:4000/Type-on-Strap/jpa/2024/07/01/jpa-%EC%98%81%EC%86%8D%EC%84%B1%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8.html" rel="alternate" type="text/html" title="영속성 컨텍스" /><published>2024-07-01T19:15:00+09:00</published><updated>2024-07-01T19:15:00+09:00</updated><id>http://localhost:4000/Type-on-Strap/jpa/2024/07/01/jpa-%EC%98%81%EC%86%8D%EC%84%B1%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8</id><content type="html" xml:base="http://localhost:4000/Type-on-Strap/jpa/2024/07/01/jpa-%EC%98%81%EC%86%8D%EC%84%B1%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8.html"><![CDATA[<h2 id="영속성-컨텍스트">영속성 컨텍스트</h2>
<p>JPA 는 영속성 컨텍스트라는 작은 메모리 공간을 가지고 있습니다. 이 영속성 컨텍스트는 엔티티 매니저의 생명주기와 일치하며, 엔티티를 관리하고 데이터베이스와 통신을 처리합니다.</p>

<p>하나의 영속성 컨텍스트는 트랜잭션 단위로 관리되며, 엔티티의 상태를 추적하고 엔티티를 데이터베이스와 동기화합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Service</span>
<span class="nd">@Transactional</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserService</span> <span class="o">{</span>
    
    <span class="nd">@PersistenceContext</span>
    <span class="kd">private</span> <span class="nc">EntityManager</span> <span class="n">em</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">saveUser</span><span class="o">(</span><span class="nc">User</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 엔티티를 영속성 컨텍스트에 저장</span>
        <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="nc">User</span> <span class="nf">findUser</span><span class="o">(</span><span class="nc">Long</span> <span class="n">userId</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// 1차 캐시에서 엔티티를 조회 (데이터베이스 조회 필요 없음)em.find(User.class, user.getId()) 는 JPA 에서 제공하는 메서드로 데이터베이스에 접근하여</span>
      <span class="k">return</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">User</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">userId</span><span class="o">);</span>
      <span class="n">지정된</span> <span class="n">엔티티</span> <span class="n">클래스와</span> <span class="n">키를</span> <span class="n">기반으로</span> <span class="n">엔티티를</span> <span class="n">조회합니다</span><span class="o">.</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">updateUser</span><span class="o">(</span><span class="nc">User</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// 엔티티의 상태 변경 (Dirty Checking)</span>
      <span class="nc">User</span> <span class="n">managedUser</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">User</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">user</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
      <span class="n">managedUser</span><span class="o">.</span><span class="na">setUsername</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">getUsername</span><span class="o">());</span>
      <span class="n">managedUser</span><span class="o">.</span><span class="na">setEmail</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">getEmail</span><span class="o">());</span>

      <span class="c1">// 트랜잭션이 커밋될 때 데이터베이스에 자동으로 반영됨이로써 반복적으로 조죄할 때 데이터베이스에 대한 추가적인 조회를 피할 수 있으며 성능이 향상됩니다.</span>
    <span class="o">}</span>    
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">deleteUser</span><span class="o">(</span><span class="nc">Long</span> <span class="n">userId</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 1캐시는 영속성 컨텍스트의 생명주기에 의존하기 때문에 트랜잭션이 종료되면 1차 캐시도 함께 종료됩니다. </span>
        <span class="c1">// 엔티티를 영속성 컨텍스트에서 제거</span>
        <span class="c1">// 이후에 같은 엔티티를 조회할 경 다시 데이터베이스에서 조회해야 합니다.</span>
        <span class="nc">User</span> <span class="n">user</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">User</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">userId</span><span class="o">);</span>
        <span class="n">em</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>
        <span class="c1">// 트랜잭션이 커밋될 때 데이터베이스에서 삭제됨</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="1차-캐시">1차 캐시</h4>
<p>영속성 컨텍스트의 일부로 JVM 메모리에 위치합니다. 따라서 데이터베이스에 접근하는 것보다 훨씬 빠른 접근이 가능합니다다.
엔티티의 식별자를 키로 사용하여 엔티티를 저장합니다. 이 식별자를 사용하여 빠르게 엔티티를 조회할 수 있습니다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">public</span> <span class="nc">User</span> <span class="nf">findUser</span><span class="o">(</span><span class="nc">Long</span> <span class="n">userId</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 1차 캐시에서 엔티티를 조회 (데이터베이스 조회 필요 없음)</span>
        <span class="k">return</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">User</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">userId</span><span class="o">);</span>
    <span class="o">}</span>
</code></pre></div></div>
<p>em.find(User.class, user.getId()) 메서드는 데이터베이스에서 엔티티를 조회하고 이 엔티티를 영속성 컨텍스트에 저장합니다.
이때 저장된 엔티티는 1차 캐시에 저장됩니다.
이후 동일한 엔티티를 다시 조회하는 경우 영속성 컨텍스트에서 먼저 조회하여 데이터베이스에 접근하지 않고 1차 캐시에 저장된 엔티티를 반환합니다.</p>

<p>1차 캐시를 통해 동일한 엔티티를 반복적으로 조회할 때 데이터베이스에 대한 추가적인 조회를 피할 수 있습니다
영속성 컨텍스트는 트랜잭션 범위 내에서 관리되기 때문 동일한 엔티티에 대해 일관된 상태를 유지할 수 있습니다.</p>

<p>하지만 컨텍스트의 생명주기에 의존하기 때문에 트랜잭션이 종료되면 1차 캐시도 함께 종료됩니다.
따라섯 이후에 같은 엔티티를 조회할 때는 다시 데이터베이스에서 조회해야 합니다.</p>

<p>1차 캐시는 멤모리에 저장되기 때문에 많은 수의 엔티티를 동시에 처리하 할 때 메모리 사용에 주의해야 합니다.</p>

<h4 id="지연-로딩">지연 로딩</h4>
<p>연관된 엔티티나 컬렉션을 실제로 사용할 때까지 데이터베이스에서 로딩하지 않고 필요한 시점에 로딩하는 기능입니다.</p>

<p>지연로딩은 FetchType.LAZY로 설정하며, 실제 엔티티가 필요한 시점에 데이터베이스에서 조회합니다.</p>

<p>반면에 즉시로딩(FetchType.EAGER)은 엔티티를 조회할 때 연관된 엔티티들을 즉시 한번에 조회합니다. 이는 성능 저하를 초래할 수 있으므로 주의해서 사용해야 합니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Entity
@Table(name = "orders")
public class Order {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "order_id")
    private Long id;

    @ManyToOne(fetch = LAZY)
    @JoinColumn(name = "user_id")
    private User user;

}
</code></pre></div></div>
<p>단순한 관계나 적은 데이터 양을 다룰 때는 즉시로딩을 사용하는 것이 좋습니다.
대규모 데이터를 다루거나 성능 최적화가 필요한 경우에는 지연로딩을 고려해야 합니다.
기본적으로는 지연로딩을 사용하고, 성능 문제나 데이터 접근 패턴에 따라 필요할 때 즉시로딩으로 변경하는 것이 바람직합니다.</p>

<h4 id="변경-감지">변경 감지</h4>
<p>트랜잭션 내에서 엔티티의 상태 변경을 감지하여 자동으로 데이터베이스와 동기화합니다.</p>

<p>트랜잭션 내에서 엔티티의 수정이 이루어져야 변경 감지가 동작합니다. 트랜잭션이 커밋될 때 변경 사항이 데이터베이스에 반영됩니다.
트랜잭션이 커밋되기 전까지는 데이터베이스에 변경 사항이 반영되지 않습니다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nd">@PersistenceContext</span>
    <span class="kd">private</span> <span class="nc">EntityManager</span> <span class="n">entityManager</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">updateProduct</span><span class="o">(</span><span class="nc">Long</span> <span class="n">productId</span><span class="o">,</span> <span class="nc">String</span> <span class="n">newName</span><span class="o">,</span> <span class="kt">double</span> <span class="n">newPrice</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 엔티티 조회</span>
        <span class="nc">Product</span> <span class="n">product</span> <span class="o">=</span> <span class="n">entityManager</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Product</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">productId</span><span class="o">);</span>

        <span class="c1">// 엔티티 수정</span>
        <span class="n">product</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="n">newName</span><span class="o">);</span>
        <span class="n">product</span><span class="o">.</span><span class="na">setPrice</span><span class="o">(</span><span class="n">newPrice</span><span class="o">);</span>

        <span class="c1">// 변경 감지가 발생하여 자동으로 데이터베이스에 반영됨</span>
    <span class="o">}</span>
</code></pre></div></div>
<p>별도의 save 메서드 호출이 필요하지 않습니다.</p>

<h4 id="트랜잭션-범위">트랜잭션 범위</h4>
<p>영속성 컨텍스트는 트랜잭션 범위 내에서 엔티티를 관리하므로, 트랜잭션이 커밋되거나 롤백되기 전까
엔티티의 변경 사항을 추적하고 커밋할 때 최종적으로 데이터베이스에 반영합니다.</p>]]></content><author><name>winnie</name></author><category term="JPA" /><summary type="html"><![CDATA[영속성 컨텍스트 JPA 는 영속성 컨텍스트라는 작은 메모리 공간을 가지고 있습니다. 이 영속성 컨텍스트는 엔티티 매니저의 생명주기와 일치하며, 엔티티를 관리하고 데이터베이스와 통신을 처리합니다.]]></summary></entry><entry><title type="html">JPA란</title><link href="http://localhost:4000/Type-on-Strap/jpa/2024/07/01/jpa-jpa.html" rel="alternate" type="text/html" title="JPA란" /><published>2024-07-01T17:10:00+09:00</published><updated>2024-07-01T17:10:00+09:00</updated><id>http://localhost:4000/Type-on-Strap/jpa/2024/07/01/jpa-jpa</id><content type="html" xml:base="http://localhost:4000/Type-on-Strap/jpa/2024/07/01/jpa-jpa.html"><![CDATA[<h2 id="jpa란">JPA란</h2>
<p>자바 애플리케이션에서 관계형 데이터베이스를 관리하고 조작할 수 있도록 도와주는 표준 API 입니다.
자바 객체를 데이터베이스 테이블에 매핑하여 객체지향 프로그래밍과 관계형 데이터베이스 간의 불일치를 해결합니다.</p>

<p>JPA를 사용하면 SQL쿼리를 직접 작성하지 않고도 데이터베이스 작업을 수행할 수 있습니다.</p>

<h3 id="등장-배경">등장 배경??</h3>
<p>JPA 가 등장하기 전에는 객체지향 프로그래밍 언어와 관계형 데이터베이스 간의 매핑을 직접 구현했습니다.</p>

<p>주로 JDBC를 이용하여 데이터베이스와 연결하여 쿼리를 실행하고 결과를 가져왔습니다.
Connection 으로 데이터베이스를 연결을 설정하고 관리하였습니다. 개발자는 쿼리를 직접 작성하여 데이터베이스에 보낸 후
반환된 결과를 받아 자바 객체로 매핑하는 작업을 수동을 해주어야 했습니다.
추가적으로 SQL 실행 중 발생할 수 있는 예외를 처리해야합니다.</p>

<p>SQL을 사용하여 데이터베이스와 상호작용해야 했으며, 반복적인 코드작성이 일어났습니다.
쿼리를 직접 다루기 때문에 발생할 수 있는 오류가 많고 유지보수가 어렵다는 문제가 있습니다.</p>

<p>객체 지향 언어의 클래스와 객체를 관계형 데이터베이스의 테이블과 매핑하는 과정에서 일관성을 유지하기 어려웠습니다.</p>

<p>따라서 이러한 문제를 해결하기 위해 나온 것이 ORM 입니다.</p>

<h2 id="orm-프레임워크">ORM 프레임워크</h2>
<p>객체와 데이터베이스 매핑 자동화</p>
<ul>
  <li>ORM 프레임워크는 객체와 데이터베이스 간의 매핑을 자동으로 처리해줍니다.</li>
</ul>

<p>CRUD 작업의 객체지향적 처리</p>
<ul>
  <li>CRUD(Create, Read, Update, Delete) 작업을 객체지향적으로 처리할 수 있습니다.</li>
</ul>

<p>표준화된 인터페이스 제공</p>
<ul>
  <li>JPA와 같은 ORM 프레임워크는 표준화된 인터페이스를 제공하여, 다양한 데이터베이스와도 쉽게 연동할 수 있습니다.</li>
</ul>

<p>성능 최적화 및 편의성 제공</p>
<ul>
  <li>내부적으로 캐싱, 지연로딩 등의 기법을 사용하여 성능을 최적화하고, 개발자가 데이터베이스와의 상호작용을 편리하게 처리할 수 있습니다.</li>
</ul>

<p>###
JPA는 개발자가 객체지향적으로 데이터를 다루면서 이것을 관계형 데이터베이스에 저장하고 조회할 수 있도록 도와줍니다.
객체와 테이블 간의 매핑 규칙을 정의하고 이를 바탕으로 JPA 구현체가 SQL을 생성하여 데이터베이스와 상호작용합니다.</p>

<p>ORM을 통해 객체와 데이터베이스 간의 매핑을 자동화하기 때문에 개발자는 객체지향적인 코드를 집중적으로 작성할 수 있습니다.
데이터베이스 스키마의 변경이 발생해도 JPA가 자동으로 SQL을 생성하여 매핑을 처리해주기 때문에 유지보수가 편리합니다.</p>

<h2 id="개념">개념</h2>
<ol>
  <li>엔티티
    <ul>
      <li>영속성을 가진 객체</li>
      <li>데이터베이스 테이블에 매핑되는 자바 클래스로 각 인스턴스는 테이블의 행을 나타냅니다.</li>
    </ul>
  </li>
  <li>엔티티 매니저
    <ul>
      <li>엔티티의 생명주기를 관리하고 데이터베이스와 상호작용합니다.</li>
      <li>엔티티를 저장, 삭제, 조회하는 등의 작업을 수행합니다.</li>
    </ul>
  </li>
  <li>영속성 컨텍스트
    <ul>
      <li>엔티티 객체를 관리하는 메모리상의 공간입니다.</li>
      <li>데이터베이스와의 상호작용을 중재하는 역할을 합니다.</li>
    </ul>
  </li>
  <li>JPQL
    <ul>
      <li>엔티티 객체를 대상으로 쿼리를 작성합니다.</li>
    </ul>
  </li>
</ol>

<h5 id="영속성persistence이란">영속성(Persistence)이란?</h5>
<blockquote>
  <p>데이터를 일시적인 저장소가 아닌 영구적인 저장소에 저장하는 것을 의미합니다.
영속성을 통해 프로그램이 종료되더라도 데이터가 손실되지 않고 유지될 수 있으며 시스템의 오류나 충돌이 발생했을 때
데이터를 복구할 수 있습니다.
여러 프로그램이나 사용자가 동일한 데이터를 사용할 수 있으며 트랜잭션을 통해 데이터의 일관성을 유지할 수 있습니다.
ex) 
데이터를 데이터베이스에 저장하여 프로그램이 종료되더라도 데이터가 유지되도록 합니다.
데이터를 파일에 저장하여 프로그램이 종료되더라도 데이터가 파일에 남아있도록 합니다.</p>
</blockquote>

<p>JPA에서의 “영속성”은 엔티티 객체의 생명 주기 중 하나로, 엔티티 객체가 영속성
컨텍스트에 의해 관리되는 상태를 말합니다.
엔티티 객체를 영속성 컨텍스트에 저장하고 이를 통해 데이터베이스와의 지속적인 동기화를 관리합니다.</p>

<p>자바에서는 JPA를 사용하여 영속성을 관리할 수 있습니다.
이를 통해 객체를 데이터베이스 테이블에 매핑하고 CRUD 작업을 쉽게 수행할 수 있습니다.</p>

<h5 id="영속성-컨텍스트">영속성 컨텍스트</h5>
<p>엔티티 매니저가 관리하는 엔티티 객체들의 집합입니다.
영속성 컨텍스트는 엔티티 객체를 캐시로 관리하여 데이터베이스와의 상호작용을 최적화하고 객체 상태의 변경을
추적합니다.</p>

<p>엔티티 객체를 메모리에 저장하고 관리하며 이를 통해 엔티티 객체가 데이터베이스와 동기화됩니다.
엔티티 객체를 메모리에 캐싱하여, 동일한 트랜잭션 내에서 반복적인 데이터베이스 접근을 줄입니다. (1차 캐시)
엔티티의 상태 변화를 감지하여 트랜잭션이 커밋될 때 변경된 내용을 데이터베이스에 반영합니다.딩 (변경감지)
필요한 시점에 데이터베이스에서 데이터를 로드하는 기능을 제공합니다. (지연로딩)</p>

<h6 id="엔티티-객체의-생명-주기">엔티티 객체의 생명 주기</h6>
<ul>
  <li>
    <p>비영속 (Transient)
엔티티 객체가 영속성 컨텍스트에 의해 관릳되지 않은 상태입니다.
데이터베이스와 연관이 없습니다.</p>
  </li>
  <li>
    <p>영속 (Persistent)
엔티티 객체가 영속성 컨텍스트에 의해 관리되는 상태입니다.
엔티티 매니저를 통해 데이터베이스에 저장됩니다.</p>
  </li>
  <li>
    <p>준영속 (Detached)
한 번 영속상태 였지만 현재는 영속성 컨텍스트에 의해 관리되지 않는 상태입니다.
영속성 컨텍스트가 닫히거나 detch() 메서드를 호출하여 엔티티가 분리될 때 발생합니다.</p>
  </li>
  <li>
    <p>삭제 (Removed)
엔티티 객체가 영속성 컨텍스트에 의해 삭제된 상태입니다.
데이터베이스에서 해당 엔티티가 삭제됩니다.</p>
  </li>
</ul>

<h2 id="주요-어노테이션">주요 어노테이션</h2>
<ol>
  <li>@Entity : 클래스가 엔티티임을 선언합니다.</li>
  <li>@Table : 엔티티와 매핑되는 데이터베이스 테이블을 지정합니다.</li>
  <li>@Id : 엔티티의 기본키를 지정합니다.</li>
  <li>@GeneratedValue : 기본키 값을 자동으로 생성하는 전략을 지정합니다.</li>
  <li>@Column : 엔티티 필드와 매핑되는 데이터베이스 컬럼을 지정합니다.</li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"user"</span><span class="o">)</span>
<span class="nd">@NoArgsConstructor</span><span class="o">(</span><span class="n">access</span> <span class="o">=</span> <span class="nc">AccessLevel</span><span class="o">.</span><span class="na">PROTECTED</span><span class="o">)</span>
<span class="nd">@Getter</span> <span class="nd">@Setter</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">User</span><span class="o">{</span>
    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span><span class="o">(</span><span class="n">strategy</span> <span class="o">=</span> <span class="nc">GenerationType</span><span class="o">.</span><span class="na">IDENTITY</span><span class="o">)</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"user_id"</span><span class="o">,</span> <span class="n">updatable</span> <span class="o">=</span> <span class="kc">false</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">email</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">password</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">phone</span><span class="o">;</span>
    
<span class="o">}</span>
</code></pre></div></div>

<p>JPA는 자동으로 엔티티와 데이터베이스 테이블 간의 매핑을 처리해주기때문에 개발자는 별도의 SQL 쿼리를 작성할 필요가 없습니다.</p>]]></content><author><name>winnie</name></author><category term="JPA" /><summary type="html"><![CDATA[JPA란 자바 애플리케이션에서 관계형 데이터베이스를 관리하고 조작할 수 있도록 도와주는 표준 API 입니다. 자바 객체를 데이터베이스 테이블에 매핑하여 객체지향 프로그래밍과 관계형 데이터베이스 간의 불일치를 해결합니다.]]></summary></entry><entry><title type="html">Db Index</title><link href="http://localhost:4000/Type-on-Strap/2024/06/27/db-index.html" rel="alternate" type="text/html" title="Db Index" /><published>2024-06-27T00:00:00+09:00</published><updated>2024-06-27T00:00:00+09:00</updated><id>http://localhost:4000/Type-on-Strap/2024/06/27/db-index</id><content type="html" xml:base="http://localhost:4000/Type-on-Strap/2024/06/27/db-index.html"><![CDATA[<hr />
<p>title: index와 B-tree, Hash인덱스
author: winnie
date: 2024-06-28 10:00:00 +0800
categories: [DB]
render_with_liquid: false
–</p>

<h2 id="인덱스란">인덱스란</h2>
<blockquote>
  <p>데이터베이스 테이블에서 데이터를 빠르게 검색할 수 있도록 도와주는 데이터 구조</p>
</blockquote>

<p>인덱스는 테이블 내의 1개 또는 여러 개의 컬럼을 이용하여 생성할 수 있습니다. 인덱스는
데이터베이스의 테이블과 별도로 저장되며, 인덱스를 저장하기 위한 추가적인 저장공간이 필요합니다.</p>

<p>테이블의 특정 컬럼에 대해서 인덱스를 생성하면, 해당 컬럼의 데이터를 정렬한 후 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장됩니다.</p>

<ul>
  <li>키 값 : 인덱스가 참조하는 컬럼 값</li>
  <li>포인터/ 참조 : 실제 데이터가 저장된 테이블의 행을 가리키는 포인터</li>
</ul>

<p>해당 컬럼의 값을 키로 사용하기 때문에 테이블 전체를 스캔하지 않고 원하는 데이터를 찾을 수 있습니다.</p>

<p>이는 검색속도를 향상시킵니다 <strong>정렬된 상태로 저장이 되기 때문에</strong> 정렬된 데이터에 빠르게 접근할 수 있습니다.</p>

<h2 id="장점">장점</h2>
<p>인덱스를 이용하면 특정 키 값을 빠르게 검색할 수 있습니다. 이는 인덱스가 정렬된 상태이기 때문입니다.
정렬된 데이터 구조이기 때문에 비트리 인덱스와 같은 알고리즘을 사용하여 데이터를 빠르게 찾을 수 있습니다.
인덱스를 사용하면 전체 테이블을 스캔하지 않고 원하는 데이터를 찾을 수 있습니다. 따라서 더 빠른 응답시간을 제공할 수 있습니다.</p>

<p>정렬되지 않은 데이터의 경우 특정 키 값을 찾기 위해 데이터를 순차적으로 스캔해야 하기 때문에 선형 검색을 수행해야 합니다.
따라서 데이터가 많아질수록 검색 속도가 느려질 수 있습니다.</p>

<h2 id="단점">단점</h2>
<p>인덱스는 추가적인 저장공간을 필요로 하기 때문에 데이터베이스의 크기가 증가할 수 있습니다.
또한 데이터의 삽입, 삭제, 수정시 인덱스도 리밸런싱되어야 하기 때문에 오버헤드가 발생할 수 있습니다.</p>

<p>키를 기준으로 검색하는 경우 빠른 속도를 기대할 수 있으나 다른 컬럼을 기준으로 검색하는 경우 해당 컬럼이 인덱스로 지정되지 않은 경우
성능 저하가 발생할 수 있습니다. 
따러서 자주 사용되는 검색 조건에 대해 적절한 인덱스를 생성하고 관리하는 것이 중요합니다.</p>

<h2 id="언제-사용해야-할까">언제 사용해야 할까?</h2>
<p>특정 컬럼이 자주 검색 조건으로 사용될 때 인덱스를 생성하는 것이 효율적입니다.
예로 주문 번호, 날짜, 사용자 ID 등 검색이 빈번한 컬럼은 인덱스를 통해 검색 성능을 향상시킬 수 있습니다.</p>

<p>정렬과 같은 그룹화 작업이 자주 일어나는 컬럼에 사용하는 것도 쿼리의 성능을 향상시킬 수 있습니다.
조인 연산에 사용되는 컬럼에 인덱스를 생성하거나, 범위 검색이나 부분 일치 검색을 수행할 때 사용할 수 있습니다.</p>

<p>하지만 너무 많은 인덱스를 생성하는 것은 성능 저하를 일으킬 수 있기때문에 자주 사용되는 검색 조건 등 꼭 필요한 인덱스만 생성하는 것이 좋습니다.</p>

<h2 id="인덱스의-구조">인덱스의 구조</h2>

<h4 id="b-tree-인덱스">B-tree 인덱스</h4>
<p>Balanced tree의 약자로 균형잡힌 트리 구조입니다. 모든 리프노드가 동일한 깊이에 위치합니다.
노드의 삽입 및 삭제 시 특정 규칙에 맞게 재정렬 되어 밸런스를 유지하는 트리입니다.
각 노드는 여러 키와 포인터를 가지고 있으며 키는 정렬된 상태로 저장됩니다.</p>

<p>검색시 루트 노드부터 시작하여 비교를 통해 적절한 리프노드에 도달합니다.</p>

<h4 id="해시-인덱스">해시 인덱스</h4>
<p>해시 함수를 사용하여 키 값을 해시코드로 변환하고 이를 기반으로 데이터를 저장하고 검색하는 구조입니다.
키와 값의 구조로 되어있기 때문에 해시 인덱스의는 탐색 시간이 O(1) 로 탐색 시간이 빠릅니다.</p>

<p>정확하게 일치하는 검색에 대해서는 빠르지만 범위를 검색하는 경우에는 적합하지 않습니다.</p>

<p>해시 인덱스는 데이터가 해시코드에 따라 분산되어 있습니다. 그래서 데이터를 정렬된 순서로 접근하는 것이 어렵습니다.
데이터들이 정렬되어 있지 않기 때문에 특정 기준보다 크거나 작은 값, 부등호 연에 대해 검색이 적합하지 않습니다.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[title: index와 B-tree, Hash인덱스 author: winnie date: 2024-06-28 10:00:00 +0800 categories: [DB] render_with_liquid: false –]]></summary></entry><entry><title type="html">인코딩</title><link href="http://localhost:4000/Type-on-Strap/java/2024/06/26/java-encoding.html" rel="alternate" type="text/html" title="인코딩" /><published>2024-06-26T15:10:00+09:00</published><updated>2024-06-26T15:10:00+09:00</updated><id>http://localhost:4000/Type-on-Strap/java/2024/06/26/java-encoding</id><content type="html" xml:base="http://localhost:4000/Type-on-Strap/java/2024/06/26/java-encoding.html"><![CDATA[<h2 id="인코딩">인코딩?</h2>
<p>데이터를 <strong>특정 형식으로 변환하여 저장하거나 전송할 수 있도록 하는 과정</strong>입니다.
인코딩을 통해 데이터를 안전하게 전송할 수 있으며 보다 효과적으로 저장할 수 있습니다.</p>

<p>서로 다른 시스템이나 프로그램 간의 데이터 호환성을 유지하며 데이터 전송 중 보안을 강화하고 민감한 정보를 보호합니다.
또한 데이터를 압축하여 저장 공간을 절약하거나, 특정 형식에 맞추어 데이터를 저장합니다.
데이터를 더 빠르고 안정적으로 전송할 수 있도록 최적화합니다.</p>

<h2 id="mysql-에서-html-인코딩">Mysql 에서 HTML 인코딩</h2>
<p>HTML 데이터를 데이터베이스에 저장할 때 특수문자나 HTML 태그로 인해 문제가 발생할 수 있습니다.
이러한 문제를 해결하기 위해 데이터 인코딩을 사용할 수 있습니다.</p>

<p>Mysql에서 HTML 태그를 인코딩하여 데이터베이스에 저장하려면 HTML 특수 문자를 이스케이프 처리하여야 합니다.
이를 통해 태그를 안전하게 저장하고 XSS 공격을 방지하는데 도움이 됩니다.</p>

<h2 id="방법">방법</h2>

<h4 id="apache-commons-text-라이브러리-설정">Apache Commons Text 라이브러리 설정</h4>
<p>Apache Commons Text 라이브러리 추가 필요
<script src="https://gist.github.com/byunyourim/a2abf1e3407b03227f2f92352fad79ca.js"></script></p>

<h4 id="preparedstatement">PreparedStatement</h4>
<p>HTML 데이터를 그래도 저장한다.</p>

<h4 id="base64-인코딩">Base64 인코딩</h4>
<p>바이너리 데이터를 ASCII 문자열로 변환하는 방법입니다. 이를 통해 바이너리 텍스트 형식의 데이터베이스나
텍스트 전송 프로토콜을 통해 안전하게 전송하고 저장할 수 있습니다.
HTML 데이터를 Base64로 인코딩하면, 특수 문자를 포함하는 HTML 태그를 안전하게 데이터베이스에 저장할 수 있습니다.
<script src="https://gist.github.com/byunyourim/1fa777e2bd9137e9c59b37f7b0b7d269.js"></script></p>

<h2 id="그-외-종류">그 외 종류</h2>
<p><strong>ASCII 인코딩 (American Standard Code for Information Interchange)</strong>
가장 오래된 인코딩 방식 중 하나로, 7비트로 표현되며 영문 알파벳, 숫자, 특수 문자를 포함하며, 
확장된 형태 8비트의 ASCII도 있습니다.</p>

<p><strong>UTF-8 (Unicode Transformation Format - 8-bit)</strong>
현재 가장 일반적으로 사용되는 문자 인코딩 방식으로 유니코드(Unicode)를 위한 다양한 문자를 다룰 수 있습니다. 
가변 길이 문자 인코딩 방식으로, ASCII와 호환되며 다국적 텍스트 처리에 적합합니다.</p>

<p><strong>UTF-16</strong>
유니코드 문자를 16비트 단위로 인코딩하는 방식입니다. 
주로 한글, 한자 등 다국적 문자 처리에 사용됩니다.</p>

<p><strong>UTF-32</strong>
유니코드 문자를 32비트 단위로 인코딩하는 방식입니다. 
모든 문자를 고정 길이로 표현할 수 있으며, UTF-16과 UTF-8에 비해 메모리 공간을 많이 사용합니다.</p>

<p><strong>URL 인코딩 (Percent Encoding)</strong>
URL에 사용할 수 없는 문자나 특수 문자를 ‘%XX’와 같은 형태로 인코딩하는 방식입니다.</p>

<p><strong>HTML 엔티티 인코딩</strong>
HTML 문서에서 사용할 수 없는 문자나 특수 기호를 대체 문자열(&amp;, &lt;, &gt;, 등)로 변환하는 방식입니다.</p>]]></content><author><name>winnie</name></author><category term="Java" /><summary type="html"><![CDATA[인코딩? 데이터를 특정 형식으로 변환하여 저장하거나 전송할 수 있도록 하는 과정입니다. 인코딩을 통해 데이터를 안전하게 전송할 수 있으며 보다 효과적으로 저장할 수 있습니다.]]></summary></entry><entry><title type="html">해시</title><link href="http://localhost:4000/Type-on-Strap/java/2024/06/21/algorithm-hash.html" rel="alternate" type="text/html" title="해시" /><published>2024-06-21T15:10:00+09:00</published><updated>2024-06-21T15:10:00+09:00</updated><id>http://localhost:4000/Type-on-Strap/java/2024/06/21/algorithm-hash</id><content type="html" xml:base="http://localhost:4000/Type-on-Strap/java/2024/06/21/algorithm-hash.html"><![CDATA[<h2 id="mysql">Mysql?</h2>
<p>데이터를 특정 형식으로 변환하여 저장하거나 전송할 수 있도록 하는 과정입니다.
인코딩을 통해 데이터를 안전하게 전송할 수 있으며 보다 효과적으로 저장할 수 있습니다.</p>

<p>서로 다른 시스템이나 프로그램 간의 데이터 호환성을 유지하며 데이터 전송 중 보안을 강화하고 민감한 정보를 보호합니다.
또한 데이터를 압축하여 저장 공간을 절약하거나, 특정 형식에 맞추어 데이터를 저장합니다.
데이터를 더 빠르고 안정적으로 전송할 수 있도록 최적화합니다.</p>

<h2 id="hikaricp">HikariCP</h2>
<p>HTML 데이터를 데이터베이스에 저장할 때 특수문자나 HTML 태그로 인해 문제가 발생할 수 있습니다.
이러한 문제를 해결하기 위해 데이터 인코딩을 사용할 수 있습니다.</p>

<p>Mysql에서 HTML 태그를 인코딩하여 데이터베이스에 저장하려면 HTML 특수 문자를 이스케이프 처리하여야 합니다.
이를 통해 태그를 안전하게 저장하고 XSS 공격을 방지하는데 도움이 됩니다.</p>

<h2 id="방법">방법</h2>

<h4 id="apache-commons-text-라이브러리-설정">Apache Commons Text 라이브러리 설정</h4>
<p>Apache Commons Text 라이브러리 추가 필
<script src="https://gist.github.com/byunyourim/a2abf1e3407b03227f2f92352fad79ca.js"></script></p>

<h4 id="preparedstatement">PreparedStatement</h4>
<p>HTML 데이터를 그래도 저장한다.</p>

<h4 id="base64-인코딩">Base64 인코딩</h4>
<p>바이너리 데이터를 ASCII 문자열로 변환하는 방법입니다. 이를 통해 바이너리 텍스트 형식의 데이터베이스나
텍스트 전송 프로토콜을 통해 안전하게 전송하고 저장할 수 있습니다.
HTML 데이터를 Base64로 인코딩하면, 특수 문자를 포함하는 HTML 태그를 안전하게 데이터베이스에 저장할 수 있습니다.
<script src="https://gist.github.com/byunyourim/1fa777e2bd9137e9c59b37f7b0b7d269.js"></script></p>

<h2 id="종류">종류</h2>
<p><strong>ASCII 인코딩 (American Standard Code for Information Interchange)</strong>
가장 오래된 인코딩 방식 중 하나로, 7비트로 표현되며 영문 알파벳, 숫자, 특수 문자를 포함하며, 
확장된 형태 8비트의 ASCII도 있습니다.</p>

<p><strong>UTF-8 (Unicode Transformation Format - 8-bit)</strong>
현재 가장 일반적으로 사용되는 문자 인코딩 방식으로 유니코드(Unicode)를 위한 다양한 문자를 다룰 수 있습니다. 
가변 길이 문자 인코딩 방식으로, ASCII와 호환되며 다국적 텍스트 처리에 적합합니다.</p>

<p><strong>UTF-16</strong>
유니코드 문자를 16비트 단위로 인코딩하는 방식입니다. 
주로 한글, 한자 등 다국적 문자 처리에 사용됩니다.</p>

<p><strong>UTF-32</strong>
유니코드 문자를 32비트 단위로 인코딩하는 방식입니다. 
모든 문자를 고정 길이로 표현할 수 있으며, UTF-16과 UTF-8에 비해 메모리 공간을 많이 사용합니다.</p>

<p><strong>Base64 인코딩</strong>
이진 데이터를 ASCII 문자로만 이루어진 문자열로 변환하는 인코딩 방식입니다. 
주로 이메일 첨부 파일 전송이나 데이터 URL 스키마와 같은 컨텍스트에서 사용됩니다.</p>

<p><strong>URL 인코딩 (Percent Encoding)</strong>
URL에 사용할 수 없는 문자나 특수 문자를 ‘%XX’와 같은 형태로 인코딩하는 방식입니다.</p>

<p><strong>HTML 엔티티 인코딩</strong>
HTML 문서에서 사용할 수 없는 문자나 특수 기호를 대체 문자열(&amp;, &lt;, &gt;, 등)로 변환하는 방식입니다.</p>]]></content><author><name>winnie</name></author><category term="Java" /><summary type="html"><![CDATA[Mysql? 데이터를 특정 형식으로 변환하여 저장하거나 전송할 수 있도록 하는 과정입니다. 인코딩을 통해 데이터를 안전하게 전송할 수 있으며 보다 효과적으로 저장할 수 있습니다.]]></summary></entry><entry><title type="html">Statement 와 PreparedStatement</title><link href="http://localhost:4000/Type-on-Strap/java/2024/06/20/java-PreparedStatement.html" rel="alternate" type="text/html" title="Statement 와 PreparedStatement" /><published>2024-06-20T15:10:00+09:00</published><updated>2024-06-20T15:10:00+09:00</updated><id>http://localhost:4000/Type-on-Strap/java/2024/06/20/java-PreparedStatement</id><content type="html" xml:base="http://localhost:4000/Type-on-Strap/java/2024/06/20/java-PreparedStatement.html"><![CDATA[<h2 id="statement와-preparedstatement의-차이">Statement와 PreparedStatement의 차이</h2>
<p>Statement와 PreparedStatement는 둘 다 JDBC API 에서 제공하는 인터페이스입니다.</p>

<p>데이터베이스에서 쿼리를 실행할 때 쿼리를 효율적으로 실행하기 위해서 쿼리 캐싱이라는 작업을 시행합니다.
쿼리 캐싱은 쿼리를 파싱하고 최적의 실행계획을 세운 뒤 실행하는 과정입니다.</p>

<p>Statement는 쿼리를 실행할 때마다 매번 쿼리를 파싱하고 실행계획을 세우는 과정을 반복하게됩니다.</p>

<p>PreparedStatement는 한 번 쿼리가 실행된 후에는 실행계획을 따로 세우지 않고 이전의 실행계획에 파라미터만 변경하여 쿼리를 날립니다.고
따라서 처음 실행된 실행계획을 재사용함으로써 성능상에서 좋습니다.</p>

<p>보안 측면에서는 Statement는 입력값을 실제 쿼리에 문자열의 형태로 이어 붙입니다.
만약 패스워드를 검색하는 쿼리가 있다고 가정을 했을 때, 유저가 패스워드 값을 입력한 후 이어서 세미콜론을 붙이고
새로운 select * from User; 쿼리를 작성하면 노출되면 안되는 데이터들이 노출될 위험이 있습니다.
따라서 SQL injection 문제가 발생할 위험이 있습니다.</p>

<p>PreparedStatement는 입력값을 파라미터로 넘깁니다. 파라미터로 넘어가는 부분을 ? 로 표시하여 바인딩해서 처리합니다.
PreparedStatement를 사용할 때 ?(플레이스 홀)를 사용하면, 사용자 입력값이 쿼리에 직접 삽입되지 않고
JDBC 드라이버가 자동으로 매개변수 값을 이스케이프 처리합니다.
위와 같은 방식(“; select * from User;”)으로 값을 넘기게 되면 SQL injection을 했을 때 문법 에러가 발생하게 됩니다.
이렇게 쿼리와 입력 값을 분리해서 처리하기 때문에 입력값은 쿼리의 데이터로만 사용되며 쿼리 구문으로 해석되지 않습니다.
이는 SQL 인젝션 공격을 방지하는 데 매우 효과적입니다.</p>

<h2 id="preparedstatement를-사용할-때-주의해야-하는-부분">PreparedStatement를 사용할 때 주의해야 하는 부분</h2>
<p>주의사항으로는 PreparedStatement 는 AutoCloseable 를 확장하고 있기 때문에 사용 후에는 리소스를 닫아주어야 합니다.
또한 실행 전에 컴파일되기 때문에 sql 문법 오류가 생기는 경우 컴파일 시점에 예외가 발생합니다.</p>

<h2 id="preparedstatement를-사용시-발생할-수-있는-성능-이슈">PreparedStatement를 사용시 발생할 수 있는 성능 이슈</h2>
<p>캐싱을 이용하기 때문에 동일한 쿼리를 여러 번 실행할 때 성능을 최적화할 수 있습니다.
하지만 Mysql의 경우 좀 다릅니다.
쿼리는 정상적으로 오류없이 동작 하지만 내부적으로 캐싱하는 동작을 하지않습니다. 따라서 캐싱을 하기위해서는
useServerPrepStmts 와 cachePrepStmts 옵션을 설정하여야 캐싱을 활용할 수 있습니다.</p>

<p>또한 매개변수 바인딩시 적절한 데이터 타입(setString, setInt)을 사용하여 성능을 최적화할 수 있으며
대랑의 데이터 처리시 addBatch 와 executeBatch 메서드를 사용하여 배치 처리함으로써 성능을 높일 수 있습니다.</p>

<p>동일한 Sql 템플릿을 재사용하기 때문에 컴파일 비용을 줄이고 성능을 최적화합니다.</p>

<h2 id="sql-injection-공격을-예방하는-방법">SQL Injection 공격을 예방하는 방법</h2>
<p>SQL injection 공격을 막기 위해서는 매개변수를 이용해 쿼리에 값을 넣어야합니다.
PreparedStatement를 사용하면 드라이버가 자동으로 매개변수 값을 이스케이프 처리하여 SQL Injection 공격을 방지합니다.</p>

<h2 id="preparedstatement에서-batch-처리를-사용하는-경우-장점과-주의할-점">PreparedStatement에서 Batch 처리를 사용하는 경우 장점과 주의할 점</h2>
<p>Batch의 장점은 대량의 데이터를 한 번에 처리할 수 있습니다.
이로써 네트워크 비용을 줄이고 연산 횟수를 감소시킴으로써 성능을 향상시킬 수 있습니다.
또한 여러 SQL 문을 하나의 트랜잭션으로 묶어서 실행하기 때문에 데이터의 일관성이 유지됩니다.</p>

<p>주의해야할 부분은 대량의 데이터를 처리하기 때문에 메모리 부족 현상이 발생할 수 있다는 것입니다.
따라서 적절한 배치 크기를 설정해야합니다.
executeBatch() 는 쿼리의 실행 결과를 반환하지 않기 때문에 각 쿼리의 행 수 등의 정보를 확인하려면 추가적인 처리가 필요합니다.</p>]]></content><author><name>winnie</name></author><category term="Java" /><summary type="html"><![CDATA[Statement와 PreparedStatement의 차이 Statement와 PreparedStatement는 둘 다 JDBC API 에서 제공하는 인터페이스입니다.]]></summary></entry></feed>