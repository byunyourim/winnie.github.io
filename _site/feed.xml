<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-09-12T16:47:22+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Winnie’s Blog</title><subtitle>A website with blog posts and pages</subtitle><entry><title type="html">HashMap 의 구조</title><link href="http://localhost:4000/algorithm/2024/09/12/Algorithm.html" rel="alternate" type="text/html" title="HashMap 의 구조" /><published>2024-09-12T00:00:00+09:00</published><updated>2024-09-12T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2024/09/12/Algorithm</id><content type="html" xml:base="http://localhost:4000/algorithm/2024/09/12/Algorithm.html"><![CDATA[<p><strong>키-값</strong>의 쌍으로 데이터를 저장하는 자료구조</p>

<p>각 키를 해시 함수로 변환하여 배열의 인덱스에 저장하여 데이터 추가, 검색, 삭제 등의 작업을 수행한다.
키의 중복을 허용하지 않으며, 하나의 키에 하나의 값이 매핑된다.</p>

<p><img src="https://github.com/user-attachments/assets/8bffadb9-b7c8-4540-b120-da08e088dec4" alt="hashmap.png" /></p>

<p><br /></p>

<p>해시 함수는 키를 해시 코드로 변환하여 HashMap의 버킷 인덱스를 정하는데, 서로 다른 두 개의 키가 같은 해시 값을 갖는 경우가 발생한다.
이 현상을 해시 충돌이라고 한다.</p>

<p>HashMap에서는 해시 충돌을 방지하기 위해 Chaining, Open Addressing을 이용한다.</p>

<p><br /></p>

<ul>
  <li><strong>Chaining</strong><br />
충돌이 발생한 버킷 안에서 연결리스트, 트리 구조로 여러 키-값을 저장하는 방식</li>
  <li><strong>Open addressing</strong><br />
다른 빈 버킷을 찾아 데이터를 저장하는 방식</li>
</ul>

<p><img src="https://github.com/user-attachments/assets/3f8e2ac4-9be9-40fe-9861-326f10766a20" alt="hashmap2.png" /></p>

<p><br /><br /></p>

<p>자바의 HashMap은 hashCode() 메서드를 이용해 해시 값을 얻고, 배열이 찬 경우 resize() 메서드를 이용하여 
버킷 배열의 크기를 늘릴 수 있다. 기존의 항목을 새로 해싱하여 새 배열에 재분배한다.</p>

<blockquote>
  <h5 id="로드-팩터-load-factor">로드 팩터 (Load Factor)</h5>
  <p>Load Factor은 HashMap이 일정 수준 채워지면 버킷 배열을 확장할지 정하는 기준이다.
기본적으로 Java의 HashMap은 로드 팩터 0.75를 사용한다. 따라서 버킷의 75%가 차면 배열의 크기를 resizing하고 재해싱 한다.
로드 팩터를 낮게 설정하는 경우 리사이징이 더 자주 일어나며, 높게 설정하는 경우 충돌 가능성이 증가한다.</p>
</blockquote>

<p><br /></p>

<p>HashMap의 시간 복잡도는 평균적으로 <strong>O(1)</strong>이다.
하지만, 해시 충돌이 많이 발생하면, 특정 버킷에 연결된 리스트를 탐색해야 하기 때문에 시간 복잡도가  <strong>O(n)</strong>에 도달한다.
하지만, Java 8 이후 트리 구조를 사용하여 최악의 경우에도 <strong>O(log n)</strong>으로 성능을 보장할 수 있.</p>

<p><br /><br /><br /></p>

<h2 id="주요-메서드">주요 메서드</h2>
<h4 id="1-putkey-value">1. put(key, value)</h4>
<p>키와 값을 HashMap에 추가한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">dataMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;():</span>
<span class="n">dataMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"key1"</span><span class="o">,</span> <span class="s">"value1"</span><span class="o">);</span>
<span class="n">dataMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"key2"</span><span class="o">,</span> <span class="s">"value2"</span><span class="o">);</span>
<span class="n">dataMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"key3"</span><span class="o">,</span> <span class="s">"value3"</span><span class="o">);</span>
</code></pre></div></div>
<ol>
  <li>해시 함수를 통해 키를 버킷 배열의 인덱스로 변환한다.</li>
  <li>해당 버킷이 비어있는 경우 새로운 노드를 추가한다.</li>
  <li>충돌이 발생하는 경우, 연결 리스트를 순회하여 동일 키가 있는지 확인
    <ul>
      <li>동일 키가 있는 경우 값 update</li>
      <li>동일 키가 없는 경우 리스트의 끝에 새 노드 추가</li>
    </ul>
  </li>
</ol>

<p><br /></p>

<h4 id="2-getkey">2. get(key)</h4>
<p>키에 대응하는 값을 반환한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dataMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"key1"</span><span class="o">);</span>
</code></pre></div></div>
<ol>
  <li>키를 해시 함수로 변환하여 버킷의 인덱스를 찾는다.</li>
  <li>해당 버킷에 연결된 리스트를 순회하여 일치하는 키를 찾아 대응하는 값을 반환한다.</li>
  <li>키가 없는 경우 -1 또는 null 반</li>
</ol>

<p><br /></p>

<h4 id="3-removekey">3. remove(key)</h4>
<p>해당 키를 삭제한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dataMap</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="s">"key1"</span><span class="o">);</span>
</code></pre></div></div>
<ol>
  <li>키를 해시 함수로 변환해 버킷을 찾는다.</li>
  <li>해당 버킷에서 연결 리스트를 순회하여 키를 찾는다.</li>
  <li>키를 찾아 해당 노드를 리스트에서 제거한다.</li>
</ol>

<p><br /><br /><br /></p>

<h3 id="hashmap-구조">HashMap 구조</h3>
<p>버킷 배열과 노드로 구성</p>

<ul>
  <li>버킷 배열 : 키의 해시 값에 따라 값이 저장되는 배열</li>
  <li>노드 : 각 노드는 키-값과 다음 노드 정보를 갖으며, 연결리스트, 트리 형태로 연결된다.</li>
</ul>

<blockquote>
  <h4 id="버킷">버킷</h4>
  <p>배열의 한 칸으로, 해시 함수에 의해 변환된 키가 매핑되는 위치이다.
버킷 배열의 크기는 보통 2의 제곱수로 설정되어 있으며, 해시 충돌을 처리하기 위해 각 버킷에 여러 개의 키-값이 저장될 수 있다.</p>
</blockquote>

<p><br /><br /><br /></p>

<p>배열과 연결리스트의 결합으로 해시맵은 키에 대해 해시 함수를 사용해서 키가 저장될 배열의 인덱스를 정한다. 만약 서로 다른 두 키가 동일한 해시 값을
갖게 되면, 해시 충둘이 발생한다.
충돌이 발생하면, 같은 버킷에 여러 엔트리가 저장되는데, 이때 연결리스트로 연결한다.</p>

<p>자바 8 이전에는 충돌이 발생하는 경우 연결리스트를 이용하였지만, 하나의 버킷에 많은 엔트리가 저장되면,
검색 속도가 O(n)이 된다. 이를 개선하기 위해 엔트리가 일정 수준을 넘어가게되면 이진트리로 변환된다.
이진 트리는 최악의 경우에도 검색 성능이 O(log n)으로 유지된다.</p>

<p>해시코드를 이용해 데이터의 저장 위치를 빠르게 찾을 수 있으며, 검색 속도를 향상시킨다.</p>

<p><br /><br /><br /></p>

<h2 id="myhashmap-구현">MyhashMap 구현</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyHashMap</span> <span class="o">{</span>

    <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">;</span>
        <span class="nc">Node</span> <span class="n">next</span><span class="o">;</span>

        <span class="nc">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">Node</span><span class="o">[]</span> <span class="n">buckets</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">capacity</span> <span class="o">=</span> <span class="mi">10000</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MyHashMap</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">buckets</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">[</span><span class="n">capacity</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="c1">// insert or update</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">buckets</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>   <span class="c1">// 없는 경우 새로운 노드 추가</span>
            <span class="n">buckets</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>    <span class="c1">// 있는 경우 연결 리스트를 탐색, 키가 있으면 update, 없으면 node 추</span>
            <span class="nc">Node</span> <span class="n">current</span> <span class="o">=</span> <span class="n">buckets</span><span class="o">[</span><span class="n">index</span><span class="o">];</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">current</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">key</span> <span class="o">==</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">current</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
                    <span class="k">return</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">current</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
                    <span class="k">return</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">hash</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">key</span> <span class="o">%</span> <span class="n">capacity</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="nc">Node</span> <span class="n">current</span> <span class="o">=</span> <span class="n">buckets</span><span class="o">[</span><span class="n">index</span><span class="o">];</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">current</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">key</span> <span class="o">==</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">current</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">remove</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="nc">Node</span> <span class="n">current</span> <span class="o">=</span> <span class="n">buckets</span><span class="o">[</span><span class="n">index</span><span class="o">];</span>
        <span class="nc">Node</span> <span class="n">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">current</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">key</span> <span class="o">==</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">prev</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">buckets</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="n">prev</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">current</span><span class="o">;</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Algorithm" /><summary type="html"><![CDATA[키-값의 쌍으로 데이터를 저장하는 자료구조]]></summary></entry><entry><title type="html">Dependency Injection</title><link href="http://localhost:4000/spring/2024/09/06/Spring-DI.html" rel="alternate" type="text/html" title="Dependency Injection" /><published>2024-09-06T00:00:00+09:00</published><updated>2024-09-06T00:00:00+09:00</updated><id>http://localhost:4000/spring/2024/09/06/Spring-DI</id><content type="html" xml:base="http://localhost:4000/spring/2024/09/06/Spring-DI.html"><![CDATA[<p>객체지향 프로그래밍에서 <strong>객체 간의 의존성을 외부에서 주입하여 객체 간의 결합도를 낮추고, 코드의 재사용성과 유연성을 높이는 설계 패턴</strong></p>

<p>이를 통해 객체가 스스로 직접 의존성을 생성하거나 관리하는 대신, 외부에서 필요한 의존성을 주입받아서 사용한다.<br />
객체는 자신이 사용할 객체의 구현을 몰라도 되고, 인터페이스나 추상 타입에 의존한다.</p>

<h3 id="강합-결합">강합 결합?</h3>
<p>한 클래스가 다른 클래스의 구현에 직접적으로 의존하는 상황으로, 두 클래스 간의 관계를 변경하거나 유지보수가 어렵다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Engine</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Engine start!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ElectricEngine</span> <span class="kd">extends</span> <span class="nc">Engine</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Electric engine started"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Car</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Engine</span> <span class="n">engine</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">Car</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">engine</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Engine</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">startCar</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">engine</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Car started!"</span><span class="o">);</span>
    <span class="o">}</span>
    
<span class="o">}</span>
</code></pre></div></div>
<p>Car 클래스는 Engine 객체의 구현에 의존한다. 
만약 Engine이 변경되거나 다른 종류의 엔진을 사용해야 하는 경우, Car의 코드를 변경해야 한다.
그리고 테스트를 해야하는 경우 실제 Engine 객체가 필요하기 때문에 테스트가 복잡해질 수 있ㄷ사.</p>

<h5 id="구체적인-구현">구체적인 구현?</h5>
<p>클래스의 실제 행동이나 기능을 수행하는 코드를 의미한다.
Engine는 기본 엔진을 나타내는 클래스이고, ElectricEngine은 전기 엔진을 나타내는 구체적인 구현이다.
각 클래스는 start() 메서드를 다르게 구현할 수 있다.</p>

<p>Car 클래스가 특정한 Engine 객체를 직접 생성할 때, Car는 Engine의 구현에 의존하게 된다.</p>

<p>만약 Engine의 클래스가 변경 되면 Car도 변경될 수 있다.
Car 가 ElectricEngine을 사용해야 한다면, 코드를 수정해야 한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Car</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Engine</span> <span class="n">engine</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">Car</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">engine</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ElectricEngine</span><span class="o">();</span>
    <span class="o">}</span>

   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">startCar</span><span class="o">()</span> <span class="o">{</span>
      <span class="n">engine</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Car started"</span><span class="o">);</span>
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>이러한 방식은 Car가 특정한 엔진 구현에 강하게 결합되어 있어 유연성이 떨어지기 때문에, 새로운 엔진이 추가될 때마다 Car 클래스를 수정해야한다.</p>

<p>이러한 문제를 해결하기 위해 의존성 주입을 사용할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Car</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Engine</span> <span class="n">engine</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">Car</span><span class="o">(</span><span class="nc">Engine</span> <span class="n">engine</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">engine</span> <span class="o">=</span> <span class="n">engine</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">startCar</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">engine</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Car started"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>Car은 Engine의 구현에 의존하지 않고, Engine 이라는 인터페이스 또는 상위 클래스에 의존한다.
Engine 객체가 어떤 클래스인지 신경 쓰지 않아도 되고, 외부에서 주입을 받아서 사용하는 방식이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Engine</span> <span class="n">regularEngine</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Engine</span><span class="o">();</span>
<span class="nc">Car</span> <span class="n">car1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Car</span><span class="o">(</span><span class="n">regularEngine</span><span class="o">);</span>

<span class="nc">Engine</span> <span class="n">electricEngine</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ElectricEngine</span><span class="o">();</span>
<span class="nc">Car</span> <span class="n">car2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Car</span><span class="o">(</span><span class="n">electricEngine</span><span class="o">);</span>

<span class="n">car1</span><span class="o">.</span><span class="na">startCar</span><span class="o">();</span>
<span class="n">car2</span><span class="o">.</span><span class="na">startCar</span><span class="o">();</span>
</code></pre></div></div>

<h2 id="의존성-주입-방법">의존성 주입 방법</h2>
<h3 id="1-생성자-주입">1. 생성자 주입</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserService</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">UserRepository</span> <span class="n">userRepository</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">UserService</span><span class="o">(</span><span class="nc">UserRepository</span> <span class="n">userRepository</span><span class="o">)</span> <span class="o">{</span>
       <span class="k">this</span><span class="o">.</span><span class="na">userRepository</span> <span class="o">=</span> <span class="n">userRepository</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="2-setter-주입">2. Setter 주입</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserService</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">UserRepository</span> <span class="n">userRepository</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setUserRepository</span><span class="o">(</span><span class="nc">UserRepository</span> <span class="n">userRepository</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">userRepository</span> <span class="o">=</span> <span class="n">userRepository</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="3-field-주입">3. field 주입</h3>
<p>@Autowired 어노테이션을 사용하여 의존성을 필드에 직접 주입한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserService</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">UserRepository</span> <span class="n">userRepository</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>의존성 주입으로 클래스가 다른 클래스의 구현에 의존하지 않고, 인터페이스나 추상 클래스에 의존함으로써
클래스 간 결합도가 낮아진다. 
의존성 주입을 사용하면 테스트 시, 실제 객체 대신 Mock객체나 Stub 객체를 주입하여 단위 테스트가 더 용이해진다.
객체의 생성과 사용을 분리하여, 코드의 유연성과 재사용성을 높일 수 있다.</p>

<p>스프링 프레임워크는 의존성  활용한 프레임 워크로</p>]]></content><author><name></name></author><category term="Spring" /><summary type="html"><![CDATA[객체지향 프로그래밍에서 객체 간의 의존성을 외부에서 주입하여 객체 간의 결합도를 낮추고, 코드의 재사용성과 유연성을 높이는 설계 패턴]]></summary></entry><entry><title type="html">Supplier 인터페이스와 LRU</title><link href="http://localhost:4000/java/2024/09/01/java-supplier-lru.html" rel="alternate" type="text/html" title="Supplier 인터페이스와 LRU" /><published>2024-09-01T00:00:00+09:00</published><updated>2024-09-01T00:00:00+09:00</updated><id>http://localhost:4000/java/2024/09/01/java-supplier-lru</id><content type="html" xml:base="http://localhost:4000/java/2024/09/01/java-supplier-lru.html"><![CDATA[<h3 id="supplier-인터페이스">Supplier 인터페이스</h3>
<p>입력 매개변수 없이 출력을 생성하는 인터페이스<br />
<img src="https://github.com/user-attachments/assets/14423fc5-3bc1-46b8-872e-915bfcb54732" alt="supplier.png" /></p>

<p>Supplier 인터페이스는 값을 생성하거나 제공할 수 있다.</p>

<p><br /><br /><br /></p>

<h3 id="사용-사례">사용 사례</h3>

<h4 id="1-지연-초기화">1. 지연 초기화</h4>
<p>객체나 데이터를 지연 초기화하여, 실제로 필요할 때 객체를 생성하여 성능을 높일 수 있다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LazyInitializationExample</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Supplier</span><span class="o">&lt;</span><span class="nc">ExpensiveObject</span><span class="o">&gt;</span> <span class="n">expensiveObjectSupplier</span> <span class="o">=</span> <span class="k">this</span><span class="o">::</span><span class="n">createExpensiveObject</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">ExpensiveObject</span> <span class="nf">createExpensiveObject</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expensive object created"</span><span class="o">);</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">ExpensiveObject</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">ExpensiveObject</span> <span class="nf">getExpensiveObject</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">expensiveObjectSupplier</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">LazyInitializationExample</span> <span class="n">example</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LazyInitializationExample</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Before accessing expensive object"</span><span class="o">);</span>
        <span class="nc">ExpensiveObject</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">example</span><span class="o">.</span><span class="na">getExpensiveObject</span><span class="o">();</span> <span class="c1">// 이 시점에서 객체 생성</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"After accessing expensive object"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">ExpensiveObject</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">ExpensiveObject</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 복잡한 초기화 작업</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>객체의 생성이 필요할 때까지 지연되기 때문에 초기화 시점에 대한 제어가 가능하며, 따라서 불필요한 리소스 사용을 줄일 수 있다.</p>

<p><br /></p>

<h4 id="2-기본-값-제">2. 기본 값 제</h4>
<p>어떤 메서드에서 기본적으로 사용될 값을 Supplier를 통해 정의할 수 있다.
코드에서 반복적으로 사용되는 기본값을 관리하거나, 다양하나 상황에서 기본 값을 다르게 설정할 때 용이하다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.function.Supplier</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DefaultValueExample</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Supplier</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">defaultNameSupplier</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="s">"Default Name"</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">name</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">name</span> <span class="o">:</span> <span class="n">defaultNameSupplier</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">DefaultValueExample</span> <span class="n">example</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DefaultValueExample</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">example</span><span class="o">.</span><span class="na">getName</span><span class="o">(</span><span class="kc">null</span><span class="o">));</span> <span class="c1">// 출력: Default Name</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">example</span><span class="o">.</span><span class="na">getName</span><span class="o">(</span><span class="s">"John"</span><span class="o">));</span> <span class="c1">// 출력: John</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="3-캐싱">3. 캐싱</h4>
<p>특정 계산의 결과를 캐싱할 수 있다.
최초 계산 후 캐시하여 이후 호출시 동일한 값을 반환하도록 한다. 값을 재사용함으로써 성능을 최적화할 수 있다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.function.Supplier</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemoizationExample</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Supplier</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">expensiveCalculation</span> <span class="o">=</span> <span class="k">this</span><span class="o">::</span><span class="n">calculate</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">Integer</span> <span class="nf">calculate</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Performing expensive calculation..."</span><span class="o">);</span>
        <span class="k">return</span> <span class="mi">42</span><span class="o">;</span> <span class="c1">// 복잡한 계산의 결과</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">Integer</span> <span class="nf">getCalculationResult</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">expensiveCalculation</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">MemoizationExample</span> <span class="n">example</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MemoizationExample</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">example</span><span class="o">.</span><span class="na">getCalculationResult</span><span class="o">());</span> <span class="c1">// 첫 번째 호출: 계산 수행</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">example</span><span class="o">.</span><span class="na">getCalculationResult</span><span class="o">());</span> <span class="c1">// 두 번째 호출: 캐시된 결과 반환</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<h4 id="4-흐름-제어">4. 흐름 제어</h4>
<p>코드의 실행 흐름을 유연하게 제어할 수 있으며, 조건에 따라 특정 코드를 실행하거나 실행하지 않도록 설정할 수 있다.
특정 값이나 객체의 생성 타이밍을 설정할 수 있고, 반복적인 코드의 중복을 줄일 때 유용하.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.function.Supplier</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ControlFlowExample</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Supplier</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">debugMessageSupplier</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="s">"Debug: Something went wrong!"</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">performAction</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">debug</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">debug</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">debugMessageSupplier</span><span class="o">.</span><span class="na">get</span><span class="o">());</span> <span class="c1">// 디버그 메시지 출력</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Action performed successfully"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ControlFlowExample</span> <span class="n">example</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ControlFlowExample</span><span class="o">();</span>
        <span class="n">example</span><span class="o">.</span><span class="na">performAction</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>  <span class="c1">// 디버그 모드</span>
        <span class="n">example</span><span class="o">.</span><span class="na">performAction</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span> <span class="c1">// 일반 모드</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p><br /><br /><br /></p>

<h2 id="supplier와-캐싱-최적화-전략">Supplier와 캐싱 최적화 전략</h2>
<p>캐싱 최적화를 통해 속도를 개선하고, 자원을 절약하고 캐시된 데이터를 최신 상태를 유지할 수 있다.
주로 자주 조회되는 데이터, 높은 비용, 제한된 자원, 데이터가 최신으로 유지되어야 하는 경우에 캐싱 전략을 최적화 한다.</p>

<h4 id="1-캐시-만료-시간-설정">1. 캐시 만료 시간 설정</h4>
<p>캐시된 데이터가 오랫동안 사용되지 않으면, 그 데이터는 오래된 정보가 될 수 있습니다. 이 경우 만료 시간을 설정하여 데이터의 신선도를 유지하고, 필요하지 않은 데이터를 자동으로 제거할 수 있습니다.
Supplier를 사용하여 만료 시간에 따라 새로 계산된 값을 캐싱할 수 있습니다.</p>

<h4 id="2lru-least-recently-used-캐싱-알고리즘">2.LRU (Least Recently Used) 캐싱 알고리즘</h4>
<p>가장 오랫동안 사용되지 않은 데이터를 우선적으로 제거하여, 메모리 사용을 최적화할 수 있습니다. LinkedHashMap과 같은 자료구조를 사용하여 LRU 캐시를 쉽게 구현할 수 있습니다.
Supplier는 LRU 캐시 내에서 데이터를 처음 요청받을 때 실제로 값을 생성할 수 있는 방법으로 사용될 수 있습니다.</p>

<h4 id="3cache-invalidation">3.Cache Invalidation</h4>
<p>캐시된 데이터가 더 이상 유효하지 않을 때, 수동 또는 자동으로 캐시를 무효화하는 전략입니다. 이는 최신 데이터가 필요하거나, 특정 이벤트가 발생했을 때 유용합니다.
위의 CachedValue 클래스에서 invalidateCache 메서드는 수동으로 캐시를 무효화할 수 있는 방법을 제공합니다.</p>

<h4 id="4lazy-loading">4.Lazy Loading</h4>
<p>처음에 데이터를 로드하지 않고, 필요할 때만 데이터를 로드하는 전략입니다. 이 전략은 초기 로딩 시간을 줄이고, 불필요한 리소스 사용을 방지합니다.
Supplier는 Lazy Loading을 구현하는 데 필수적인 도구로, 값이 필요할 때만 생성되도록 할 수 있습니다.</p>

<h4 id="5동시성-제어">5.동시성 제어</h4>
<p>여러 스레드가 동시에 캐시에 접근하는 경우, 캐시의 일관성을 유지하기 위한 동시성 제어가 필요합니다. ConcurrentHashMap과 같은 스레드 안전한 자료구조를 사용하거나, synchronized 블록을 사용하여 동시성 문제를 해결할 수 있습니다.</p>

<p><br /><br /><br /></p>

<h2 id="least-recently-used-lru">Least Recently Used (LRU)?</h2>
<p>가장 오랫동안 사용되지 않은 데이터를 우선적으로 캐시에서 제거하는 방법으로, 이를 통해 최근에 사용한 데이터는 캐시에 유지할 수 있다.</p>

<p>메모리가 제한된 환경에서 오래된 데이터는 제거하고 최신 데이터를 유지하여 메모리를 효율적으로 관리할 수 있다. 또한 자주 사용되는 데이터에 빠르게 접근할 수 있도록 하여 성능을 높일 수 있따. 또한 최신의 데이터를 유지하여 일관성을 보장할 수 있다.</p>

<p>LRU 알고리즘의 핵심은 각 데이터의 사용 시점(최근 사용 시간)을 추적하는 것입니다. 일반적인 구현 방식은 다음과 같습니다:</p>

<p>데이터 접근 시점 갱신: 데이터를 접근(읽기/쓰기)할 때마다 그 데이터의 최근 사용 시간을 갱신합니다.
캐시 가득 참: 캐시가 가득 차서 새로운 데이터를 추가해야 할 경우, 가장 오랫동안 사용되지 않은 데이터를 제거합니다.
새로운 데이터 추가: 제거된 자리에 새로운 데이터를 추가합니다.</p>

<p>LRU 캐싱은 종종 다음과 같은 자료구조를 사용하여 구현됩니다:</p>

<p>이중 연결 리스트 (Doubly Linked List): 노드의 삽입, 삭제가 효율적으로 수행됩니다. 가장 최근에 사용된 데이터를 리스트의 앞쪽에 위치시키고, 가장 오래된 데이터를 리스트의 뒤쪽에 위치시킵니다.
해시맵 (HashMap): 데이터의 빠른 조회와 참조를 위해 사용됩니다. 키를 통해 해당 노드를 빠르게 찾을 수 있습니다.</p>

<p><br /></p>

<h3 id="lru-캐싱-알고리즘의-데이터-구조">LRU 캐싱 알고리즘의 데이터 구조</h3>
<p>LinkedHashMap을 사용하여 LRU 캐싱 알고리즘을 구현할 때 중요한 부분은 새로운 데이터가 추가될 때마다 해당 데이터를 가장 최근에 사용된 데이터로 갱신하는 것이다. 
최근에 사용된 데이터를 LinkedHashMap의 뒤로 이동시키고, 가장 앞에 있는 데이터를 LRU 데이터로 판별하여 삭제하는 메커니즘을 구현하다. 또한, 삭제될 때를 예측하여 불필요한 데이터를 즉시 삭제하는 것이 중요합니다. 
이러한 구현을 통해 LinkedHashMap를 사용한 LRU 캐싱 알고리즘을 효과적으로 운영할 수 있다.</p>

<ul>
  <li>HashMap을 확장한 구조</li>
  <li>doubleLinkedList 형태</li>
</ul>

<h4 id="doublelinkedlist">DoubleLinkedList?</h4>
<p>LinkedList를 이중으로 사용하여 요소의 순서를 유지하는 리스트이다.
자바의 링크드리스트는 더블링크드리스트로 구현되어있다.</p>

<p>LinkedHashMap에는 accessOrder 이라는 값이 있다.</p>

<p>Entry 에 access 하는 mode를 나타낸다</p>
<ul>
  <li>true : access 빈도 낮은 것부터 접근</li>
  <li>false : 입력된 순서로 Entry 에 접근</li>
</ul>

<p>linkedList는 키와 값 뿐만아니라 next, after, before를 가지고 있다.</p>

<p>before : 이 노드 앞에 삽입된 노드를 가리킴
after : 이 노드 뒤에 삽입된 노드를 가리킴
key : 제공된 키
value : 제공된 값
next : 배열 테이블의 동일한 버킷에 있는 다음 노드를 가리킴</p>

<p>HashMap과의 차이
HashMap을 확장한 구조이기 때문에 HashMap의 장점 + 순서보장을 할 수 있는 구조가 linkedHashMap라고 할 수 있다.
순서 지정 기능으로 인해 HashMap보다 더 많은 메모리가 필요하다.
시간복잡도는 HashMap과 동일하게 get,put,remove,containsKey 메소드를 호출할 때 O(1)을 가진다.
HashMap과 마찬가지로 동기화 처리가 되어있지 않기 때문에 multi-thread환경에서 사용은 적절하지 않다는 특징을 가지고 있다.</p>

<p>LinkedHashMap 를 사용하여 LRU 캐싱 알고리즘을 구현하고, 데이터를 접근할 때마다 해당 데이터의 “사용 시간” 또는 “접근 시간”을 업데이트하여 최근에 사용된 데이터를 파악할 수 있고, 
이를 바탕으로 가장 오랫동안 사용되지 않은 데이터를 식별하고 처리할 수 있습니다.</p>

<p><br /></p>

<h3 id="lru-캐싱-알고리즘을-구현할-때-고려해야-할-핵심-요소는-무엇인가요">LRU 캐싱 알고리즘을 구현할 때 고려해야 할 핵심 요소는 무엇인가요?</h3>
<p>LinkedHashMap을 이용해 LRU 캐싱을 구현할 수 있다. 
LinkedHashMap은 기본적으로 이중 연결 리스트와 해시맵의 조합 형태로 동작한다.
LinkedHashMap의 생성자에서 accessOrder 파라미터를 true로 설정하면, 데이터가 접근될 때마다 노드가 리스트의 앞쪽으로 이동하게 되어 LRU 캐싱이 자동으로 구현한.</p>

<p>이 코드에서 removeEldestEntry 메서드는 캐시의 크기가 설정된 용량을 초과할 때 가장 오래된 항목을 자동으로 제거합니다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.LinkedHashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LRUCache</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">LinkedHashMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">capacity</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">LRUCache</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">capacity</span><span class="o">,</span> <span class="mf">0.75f</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">capacity</span> <span class="o">=</span> <span class="n">capacity</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">removeEldestEntry</span><span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">eldest</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">capacity</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<ol>
  <li>시간 복잡도 최적화
빠른 데이터 접근: 캐시된 데이터를 빠르게 접근할 수 있어야 합니다. 이를 위해 보통 HashMap을 사용하여 O(1) 시간 복잡도로 데이터를 검색할 수 있게 합니다.
빠른 데이터 갱신: 데이터의 삽입, 삭제 및 갱신 작업도 O(1) 시간 복잡도로 이루어져야 합니다. 이 작업은 일반적으로 <strong>이중 연결 리스트(Doubly Linked List)</strong>와 같은 자료 구조를 활용하여 구현합니다. 이중 연결 리스트를 사용하면 캐시된 항목을 리스트의 처음이나 끝으로 쉽게 이동시킬 수 있습니다.</li>
  <li>메모리 효율성
메모리 사용량: HashMap과 이중 연결 리스트를 함께 사용하면 캐시 효율성이 높아지지만, 추가적인 메모리 오버헤드가 발생합니다. 따라서 메모리 사용량과 성능 간의 균형을 고려하여 캐시 크기를 설정해야 합니다.
캐시 크기 설정: 캐시 크기가 너무 작으면 빈번한 캐시 미스가 발생하고, 너무 크면 메모리 낭비가 발생할 수 있습니다. 시스템의 메모리 제한과 실제 사용 패턴을 기반으로 적절한 캐시 크기를 설정해야 합니다.</li>
  <li>캐시 갱신 정책
데이터 삽입 시 정책: 새로운 데이터가 캐시에 삽입되면, 이를 가장 최근에 사용된 데이터로 간주하고 이중 연결 리스트의 맨 앞에 배치합니다.
캐시 크기 초과 시 정책: 캐시가 가득 찼을 때 새로운 데이터를 추가해야 하는 경우, 이중 연결 리스트의 맨 끝에 있는, 즉 가장 오랫동안 사용되지 않은 데이터를 제거합니다.</li>
  <li>동시성 관리
스레드 안전성: 멀티스레드 환경에서 캐시가 안전하게 작동하도록 동기화가 필요합니다. Java에서는 ConcurrentHashMap이나 synchronized 키워드를 사용하여 데이터의 일관성을 유지합니다. 하지만 동기화는 성능 저하를 유발할 수 있으므로 필요한 부분에만 최소한으로 적용해야 합니다.</li>
  <li>캐시의 초기화 및 무효화
캐시 초기화: 시스템 시작 시 캐시를 미리 채우거나, 캐시가 가득 찼을 때 특정 조건에 따라 캐시를 초기화할 수 있어야 합니다.
캐시 무효화: 데이터가 갱신되거나 시스템 환경이 변할 때, 캐시의 특정 데이터를 무효화할 필요가 있습니다. 이를 통해 캐시가 최신 상태를 유지하도록 할 수 있습니다.</li>
  <li>추가적인 최적화 기법
사용 패턴 분석: 캐시 사용 패턴을 분석하여 LRU 외에 다른 캐싱 전략이 더 적합한지 평가할 수 있습니다. 예를 들어, 자주 사용되는 데이터는 캐시에 오래 남도록 하는 전략을 추가할 수 있습니다.
다중 레벨 캐싱: 메모리와 디스크 또는 네트워크 캐시를 조합한 다중 레벨 캐싱을 고려할 수 있습니다. 메모리에 여유가 없을 때 디스크 기반 캐시를 사용하여 적중률을 높일 수 있습니다.</li>
</ol>]]></content><author><name></name></author><category term="Java" /><summary type="html"><![CDATA[Supplier 인터페이스 입력 매개변수 없이 출력을 생성하는 인터페이스]]></summary></entry><entry><title type="html">Lambda 와 함수형 인터페이스</title><link href="http://localhost:4000/java/2024/09/01/java-lamda.html" rel="alternate" type="text/html" title="Lambda 와 함수형 인터페이스" /><published>2024-09-01T00:00:00+09:00</published><updated>2024-09-01T00:00:00+09:00</updated><id>http://localhost:4000/java/2024/09/01/java-lamda</id><content type="html" xml:base="http://localhost:4000/java/2024/09/01/java-lamda.html"><![CDATA[<p><br /></p>

<p>람다 표현식은 <strong>자바의 메서드 하나의 식으로 간결하게 표현한 것</strong> 이다.</p>

<p><br /></p>

<p>이전에는 자바에서 메서드를 표현하려면 클래스를 정의해야 했다. 하지만 자바 8 부터 람다식을 통해 메서드의 이름과 반환값을 
생략할 수 있고, 이를 변수에 넣어 코드를 간결하게 한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">add</span> <span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">;</span> 
<span class="o">}</span>


<span class="c1">// 이는 아래와 같이 변경할 수 있다.</span>
<span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">;</span>
</code></pre></div></div>

<p><br /></p>

<p><strong>(매개변수) -&gt; {함수 본문}</strong> 의 형태로,</p>

<p>매개 변수가 없는 경우 () 를 사용하고, 매개 변수가 하나 인 경우 괄호를 생략할 수 있으며, 
함수의 본문이 하나인 경우 중괄호와 return을 생략할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 매개변수가 없고, 표현식이 하나</span>
<span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"hello"</span><span class="o">):</span>

<span class="c1">// 매개 변수가 하나</span>
<span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="o">;</span>

<span class="c1">// 매개변수가 여러 개이고, 본문이 여러 줄</span>
<span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /><br /><br /></p>

<h2 id="람다-표현식의-특징">람다 표현식의 특징</h2>

<h3 id="1-간결하다">1. 간결하다</h3>
<p>람다 표현식을 사용하면 코드가 간결해진다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 익명 클래스로 Runnable 구현</span>
<span class="nc">Runnable</span> <span class="n">r1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello, World!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">};</span>

<span class="c1">// 람다 표현식으로 Runnable 구현</span>
<span class="nc">Runnable</span> <span class="n">r2</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello, World!"</span><span class="o">);</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="2-익명성">2. 익명성</h3>
<p>람다 표현식은 익명함수로, 함수의 이름을 정의하지 않고 사용할 수 있다.</p>

<blockquote>
  <h5 id="익명-함수란">익명 함수란?</h5>
  <p>이름이 없는 함수로, 익명 함수는 모두 일급 객체이다.
일급 객체인 함수는 변수처럼 사용이 가능하며, 매개변수로 전달이 가능하다.</p>
</blockquote>

<p><br /></p>

<h3 id="3-타입-추론">3. 타입 추론</h3>
<p>람다 표현식에서는 컴파일러가 타입을 추론할 수 있기 때문에, 매개변수의 타입을 명시적으로 지정하지 않아도 된다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 타입 명시</span>
<span class="nc">Function</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stringLength1</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>

<span class="c1">// 타입 추론</span>
<span class="nc">Function</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stringLength2</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="4-클로저-지원">4. 클로저 지원</h3>
<p>자신이 선언된 스코프의 변수에 접근할 수 있다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LambdaExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">number</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>  
        <span class="nc">Runnable</span> <span class="n">r</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">number</span><span class="o">);</span>

        <span class="n">r</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>  <span class="c1">// 출력: 10</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="5-고차-함수-지원">5. 고차 함수 지원</h3>
<p>람다 표현식은 고차 함수를 지원한다. 
고차 함수는 다른 함수를 매개변수로 받거나, 함수를 반환하는 함수이다.</p>

<p>람다식을 이용하면, 고차 함수를 쉽게 정의하고 사용할 수 잇따.</p>

<p>람다 표현식을 사용하여 코드를 더 간결하게 할 수 있다. filter 메서드를 이용해 조건을 나타내는 람다 표현식을 매개변수로 받아 필터링을 쉽게 구현할 수 있다.</p>

<p>또한 이런 filter 메서드는 여러 상황에서 재사용할 수 있다. 조건만 다르게 해서 재사용할 수 있기 때문에, 코드의 중복이 줄고 유지보수가 쉽다.</p>

<p>컬렌션의 필터링, 매핑, 집계 등 여러 작업을 람다를 이용해서 간결하게 처리할 수 있으며, 재사용성을 높인다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.function.Function</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LambdaExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Function</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Function</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">add</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">;</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">add</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="na">apply</span><span class="o">(</span><span class="mi">3</span><span class="o">));</span>  <span class="c1">// 출력: 5</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="6-병렬-처리-가능">6. 병렬 처리 가능</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LambdaExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">);</span>

        <span class="c1">// 병렬 처리</span>
        <span class="n">list</span><span class="o">.</span><span class="na">parallelStream</span><span class="o">()</span>
            <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
            <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="7-함수형-인터페이스-구현">7. 함수형 인터페이스 구현</h3>
<p>함수형 인터페이스는 하나의 추상 메서드를 갖는 인터페이스이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FunctionalInterfaceExample</span> <span class="o">{</span>

   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

      <span class="nc">MyFunctionInterface</span> <span class="n">add</span> <span class="o">=</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">;</span>
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">add</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">3</span><span class="o">));</span>
   <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 함수형 인터페이스 정의</span>
<span class="nd">@FunctionalInterface</span>
<span class="kd">interface</span> <span class="nc">MyFunctionInterface</span> <span class="o">{</span>
   <span class="kt">int</span> <span class="nf">execute</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="인터페이스에-추상-메서드가-여러-개라면">인터페이스에 추상 메서드가 여러 개라면?</h3>
<p>함수형 인터페이스는 추상 메서드를 하나만 갖는 인터페이스이다. 이 추상 메서드는 람다표현식을 사용하여 구현할 수 있다.</p>

<p>추상 메서드가 여러 개인 인터페이스의 경우 함수형 인터페이스가 아니기 때문에 람다 표현식으로 구현할 수 없다.<br />
만약 여러 개의 메서드가 필요한 경우에는 각각의 메서드를 분리하여 함수형 인터페이스로 만들어야 한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FunctionInterface</span>
<span class="kd">interface</span> <span class="nc">FunctionInterface</span> <span class="o">{</span>
   <span class="kt">void</span> <span class="nf">execute</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Example</span> <span class="o">{</span>
   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">FunctionInterface</span> <span class="n">function</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">Systemout</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"hello"</span><span class="o">);</span>
      <span class="n">function</span><span class="o">.</span><span class="na">execute</span><span class="o">();</span>
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="8-기존-인터페이스와-호환">8. 기존 인터페이스와 호환</h2>

<p>자바에서 제공하는 함수형 인터페이스에는 <strong>Runnable, Function, Predicate, Consumer, Supplier, Callable</strong> 등이 있다.</p>

<p><br /></p>

<h3 id="️-runnable">◾️ Runnable</h3>
<p>스레드를 실행하기 위한 함수형 인터페이스</p>

<h3 id="️-functiont-r">◾️ Function&lt;T, R&gt;</h3>
<ul>
  <li>T타입의 매개변수를 입력 받아, R 타입으로 반환하는 함수형 인터페이스</li>
  <li><strong>R apply (T t)</strong>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Function</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">lengthFunction</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">lengthFunction</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">);</span>
</code></pre></div>    </div>
    <p>입력을 받아서 출력으로 변환하며, 주로 변환 작업에 사용된다.</p>
  </li>
</ul>

<h3 id="️-predicate-t-">◾️ Predicate&lt; T &gt;</h3>
<ul>
  <li>T타입의 매개변수를 입력 받아, 조건 검사 후 boolean 값을 반환하는 함수형 인터페이스</li>
  <li><strong>boolean test(T t)</strong>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Predicate</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">isEmpty</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>
<span class="kt">boolean</span> <span class="n">result</span> <span class="o">=</span> <span class="n">isEmpty</span><span class="o">.</span><span class="na">test</span><span class="o">(</span><span class="s">""</span><span class="o">);</span> <span class="c1">// true</span>
</code></pre></div>    </div>
    <p>입력값에 대해 boolean 값을 반환하며, 조건 검증에 사용한다.</p>
  </li>
</ul>

<h3 id="️-consumer-t-">◾️ Consumer&lt; T &gt;</h3>
<ul>
  <li>T타입의 입력을 받아 동작을 수행한 후, 결과를 반환하지 않는 함수형 인터페이스이다.</li>
  <li><strong>void accept(T t)</strong>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Consumer</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">str</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
<span class="n">print</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="s">"Hello, World!"</span><span class="o">);</span>
</code></pre></div>    </div>
    <p>입력을 받아서 동작을 수행하며, 결과를 반환하지 않는다.</p>
  </li>
</ul>

<h3 id="️-supplier-t-">◾️ Supplier&lt; T &gt;</h3>
<ul>
  <li>매개변수 없이 T타입의 값을 반환하는 함수형 인터페이스로 객체를 생성하거나 값을 제공한다.</li>
  <li><strong>T get()</strong>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Supplier</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">randomSupplier</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">random</span><span class="o">()</span> <span class="o">*</span> <span class="mi">100</span><span class="o">);</span>
<span class="kt">int</span> <span class="n">randomValue</span> <span class="o">=</span> <span class="n">randomSupplier</span><span class="o">.</span><span class="na">get</span><span class="o">();</span> <span class="c1">// 임의의 정수 반환</span>
</code></pre></div>    </div>
    <p>매개 변수를 받지 않고, 값을 생성하거나 제공한다.</p>
  </li>
</ul>]]></content><author><name></name></author><category term="Java" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Stream API</title><link href="http://localhost:4000/java/2024/09/01/java-stream_api.html" rel="alternate" type="text/html" title="Stream API" /><published>2024-09-01T00:00:00+09:00</published><updated>2024-09-01T00:00:00+09:00</updated><id>http://localhost:4000/java/2024/09/01/java-stream_api</id><content type="html" xml:base="http://localhost:4000/java/2024/09/01/java-stream_api.html"><![CDATA[<h2 id="stream-api">Stream API</h2>
<p><strong>데이터 처리를 간결하고 효율적으로 할 수 있도록 도와주는 API</strong></p>

<p>Java8 부터 도입되어 컬렉션의 데이터를 함수형으로 처리할 수 있도록 해준다.
데이터 소스 (컬렉션, 배열, I/O 채널 등)에서 파이프라인 방식으로 연속적인 연산을 수행할 수 있다.</p>

<p><br /></p>

<h3 id="특징">특징</h3>
<h4 id="1-불변성">1. 불변성</h4>
<p>스트림은 기존의 데이터를 변경하지 않고, 새로운 스트림을 생성하여 작업을 수행한다.</p>

<h4 id="2-지연-연산-lazy-evaluation">2. 지연 연산 Lazy Evaluation</h4>
<p>스트림에는 중간 연산과 최종 연산이 있는데, 최종 연산이 호출될 때까지 중간 연산이 실제로 수행되지 않는 것을 말한다.
지연 연산으로 불필요한 계산이 줄어들어 성능이 최적화 될 수 있다.</p>

<h4 id="3-파이프라이닝-pipelining">3. 파이프라이닝 Pipelining</h4>
<p>여러 중간 연산을 연결하여 하나의 파이프라인을 구성할 수 있다.
파이프라인은 한 번의 최종 연산을 통해 처리 될 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">fruits</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"apple"</span><span class="o">,</span> <span class="s">"banana"</span><span class="o">,</span> <span class="s">"orange"</span><span class="o">);</span>

<span class="nc">Listt</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">fruits</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                             <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">name</span> <span class="o">-&gt;</span> <span class="n">name</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="o">)</span>
                             <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">String:</span><span class="o">:</span><span class="n">toUpperCase</span><span class="o">)</span>
                             <span class="o">.</span><span class="na">sorted</span><span class="o">()</span>
                             <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</code></pre></div></div>

<h4 id="4-함수형-프로그래밍-지원">4. 함수형 프로그래밍 지원</h4>
<p>함수형 인터페이스와 람다 표현식을 활용하여 함수형 프로그래밍을 지원하며, 이를 통해 코드를 간결하게 할 수 있다.</p>

<h4 id="5-다양한-데이터-소스-지원">5. 다양한 데이터 소스 지원</h4>
<p>Collection 인터페이스를 구현한 클래스뿐 아니라 배열, 파일 등 다양한 데이터를 사용할 수 있다.</p>

<h4 id="6-유형-스트림-지원">6. 유형 스트림 지원</h4>
<p>기본형 타입을 위한 스트림을 별도로 제공하여 박싱 비용을 줄일 수 있다.</p>

<p><br /><br /></p>

<h2 id="lazy-evaluation">Lazy Evaluation</h2>
<p>Java Stream API에서 중간 연산이 최종 연산이 호출될 때까지 실제로 수행되지 않는 것을 말한다.</p>

<h3 id="구현-방식">구현 방식</h3>
<h4 id="1-스트림을-생성한다">1. 스트림을 생성한다.</h4>
<p>스트림은 데이터의 요소들의 연속적인 데이터 흐름으로 스트림을 생성하면, 데이터를 일관된 방식으로 처리할 수 있는 파이프 라인을 만들 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">names</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"Alice"</span><span class="o">,</span> <span class="s">"Bob"</span><span class="o">,</span> <span class="s">"Charlie"</span><span class="o">);</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">nameStream</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="na">stream</span><span class="o">();</span> <span class="c1">// 스트림 생성</span>
        
<span class="nc">String</span><span class="o">[]</span> <span class="n">nameArray</span> <span class="o">=</span> <span class="o">{</span><span class="s">"Alice"</span><span class="o">,</span> <span class="s">"Bob"</span><span class="o">,</span> <span class="s">"Charlie"</span><span class="o">};</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">nameStream</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">nameArray</span><span class="o">);</span> <span class="c1">// 스트림 생성</span>
        
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">nameStream</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"Alice"</span><span class="o">,</span> <span class="s">"Bob"</span><span class="o">,</span> <span class="s">"Charlie"</span><span class="o">);</span> <span class="c1">// 스트림 생성</span>
</code></pre></div></div>

<h4 id="2-중간-연산을-정의한다">2. 중간 연산을 정의한다.</h4>
<p>중간 연산(filtter, map, sorted)이 스트림에 연결된다. 각 중간 연산은
   스트림을 변환하는 새로운 스트림을 반화하며, 실제 데이터는 처리되지 않는다.
   중간 연산은 다음 연산을 위한 연산 체인을 설정한다.</p>

<h4 id="3-최종-연산을-호출한다">3. 최종 연산을 호출한다.</h4>
<p>최종 연산(collect, forEach, reduce)이 호출되면 스트림의 데이터가 실제로 처리된다.<br />
   이때 스트림의 중간 연산이 실행된다.</p>

<p><br /></p>

<h4 id="장점">장점</h4>
<ul>
  <li>
    <p>스트림은 필요한 데이터만 처리하기 때문에 성능을 향상시킨다.</p>
  </li>
  <li>
    <p>중간 연산이 지연되어 필요한 시점에 처리되기 때문에 메모리 사용이 줄어든다.</p>
  </li>
  <li>
    <p>여러 중간 연산이 연결된 경우, 하나의 파이프라인에서 순차적으로 처리되기 때문에 불필요한 중간 결과가 생성되지 않는다.
모든 연산이 최종 연산이 호출될 때 한 번에 처리된다.</p>
  </li>
</ul>

<h4 id="단점">단점</h4>
<ul>
  <li>
    <p>지연 평가로 중간 연산이 언제 실행될지 모르기 때문에 디버깅이 복잡해질 수 있다.</p>
  </li>
  <li>
    <p>오류가 발생할 경우, 실제 실행 시점에서 오류가 발생하기 때문에 중간 연산에서 발생한 문제를 추적하기 어렵다.</p>
  </li>
</ul>

<p><br /><br /></p>

<h4 id="스트림은-데이터를-변경하지-않는다-왜">스트림은 데이터를 변경하지 않는다? 왜?</h4>
<p>스트림은 연산 과정에서 원본 데이터를 복사하는 것이 아닌, 참조된 데이터를 바탕으로 필요한 연산을 수행하여 새로운 데이터를 생성한다.</p>

<p>한 번 사용된 이후 재사용할 수 없는 일회성 객체이며, 이를 통해 원본 데이터의 불변성을 유지할 수 있다.</p>

<p>또한 참조 변수에 저장하지 않고 곧바로 연산을 수행할 수 있다. 즉, 스트림 객체를 별도로 저장하지 않고 사용하는 것이 가능하다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">names</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"apple"</span><span class="o">,</span> <span class="s">"banana"</span><span class="o">,</span> <span class="s">"coke"</span><span class="o">);</span>

<span class="n">names</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>          <span class="c1">// 스트림 생성</span>
     <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">name</span> <span class="o">-&gt;</span> <span class="n">name</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"a"</span><span class="o">))</span>   <span class="c1">// 중간연산 </span>
     <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="nl">String:</span><span class="o">:</span><span class="n">toUpperCase</span><span class="o">)</span>   <span class="c1">// 중간연산 </span>
     <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>          <span class="c1">// 최종연산</span>
</code></pre></div></div>
<p>위 코드에서는 names.stream()으로 스트림을 생성한 후, 이를 Stream<String> stream = names.stream(); 같은 참조 변수에 할당하지 않고 
바로 연산(filter, forEach)을 수행한다.</String></p>

<p>한 번 사용하면 다시 사용할 수 없는 일회성 객체로, 최종 연산이 수행되면 더 이상 해당 스트림을 사용할 수 없다.
만약 동일한 연산을 다시 수행하려면 names.stream()으로 새로 스트림을 생성해야 한다.</p>

<p>스트림의 파이프라인은 최종 연산이 호출될 때 한 번에 실행되고 그 후에 스트림은 종료된다.
다시 사용하려고 하면 IllegalStateException이 발생한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">stream</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">filter</span><span class="o">(</span><span class="n">name</span> <span class="o">-&gt;</span> <span class="n">name</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"A"</span><span class="o">));</span>
<span class="n">stream</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span> <span class="c1">// 최종 연산</span>
<span class="n">stream</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span> <span class="c1">// IllegalStateException 발생</span>
</code></pre></div></div>

<p><br /><br /><br /></p>

<h2 id="stateful--statefuless">Stateful &amp; Statefuless</h2>

<h4 id="stateful-연산-stateful-operations">Stateful 연산 (Stateful Operations)</h4>

<p>Stateful Stream 은 스트림의 중간 연산 중 이전 단계의 결과를 바탕으로 현재 연산을 수행하는 것을 말한다.<br />
전체 스트림의 상태를 추적하기 때문에 성능이 떨어질 수 있다.
sorted(), distinct() 가 있으며, 전체 데이터의 상태를 고려해야 하기 때문에 연산 중 일시적으로 전체 데이터를 저장하거나 처리해야 한다.</p>

<p>연산을 수행할 때 스트림의 요소들 간의 상태나 순서를 유지하거나 추적해야 하는 연산<br />
연산은 스트릠의 모든 요소를 고려하여 상태를 유지하거나 변경할 필요가 깅ㅅ다.
상태를 추적해야 하기 때문에 메모리 사용량이 증가하고 성능이 저하될 수 있다.
요소 간의 관계를 고려하거나, 스트림 전체를 정렬, 필터링해야 할 때 사용한다.</p>

<ul>
  <li>
    <p>sorted 
스트림의 모든 요소를 정렬하기 위해 전체 스트림을 고려한다. 요소를 정렬하려면 전체 데이터를 메모리에
로드하고 정렬해야 하기 때문에 상태를 유지한다.</p>
  </li>
  <li>
    <p>distinct
중복을 제거하기 위해 스트림의 모든 요소를 기억하고 비교해야 하기 때문에 상태를 유지한다.</p>
  </li>
</ul>

<p><br /></p>

<h4 id="stateless-연산-stateless-operations">Stateless 연산 (Stateless Operations)</h4>
<p>연산을 수행할 때 스트림의 요소 간의 상태를 유지하지 않고, 각 요소를 독립적으로 처리하는 연산<br />
요소 간의 관계를 고려하지 않는다.</p>

<p>연산은 각 요소를 독립적으로 처리하며, 이전 또는 다른 요소의 상태에 의존하지 안흔다.
상태를 유지하지 않기 때문에 메모리 사용량이 적고 성능이 좋으며, 각 요소를 독립적으로 처리하여 결과를 생성한다.</p>

<ul>
  <li>
    <p>filter()
각 요소를 개별적으로 검사하여 조건에 맞는 요소만 남기며, 다른 요소의 상태나 관계를 고려하지 않는다.</p>
  </li>
  <li>
    <p>map()
각 요소를 다른 형태로 변환하며, 이 과정에서 요소 간이 관계를 고려하지 않는다.</p>
  </li>
</ul>

<p><br /><br /><br /></p>

<h2 id="중간-연산과-최종-연산">중간 연산과 최종 연산</h2>

<p><br /></p>

<h3 id="중간-연산">중간 연산</h3>
<p>스트림 파이프라인에서 스트림을 변환하거나 필터링한다.
스트림을 변경하지 않고 새로운 스트림을 반환하며, 지연 평가를 통해 최종 연산이 호출될 때까지 실제로 수행되지 않는다.
연속해서 호출할 수 있으며, 스트림 파이프라인을 구성할 수 있다.</p>
<ul>
  <li>filter(Predicate<T>) : 조건에 맞는 요소만 필터링하여 새로운 스트림 반환
</T>    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">names</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"amy"</span><span class="o">,</span> <span class="s">"jenny"</span><span class="o">,</span> <span class="s">"bob"</span><span class="o">,</span> <span class="s">"jun"</span><span class="o">);</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">filteredStream</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="na">streaam</span><span class="o">()</span>
                                   <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">name</span> <span class="o">-&gt;</span> <span class="n">name</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"j"</span><span class="o">));</span>
</code></pre></div>    </div>
  </li>
  <li>map(Function&lt;T, R&gt;) : 각 요소를 다른 형태로 변환하여 새로운 스트림 반환
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">names</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"amy"</span><span class="o">,</span> <span class="s">"jenny"</span><span class="o">,</span> <span class="s">"bob"</span><span class="o">,</span> <span class="s">"jun"</span><span class="o">);</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">upperCaseStream</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                                    <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">String:</span><span class="o">:</span><span class="n">toUpperCase</span><span class="o">);</span>
</code></pre></div>    </div>
  </li>
  <li>sorted(Comparator<T>) : 스트릠의 요소를 정렬하여 새로운 스트림 반환
</T>    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">sortedStream</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">sorted</span><span class="o">();</span>
</code></pre></div>    </div>
  </li>
</ul>

<p><br /></p>

<h3 id="최종-연산">최종 연산</h3>
<p>스트림 파이프라인의 결과를 생성한다.
스트림의 요소를 실제로 처리하여 결과를 반환하며, 스트림이 종료되고 더 이상 사용할 수 없다. 최종 연산이 호출되면, 중간 연산이 실행된다.</p>

<h5 id="--foreachconsumer-t-">- forEach(Consumer&lt; T &gt;)</h5>
<p>스트림의 각 요소에 대해 주어진 작업 수행</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">names</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"amy"</span><span class="o">,</span> <span class="s">"jenny"</span><span class="o">,</span> <span class="s">"bob"</span><span class="o">,</span> <span class="s">"jun"</span><span class="o">);</span>

<span class="n">names</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</code></pre></div></div>

<h5 id="--collectcollectort-a-r">- collect(Collector&lt;T, A, R&gt;)</h5>
<p>스트림의 요소를 수집하여 컬렉션 또는 다른 형태의 결과 생성</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">names</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"amy"</span><span class="o">,</span> <span class="s">"jenny"</span><span class="o">,</span> <span class="s">"bob"</span><span class="o">,</span> <span class="s">"jun"</span><span class="o">);</span>

<span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">collectedNames</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
        <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</code></pre></div></div>

<h5 id="--reducebinaryoperator">- reduce(BinaryOperator<T>)</T></h5>
<p>스트림의 요소를 하나로 결합하여 단일 결과 생성</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
<span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
        <span class="o">.</span><span class="na">reduce</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="nl">Integer:</span><span class="o">:</span><span class="n">sum</span><span class="o">);</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Java" /><summary type="html"><![CDATA[Stream API 데이터 처리를 간결하고 효율적으로 할 수 있도록 도와주는 API]]></summary></entry><entry><title type="html">Event-Driven Architecture</title><link href="http://localhost:4000/java/2024/08/29/java-event-driven.html" rel="alternate" type="text/html" title="Event-Driven Architecture" /><published>2024-08-29T00:00:00+09:00</published><updated>2024-08-29T00:00:00+09:00</updated><id>http://localhost:4000/java/2024/08/29/java-event-driven</id><content type="html" xml:base="http://localhost:4000/java/2024/08/29/java-event-driven.html"><![CDATA[<p>일반적으로 API는 클라이언트가 요청한 값에 대해서 응답을 제공한다.</p>

<p>클라이언트(웹 애플리케이션, 모바일 앱, 서버)가 특정 데이터를 요청하면, API는 그 요청에 알맞은 데이터를 반환한다.</p>

<p><img src="https://github.com/user-attachments/assets/5da65ab3-e635-4092-b146-869e89a0dfee" alt="api_process.png" /></p>

<p>API는 클라이언트의 요청에 대해서만 응답을 반환하며, 클라이언트의 요청 없이 API가 데이터를 보내지 않는다.</p>

<p>하지만 API가 클라이언트의 요청 없이 데이터를 보내야 하는 상황이 있다. 클라이언트가 특정 이벤트나 조건을 즉시 알 필요가 있거나, 실시간 데이터를 지속적으로 받아야 하는 경우가 있다.</p>

<p>API가 클라이언트의 요청 없이 데이터를 주도적으로 전달하기 위해 <strong>훅, 서버-사이드 이벤트(SSE), 웹소켓, 푸시 알림, 폴링/롱 폴링</strong>과 같은 기술들이 개발되었다. 
이러한 기술은 클라이언트와 서버 간의 실시간 통신, 효율적인 데이터 전달, 그리고 더 나은 사용자 경험을 제공한다.</p>

<p><br /></p>

<p><br /></p>

<h2 id="api가-클라이언트의-요청없이-데이터를-보내는-경우">API가 클라이언트의 요청없이 데이터를 보내는 경우?</h2>
<h4 id="1-실시간-알림-시스템">1. 실시간 알림 시스템</h4>
<ul>
  <li>사용자가 메시지를 받았거나, 중요한 업데이트가 발생했을 때 이를 실시간으로 전송한다.</li>
  <li>채팅 애플리케이션, 이메일 알림, 소셜미디어 알림</li>
</ul>

<h4 id="2-실시간-데이터-스트리밍">2. 실시간 데이터 스트리밍</h4>
<ul>
  <li>실시간 스포츠 경기 데이터처럼 실시간으로 변동되는 데이터를 클라이언트가 지속적으로 받아야하는 경우</li>
  <li>주식 가격이나 환율이 실시간으로 변동할 때, 클라이언트에게 즉시 해당 데이터를 제공한다.</li>
</ul>

<h4 id="3-자동회된-작업-처리">3. 자동회된 작업 처리</h4>
<ul>
  <li>시스템에서 특정 조건이 만족되거나 이벤트가 발생했을 때, 자동으로 클라이언트에 데이터를 보내야 하는 경우</li>
  <li>주문이 완료되었을 때, 결제 시스템이 자동으로 클라이언트에게 영수증을 전송하는 경우</li>
  <li>백엔드 서버에서 데이터가 업데이트되었을 때, 관련 데이터를 자동으로 다른 서비스나 클라이언트에게 전달한다.</li>
</ul>

<h4 id="4-상태-변화-모니터링">4. 상태 변화 모니터링</h4>
<ul>
  <li>시스템의 상태가 변할 때 이를 즉시 클라이언트에 알려야 하는 경우</li>
  <li>서버의 상태가 정상에서 오류로 변경되었을 때, 이를 실시간으로 모니터링 시스템에 알린다.</li>
</ul>

<h4 id="5-트리거-기반-워크플로우">5. 트리거 기반 워크플로우</h4>
<ul>
  <li>특정 이벤트가 발생하면 워크플로우를 자동으로 시작하고, 그에 따라 클라이언트에게 데이터를 보내야하는 경</li>
</ul>

<p><br />
<br /></p>

<h4 id="웹훅webhook">웹훅(Webhook)</h4>
<p>서버가 <strong>특정 이벤트를 발생시켰을 때, 미리 정의된 url로 http 요청을 보내는 방식</strong><br />
클라이언트가 서버에 따로 요청을 보내지 않아도 서버가 클라이언트에 데이터를 전송할 수 있다.</p>
<ul>
  <li>결제 완료, 사용자 등록, 데이터베이스 업데이트 등이 발생할 때 웹훅을 통해 관련 정보를 클라이언트에 전송한다.</li>
  <li>클라이언트는 서버에 웹훅 URL을 등록하고, 서버는 특정 이벤트 발생 시 해당 URL로 HTTP POST 요청을 보낸다.</li>
</ul>

<p><br /></p>

<h4 id="서버-사이드-이벤트server-sent-events-sse">서버-사이드 이벤트(Server-Sent Events, SSE)</h4>
<p>서버가 클라이언트에 <strong>실시간 데이터를 지속적으로 스트리밍 하는 방식</strong>
클라이언트가 한 번 서번에 연결을 맺으면, 서버는 클라이언트가 연결을 끊지 않는 한 실시간으로 데이터를 계속해서 전송할 수 있다.</p>
<ul>
  <li>실시간 주식 가격 업데이트, 뉴스 피드, 실시간 알림 등</li>
  <li>클라이언트는 서버와 연결을 맺고, 서버는 그 연결을 통해 실시간으로 데이터를 전송한다. 주로 HTTP 프로토콜을 사용하며, 클라이언트는 이벤트를 수신한다.</li>
</ul>

<p><br /></p>

<h4 id="웹소켓websocket">웹소켓(WebSocket)</h4>
<p>클라이언트와 서버 간의 <strong>실시간 양방향 통신</strong>을 가능하게 하는 프로토콜<br />
연결이 한 번 성립되면, 클라이언트와 서버는 서로 데이터를 자유롭게 주고받을 수 있다.</p>
<ul>
  <li>실시간 채팅 애플리케이션, 실시간 게임, 협업 도구 등</li>
  <li>클라이언트와 서버가 처음에 핸드셰이크를 통해 웹소켓 연결을 맺으면, 이후 양방향 데이터 전송이 가능하다.</li>
</ul>

<p><br /></p>

<h4 id="푸시-알림push-notifications">푸시 알림(Push Notifications)</h4>
<p><strong>모바일 애플리케이션</strong>에서 많이 사용되는 방식으로 서버가 클라이언트(모바일)에 <strong>알림을 푸시</strong>하는 방식<br />
푸시 알림은 서버가 클라이언트의 상태에 따라 메시지를 보낸다.</p>
<ul>
  <li>메시지 알림, 새 콘텐츠 업데이트 알림 등</li>
  <li>푸시 서버를 통해 클라이언트에 알림을 전달한다. 클라이언트는 푸시 토큰을 서버에 등록해두고, 서버는 해당 토큰을 사용해
특정 클라이언트에 알림을 보낸다.</li>
</ul>

<p><br /></p>

<h4 id="폴링polling과-롱-폴링long-polling">폴링(Polling)과 롱 폴링(Long Polling)</h4>
<p><strong>클라이언트가 주기적으로 서버에 데이터를 요청</strong>하는 방식<br />
폴링은 클라이언트가 정해진 간격으로 서버에 요청을 보내고, 롱 폴링은 서버가 새로운 데이터가 있을 때까지 응답을 지연시킨 뒤
클라이언트에 응답을 보낸다.</p>
<ul>
  <li>실시간 알림에 사용되나 비효율적</li>
  <li>클라이언트가 정해진 주기로 서버에 요청을 보내거나, 롱 폴링에서 클라이언트가 요청을 보내고 서버가 새 데이터가 생길 때까지 응답을 기다린 후 데이터를 보낸다.</li>
</ul>

<p><br /></p>

<p>위의 기술들은 클라이언트와 서버 간의 실시간 통신, 효율적인 데이터 전달, 그리고 더 나은 사용자 경험을 제공하기 위해 등장했으며, 이벤트 드리븐 방식으로 처리한다.</p>

<p><br /></p>

<p><br /></p>

<p><br /></p>

<h2 id="이벤트-드리븐-event-driven-아키텍처">이벤트 드리븐 Event-Driven 아키텍처</h2>
<p><strong>이벤트를 중심으로 동작하도록 설계된 아키텍처</strong>로
특정 이벤트가 발생할 때마다, 그에 반응하는 작업이 자동으로 실행된다.</p>

<p><br /></p>

<p><br /></p>

<h4 id="이벤트-처리-과정">이벤트 처리 과정</h4>
<p><img src="https://github.com/user-attachments/assets/3b081ef7-8bb6-4496-bc65-fe25c16aa53c" alt="event_process.png" /></p>

<h3 id="event">Event</h3>
<ul>
  <li>시스템 내에서 발생하는 중요한 사건이나 상태 변화</li>
  <li>버튼 클릭, 스크롤, 데이터베이스에 새로운 항목 추가, 특정 시간에 도달 등등</li>
</ul>

<h3 id="event-source">Event Source</h3>
<ul>
  <li>시스템 내에서 중요한 상태 변화, 이벤트 감지</li>
  <li>특정 비즈니스 이벤트를 트리거한다.</li>
  <li>사용자의 행동(클릭, 입력), 시스템 내의 상태 변화(파일 생성, 데이터 업데이트) 등</li>
</ul>

<h3 id="event-producer">Event Producer</h3>
<ul>
  <li>이벤트 소스가 감지한 상태 변화, 동작을 바탕으로 이벤트 메시지 생성한다.</li>
  <li>에빈트를 준비하고 발행한다.</li>
  <li>데이터베이스에서 새로운 레코드가 생성되거나, 사용자 애플리케이션에서 특정 역할을 수행했을 때 이벤트 프로듀서가 이벤트 메시지를 생성한다.</li>
</ul>

<h3 id="event-emitter">Event Emitter</h3>
<ul>
  <li>이벤트 프로듀서가 생성한 이벤트 메시지를 시스템 내에서 전파한다.</li>
  <li>이벤트 메시지를 이벤트 브로커나 이벤트 버스로 전달한다.</li>
</ul>

<h3 id="event-message">Event Message</h3>
<ul>
  <li>이벤트에 관한 정보를 담고 있는 데이터 구조</li>
  <li>이벤트의 유형과 관련된 데이터를 포함한다.</li>
  <li>이벤트에 대한 정보를 포함하며, 시스템 내 다른 컴포넌트들이 이 정보를 통해 작업을 수행한다.</li>
</ul>

<blockquote>
  <h4 id="구성요소">구성요소</h4>
  <p><strong>이벤트 타입</strong> : 이벤트의 종류 (OrderCreated, UserSignUp)<br />
<strong>페이로드</strong> : 이벤트와 관련된 데이터 (주문 ID, 사용자 정보)<br />
<strong>메타데이터</strong> : 이벤트 발생 시간, 위치, 우선 순위 등 부가 정보</p>
</blockquote>

<h3 id="event-broker-message-queue">Event Broker/ Message Queue</h3>
<ul>
  <li>이벤트 메시지를 수신하고, 이를 관리하여 등록된 이벤트 소비자에게 전달한다.</li>
  <li>메시지 큐는 이벤트를 일시적으로 저장하고, 차례로 소비자에게 전달한다.</li>
  <li>이벤트 프로듀서와 이벤트 컨슈머 간의 비동기적 통신을 가능하게 한다.</li>
  <li>Event Producer 큐에 이벤트 메시지를 넣고, Event Consumer 큐에서 메시지를 꺼내 처리한다.</li>
  <li>Apache Kafka, RabbitMQ, Amazon SQS.</li>
</ul>

<h3 id="event-bus">Event Bus</h3>
<ul>
  <li>이벤트 메시지를 발행하고, 여러 Event Consumer에 전달한다.</li>
  <li>애플리케이션 내에서 이벤트를 라우팅하고 관리한다.</li>
  <li>대규모 마이크로서비스 아키텍처에서 여러 서비스가 이벤트 버스를 통해 서로 이벤트를 주고 받는다.</li>
</ul>

<h3 id="event-consumer">Event Consumer</h3>
<ul>
  <li>이벤트 메시지를 수신하고 그에 맞는 작업을 수행한다.</li>
  <li>Consumer은 특정 이벤트에 대해 등록되어 있으며, 이벤트가 발생하면 이를 처리한다.</li>
  <li>주문이 생성되면, 주문 처리 서비스가 그 이벤트를 받아 결제 처리를 한다.</li>
</ul>

<h3 id="event-stream">Event Stream</h3>
<ul>
  <li>연속적으로 발생하는 이벤트를 시간 순서대로 기록하는 로그 또는 데이터 구조</li>
  <li>스트림에서 발생한 이벤트들을 순차적으로 처리하며, 실시간 데이터 처리에 유용한다.</li>
  <li>Apache Kafka와 같은 시스템에서 이벤트 스트림을 관리하며, 실시간 데이터 파이프라인을 구축한다.</li>
</ul>

<p><br /></p>

<p><img src="https://github.com/user-attachments/assets/70c816a4-98eb-4eb3-8da9-08e8a834e198" alt="event1.png" /></p>

<h2 id="동작-방식">동작 방식</h2>
<h4 id="1-이벤트-발생">1. 이벤트 발생</h4>
<ul>
  <li>특정 조건이나 사용자 행동을 인해 이벤트가 발생한다.</li>
</ul>

<h4 id="2-이벤트-생성">2. 이벤트 생성</h4>
<ul>
  <li>이벤트 프로듀서가 상태 변화에 대한 이벤트 메시지를 생성한다.</li>
</ul>

<h4 id="3-이벤트-전파">3. 이벤트 전파</h4>
<ul>
  <li>이벤트 프로듀서가 생성한 이벤트 메시지를 이벤트 브로커나 이벤트 버스로 전송한다.</li>
</ul>

<h4 id="4-이벤트-전달">4. 이벤트 전달</h4>
<ul>
  <li>이벤트 브로커, 메시지 큐는 이벤트 메시지를 수신하고, 이를 관리하여 등록된 이벤트 소비자에게 전달한다.</li>
  <li>이벤트 버스는 이벤트 메시지를 애플리케이션 내에서 라우팅하고, 여러 Consumer에 전달한다.</li>
</ul>

<h4 id="5-이벤트-처리">5. 이벤트 처리</h4>
<ul>
  <li>이벤트 소비자가 이벤트 메시지를 수신한 후, 그에 맞는 작업을 수행한다.</li>
  <li>주문이 생성되었을 때 결제를 처리하거나, 이메일을 전송하는 작업이 이루어질 수 있다.</li>
</ul>

<h4 id="6-후속-작업">6. 후속 작업</h4>
<ul>
  <li>하나의 이벤트의 처리 결과로 다른 이벤트가 발생할 수 있으, 추가적인 이벤트가 발생할 수 있다.</li>
  <li>결제가 완료되면 ‘결제완료’ 이벤트가 발생하고, 이를 기반으로 배송 시스템에서 작업이 시작될 수 있다.</li>
</ul>

<p><br /></p>

<h2 id="특징">특징</h2>
<h4 id="1-비동기성-및-비차단-io">1. 비동기성 및 비차단 I/O</h4>
<p>이벤트 드리븐 모델은 비동기로 동작하ㅏ기 때문에, 작업이 완료될 때까지 프로그램이 대기하지 않고 다른 작업을 수행할 수 있다. <br />
따라서 시스템 자원을 낭비하지 않고 다른 작업을 처리할 수 있다.</p>

<h4 id="2-높은-동시성-처리">2. 높은 동시성 처리</h4>
<p>이벤트 드리븐 모델은 많은 동시 연결을 할 수 있다. 수천 개 이상의 동시 연결을 단일 스레드로 처리할 수 있기 때문에 확장성이 뛰어나다.</p>

<p><strong>스레드 기반 모델의 경우</strong> 각 연결에 대해 별도의 스레드를 생성하기 때문에 많은 연결이 발생할 경우 스레드 관리가 복잡해지고 리소스 소모가 커진다.</p>

<h4 id="3-반응성-및-사용자-경험">3. 반응성 및 사용자 경험</h4>
<p>UI 애플리케이션에서 사용자 입력에 즉각적으로 반응하여 빠른 응답을 제공하기 때문에 사용자 경험 반응성을 높일 수 있다.</p>

<h4 id="4-복잡한-상태-관리-용이">4. 복잡한 상태 관리 용이</h4>
<p>상태 기계와 같은 구조를 사용하여, 다양한 상태에서 발생하는 여러 이벤트를 효율적으로 처리할 수 있다.</p>

<h4 id="5-예측-가능성">5. 예측 가능성</h4>
<p>각 이벤트에 대한 처리가 예측이 가능하기 때문에, 시스템과 신뢰성과 유지보수성을 높일 수 있다.</p>

<p><br /></p>

<h2 id="장단점">장단점</h2>
<ul>
  <li><strong>비동기적으로 처리하기 때문에</strong>, 시스템이 더 많은 이벤트를 처리할 수 있다. (확장성)</li>
  <li>이벤트 처리 로직을 분리하여, 새로운 기능을 추가하거나 변경할 때 기존 시스템에 <strong>영향을 최소화</strong>할 수 있다. (유연성)</li>
  <li>이벤트 발생 즉시 반응할 수 있어 <strong>실시간 시스템</strong>에 용이하다.</li>
  <li>이벤트의 흐름을 추적하고 디버깅이 어려우며, 이벤트가 여러 시스템에 걸쳐 발생할 때 <strong>복잡도가 증가</strong>한다.</li>
  <li>비동기 처리로 인해 <strong>데이터의 일관성</strong>을 유지하기 어려우며, 추가적인 설계, 관리가 필요할 수 있다.</li>
  <li>이벤트나 버스의 관리 및 유지보수에 추가적인 리소스가 필요하기때문에 <strong>오버헤드가 발생</strong>할 수 있다.</li>
</ul>

<p><br /></p>

<h2 id="사용-사례">사용 사례</h2>
<ul>
  <li><strong>사용자 인터페이스</strong> : 버튼 클릭, 마우스 이동 등 사용자 입력에 반응하는 작업을 처리한다.</li>
  <li><strong>실시간 애플리케이션</strong> : 채팅 애플리케이션, 실시간 알림 등에서 이벤트를 기반으로 데이터를 전송한다.</li>
  <li><strong>마이크로서비스 아키텍처</strong> : 각 서비스가 독립적으로 이벤트를 발생시키고 이를 다른 서비스가 수신하여 처리한다.</li>
  <li><strong>IoT 시스템</strong> : 센서 데이터가 변경되거나 특정 조건이 충족될 때 이벤트를 발생시키고, 그에 대응하는 작업을 한다.</li>
</ul>

<p><br /></p>

<h2 id="msa와의-관계">MSA와의 관계</h2>
<p>마이크로서비스 아키텍처는 애플리케이션을 여러 개의 독립적인 서비스로 분리하는 설계 패턴으로 
각 서비스는 특정 비즈니스 기능을 담당하며, 독립적으로 배포, 확장, 유지보수가 가능하다.<br />
이벤트 드리븐 아키텍처는 마이크로 서비스 간 통신을 효과적으로 관리하는 데 유용하다.</p>

<p>서비스 간의 결합도를 낮추고, 서비스들이 더 독립적으로 동작하도록 한다.</p>]]></content><author><name></name></author><category term="Java" /><summary type="html"><![CDATA[일반적으로 API는 클라이언트가 요청한 값에 대해서 응답을 제공한다.]]></summary></entry><entry><title type="html">DB Lock</title><link href="http://localhost:4000/java/2024/08/29/java-dblock.html" rel="alternate" type="text/html" title="DB Lock" /><published>2024-08-29T00:00:00+09:00</published><updated>2024-08-29T00:00:00+09:00</updated><id>http://localhost:4000/java/2024/08/29/java-dblock</id><content type="html" xml:base="http://localhost:4000/java/2024/08/29/java-dblock.html"><![CDATA[<h2 id="동시성-concurrency">동시성 Concurrency</h2>

<p><strong>여러 작업이 동시에 실행되는 것처럼 보이도록 관리되는 상태</strong>로, 하나의 CPU에서 여러 작업이 실행될 때
CPU는 빠르게 작업을 전환하여 <strong>마치 여러 작업이 동시에 실행되는 것처럼</strong> 보이게 한다.</p>

<p>동시성을 활용하면 프로그램의 여러 부분이 동시에 실행되어, 더 많은 작업을 빠르게 처리할 수 있고, 자원을 효율적으로 사용하며,
응답을 향상시킬 수 있다.</p>

<p>데이터베이스는 다수의 사용자가 데이터에 동시에 접근하게된다. 여러 사용자가 데이터베이스에 접근하는 과정에서
사용자에 대한 제어가 적절하게 이루어지지 않으면 데이터의 일관성과 무결성이 깨지게 된다.</p>

<p>따라서 동시성 제어를 통해 여러 사용자가 있는 상황에서 여러 개의 트랜잭션이 동시에 수행될 때, 데이터의 일관성이 깨지지 않도록 해야한다.</p>

<p><br /></p>

<h4 id="락의-범위">락의 범위</h4>
<p>DB, 파일, 테이블, 페이지, 컬럼 등</p>

<p><br /></p>

<h2 id="낙관적-락-optimistic-lock">낙관적 락 (Optimistic Lock)</h2>
<p><img src="https://github.com/user-attachments/assets/a1976ba0-b811-4270-b8c1-6e4fc408e1a5" alt="optimistic.png" />
자원에 락을 걸지 않고, 동시성 문제가 발생하면 그때 그때 처리하는 방식이다.</p>

<p>수정 작업을 할때 수정했다고 명시하여 다른 트랜잭션이 동일한 조건으로 값을 수정할 수 없도록 하는 것이다.<br />
version과 같은 별도의 컬럼을 추가하여 충돌의 발생을 막는다.
version(hashcode/ timestamp)의 상태로 충돌을 확인하며, 충돌된 경우 롤백한다.</p>

<p>데이터 충돌이 자주 일어나지 않을 것이라고 예상되는 경우 주로 사용한다.
조회 작업이 많기 때문에 동시 접근 성능이 중요하다.</p>

<h4 id="장-단점">장 단점</h4>
<p>충돌이 안난다는 가정하에, 동시 요청에 대해서 처리 성능이 좋다.</p>

<p>그러나 충돌이 빈번하게 일어나는 경우, 롤백처리에 대한 비용이 많이 들어 성능에서 손해를 볼 수 있다.
또한, 개발자가 직접 롤백을 구현해야하기 때문에 시스템 구조에 따라 복잡해질 수 있다.</p>

<p><br />
<br />
<br />
<br />
<br /></p>

<h2 id="비관적-락-pessimistic-lock">비관적 락 (Pessimistic Lock)</h2>

<p><img src="https://github.com/user-attachments/assets/a5b7eb4f-082e-49d4-8a4b-013a4dd84d4b" alt="pessimistic.png" />
데이터베이스나 다른 공유 자원에 접근할 때, 데이터 충돌이 발생할 가능성을 미리 고려하고 이를 방지하기 위해
자원에 대해 락을 미리 거는 방법이다.</p>

<p>하나의 트랜잭션이 자원에 접근시 락을 걸고, 다른 트랜잭션이 접근하지 못하게 하여 조회 또는 갱신 처리가 완료될 때까지 락을 유지한다.</p>

<p>데이터베이스에서 Shared Lock(공유, 읽기 잠금) 이나 Exclusive Lock(배타, 쓰기 잠금) 을 걸 수 있다.</p>

<p>충돌이 자주 발생하는 상황에서 유리하며 데이터의 무결성을 보장한다. 하지만 읽기 작업이 많이 이루어지는 경우 성능이 떨어지며
서로 자원이 필요한 경우 데드락에 걸릴 가능성이 있다.</p>

<p><img src="https://github.com/user-attachments/assets/c39ab451-cc23-410c-a80b-5b8e5f9e4c0a" alt="deadlock.png" /></p>

<p>따라서, 조건을 추가하여 대기시간을 주거나 예외처리가 가능하다.</p>

<blockquote>
  <h6 id="no-wiat">NO WIAT</h6>
  <p>잠금을 획득하지 못하면 바로 예외를 발생시킨다. <br />
트랜잭션은 다른 트랜잭션의 잠금이 해제될 때까지 대기하지 않고, 바로 실패한다. <br />
즉각 적인 실패 응답이 필요한 경우 사용</p>

  <h6 id="waitn">WAIT[n]</h6>
  <p>트랜잭션이 잠금을 요청했을 때, 해당 자원이 잠겨있는 경우, 최대 n 초 동안 대기한다.<br />
n 초 동안 잠금이 해제되지 않으면 예외가 발생하며 트랜잭션이 실패한다.</p>
</blockquote>

<p>트랜잭션이 시작될 때 Shared Lock 또는 Exclusive Lock을 걸고 시작한다.</p>

<p><br /></p>

<h3 id="공유-락-shared-lock-read-lock">공유 락 (Shared Lock, Read Lock)</h3>
<p><code class="language-plaintext highlighter-rouge">특정 자원에 대해 여러 트랜잭션이 동시에 읽기 작업을 수행할 수 있도록 허용하는 락</code></p>

<p>여러 트랜잭션이 동시에 접근하여 데이터를 읽을 수 있지만, 쓰기 작업은 제한된다. 주로 데이터 읽기의 동시성을 높이기 위해
사용하며, 어떤 자원에 공유락이 동시에 여러 개 적용될 수 있다.</p>

<p>일반적으로 select 할 때 공유락이 발생하며, 어떤 자원이 공유락에 걸려있는 경우 베타적 락을 걸 수 없다.</p>

<h4 id="공유락의-특징">공유락의 특징</h4>
<ol>
  <li><strong>동시 읽기 허용</strong><br />
공유락이 설정된 자원은 여러 트랜잭션이 동시에 읽을 수 있다. 
데이터를 읽는 작업이 병렬로 수행되기 때문에 성능이 향상된다.</li>
  <li><strong>쓰기 제한</strong><br />
공유락이 설정된 자원에 대해 다른 트랜잭션이 쓰기 작업을 수행하려고 하면
그 트랜잭션은 공유락이 해제될 때까지 대기해야 한다.
데이터를 일관되게 유지하고, 읽기 중인 데이터가 변경되지 않도록 보장한다.</li>
  <li><strong>락 충돌</strong><br />
만약 한 트랜잭션이 공유락을 걸고 데이터를 읽고 있을 때, 다른 트랜잭션이 해당 자원에 배타락을 걸려고 시도하면 충돌이 발생한다.
이 경우 쓰기 작업은 공유락이 해제될 때까지 대기한다.</li>
  <li><strong>데이터 일관성 유지</strong><br />
공유락은 트랜잭션이 데이터를 읽는 동안 해당 데이터가 다른 트랜잭션에 의해 변경되지 않도록 보호한다.</li>
</ol>

<blockquote>
  <h5 id="공유락의-장단점">공유락의 장단점</h5>
  <p>여러 트랜잭션이 동시에 데이터를 읽을 수 있어 읽기 작업의 효율성이 높으며, 데이터를 읽는 동안 데이터의 일관성을 유지할 수 있다.
그러나 여러 트랜잭션이 공유락을 설정한 상태엣서는 쓰기 작업을 기다려야 하기 때문에 성능저하가 발생할 수 있다.
또한 데드락이 발생할 수 있다.</p>
</blockquote>

<p><br /></p>

<h3 id="배타-락-exclusive-lock-write-lock">배타 락 (Exclusive Lock, Write Lock)</h3>
<p><code class="language-plaintext highlighter-rouge">특정 자원(데이터, 행, 테이블 등)에 대해 하나의 트랜잭션이 독점적으로 접근할 수 있도록 설정하는 락</code></p>

<p>배타락이 걸린 자원에는 다른 트랜잭션이 읽기, 쓰기 작업을 수행할 수 없다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">SELECT</span> <span class="o">*</span> <span class="no">FROM</span> <span class="nc">Member</span> <span class="no">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span> <span class="no">FOR</span> <span class="no">UPDATE</span><span class="o">;</span>
</code></pre></div></div>

<p>배타락을 설정하기 위해 사용하는 구문이며, 해당 데이터에 쓰기락을 걸어, 
다른 트랜잭션이 동시에 그 데이터에 접근, 수정하지 못하도록 한다.</p>

<h4 id="배타락의-특징">배타락의 특징</h4>
<ol>
  <li><strong>독점적 접근</strong><br />
자원을 잠근 트랜잭션이 자원을 독점적으로 접그할 수 있다. 다른 트랜잭션은 해당 자원이 잠겨있는 동안 접근할 수 없다.</li>
  <li><strong>쓰기 작업 보호</strong><br />
일반적으로 쓰기(수정, 삭제, 삽입 등) 작업을 수행하기 전에 설정된다.
따라서 다른 트랜잭션이 해당 자원을 동시에 수정하지 못하도록 하여 충돌을 방지한다.</li>
  <li><strong>동시성 제어</strong><br />
데이터를 보호하고 여러 트랜잭션이 동시에 데이터를 처리할 때 발생할 수 있는 문제를 예방한다.</li>
  <li><strong>락 대기</strong><br />
다른 트랜잭션이 배타락이 걸린 자원에 접근하려고 하면, 해당 트랜잭션은 락이 해제될 때까지
대기해야 한다.</li>
</ol>

<p>예를 들어, 은행 시스템에서 특정 계좌의 잔액을 수정하는 트랜잭션이 있다.</p>

<p>트랜잭션 A가 계좌의 잔액을 수정하려고 할 때, 먼저 해당 계좌 데이터에 배타락을 설정한다.
이때, 트랜잭션 A가 작업을 완료하고 락을 해제할 때까지, 트랜잭션 B는 그 계좌에 접근할 수 없게된다.
트랜잭션 A가 작업을 완료한 후 락을 해제하면, 트랜잭션 B가 계좌에 접근할 수 있다.</p>

<p>데이터의 무결성과 일관성을 보장하며 충돌을 미리 방지하여 데이터의 손상과 비 일관성을 방지한다.</p>

<p>그러나 자원이 락이 걸린 동안 다른 트랜잭션이 대기해야 하므로 성능 저하가 발생할 수 있으며,
대기 시간이 길어질 경우, 데드락의 가능성이 증가한다.</p>

<blockquote>
  <h5 id="배타락의-장단점">배타락의 장단점</h5>
  <p>데이터의 무결성과 일관성을 보장하며, 충돌을 사전에 방지하기 때문에 데이터의 손상과 비일관성을 방지할 수 있다.</p>

  <p>그러나 자원이 락에 걸린동안 다른 트랜잭션이 대기해야하기 때문에 성능 저하가 발생할 수 있으며, 대기 시간이 길어질 경우 데드락의 가능성이 증가한다.</p>
</blockquote>]]></content><author><name></name></author><category term="Java" /><summary type="html"><![CDATA[동시성 Concurrency]]></summary></entry><entry><title type="html">Socket</title><link href="http://localhost:4000/java/2024/08/27/java-socket.html" rel="alternate" type="text/html" title="Socket" /><published>2024-08-27T00:00:00+09:00</published><updated>2024-08-27T00:00:00+09:00</updated><id>http://localhost:4000/java/2024/08/27/java-socket</id><content type="html" xml:base="http://localhost:4000/java/2024/08/27/java-socket.html"><![CDATA[<h2 id="socket">Socket</h2>
<p>소켓은 TCP/IP 기반의 네트워크 통신에서 데이터 송수신의 마지막 접점을 말한다ㅣ.
네트워크를 통해 두 컴퓨터 간의 데이터 통신을 하고, 클라이언트와 서버 간의 연결을 관리한다.</p>

<p>클라이언트가 서버에 연결 요청을 보내고, 서버가 이 요청을 수락하면 데이터 전송이 시작된다.</p>

<p>지속적으로 연결을 유지하며 실시간으로 데이터를 주고 받는다.</p>

<p>클라이언트와 서버로 구분되며, 네트워크 상에서 클라이언트와 서버에 해당하는 컴퓨터를 식별하기 위해 IP 주소와 
해당 컴퓨터 내에서 현재 통신에 사용되는 응용프로그램을 식별하기 위한 포트번호가 사용된다.</p>

<p><img src="https://github.com/user-attachments/assets/5ee55c98-b46c-433a-9f66-1285d9a1372e" alt="socket.png" /></p>
<h3 id="server">Server</h3>
<p>데이터 제공</p>

<h3 id="client">Client</h3>
<p>데이터를 요청하여 제공받는 쪽</p>

<p><br /></p>

<h3 id="주요-클래스">주요 클래스</h3>
<h4 id="socket-1">Socket</h4>
<ul>
  <li>클라이언트 측에서 사용하는 클래스로 서버에 연결을 설정하고 데이터를 송수신한다.</li>
</ul>

<h4 id="serversocket">ServerSocket</h4>
<ul>
  <li>서버 측에서 사용되는 클래스로 특정 포트에서 클라이언트의 연결 요청ㅇㄹ 기다리고, 요청이 들어오면 이를 수락하여
Socket 객체를 생성한다.</li>
</ul>

<h4 id="inputstream-outputstream">InputStream/ OutputStream</h4>
<ul>
  <li>소켓을 통해 데이터를 주고 받는데 사용한다.</li>
</ul>

<h4 id="inetaddress">InetAddress</h4>
<ul>
  <li>IP 주소를 다루기 위한 클래스로 특정 호스트의 IP 주소를 얻거나, 호스트 이름을 IP 주소로 변환하는데 사용한다.</li>
</ul>

<p><br /></p>

<h3 id="클라이언트와-서버-간의-연결">클라이언트와 서버 간의 연결</h3>
<ol>
  <li>
    <p>서버 소켓 생성 후 대기
서버가 ServerSocket 를 생성 후, accept() 메서드를 호출하여 클라이언트의 연결 요청을 대기한다.</p>
  </li>
  <li>
    <p>클라이언트 측 설정 후 연결 요청
클라이언트는 서버의 IP 주소와 포트 번호로 Socket 객체를 생성하고, 서버에 연결을 요청한다.</p>
  </li>
  <li>
    <p>서버에서 연결 수락
서버는 클라이언트의 연결 요청을 수락하과, 연결된 클라이언트와 통신하기 위해 Socket 객체를 생성한다.</p>
  </li>
  <li>
    <p>데이터 송수신
클라이언트와 서버는 InputStream, OutputStream을 사용하여 데이터를 주고 받는다.</p>
  </li>
  <li>
    <p>연결 종료
통신이 끝나면 클라이언트와 서버는 각각 소켓을 닫아 연결을 종료한다.</p>
  </li>
</ol>

<p><br /></p>

<h1 id="데이터-처리">데이터 처리</h1>
<p>소켓을 통해 데이터를 주고받는 과정에서 데이터를 적절한 형식으로 변환하고 수신 후 원래의 형싱으로 변환하는 작업이 필요하다.
이 과정을 패킹, 언패킹이라고 한다.</p>

<h3 id="패킹-packing">패킹 Packing</h3>
<p>전송 전 데이터를 바이트 배열이나 스트림으로 변환하는 과정</p>
<ul>
  <li>텍스트 데이터
```java
String message = “Hello”;
byte[] data = message.getBytes(message);</li>
</ul>

<p>outputStream.write(data);</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 객체 데이터
객체를 전송하는 경우, 객체를 직렬화하여 바이트 배열로 변환한다.  
ObjectOutputStream을 사용하여 객체를 직렬화할 수 있다.
```java
ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());

oos.writeObject(myObject);
</code></pre></div></div>

<h3 id="언패킹-unpacking">언패킹 Unpacking</h3>
<p>수신된 바이트 데이터를 원래 형식으로 변환하는 과정</p>
<ul>
  <li>텍스트 데이터
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">byte</span><span class="o">[]</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">1024</span><span class="o">];</span>
<span class="kt">int</span> <span class="n">bytesRead</span> <span class="o">=</span> <span class="n">inputStream</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">buffer</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">receivedMessage</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">bytesRead</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">);</span>
</code></pre></div>    </div>
  </li>
  <li>객체 데이터 
직렬화된 객체를 수신한 경우, 역직렬화를 통해 원래 객체로 복원한다.
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ObjectInputStream</span> <span class="n">ois</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectInputStream</span><span class="o">(</span><span class="n">socket</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">());</span>
<span class="nc">MyObject</span> <span class="n">myObject</span> <span class="o">=</span> <span class="o">(</span><span class="nc">MyObject</span><span class="o">)</span> <span class="n">ois</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
</code></pre></div>    </div>
  </li>
</ul>

<p><br /></p>

<h1 id="예외">예외</h1>
<h4 id="ioexception">IOException</h4>
<p>데이터 전송 중 연결이 끊어지거나, 네트워크 오류가 발생하는 경우 발생한.
 서버가 다운되거나, 클라이언트와 연결이 갑자기 끊어지는 경우</p>

<h4 id="sockettimeoutexception">SocketTimeoutException</h4>
<p>소켓에서 데이터 수신을 대기하는 동안 일정 시간 내에 응답이 없는 경우다 발생한다.<br />
 소켓에서 타임아웃을 설정할 수 있으며, 타임아웃이 지나면 예외가 발생</p>

<h4 id="unknownhostexception">UnknownHostException</h4>
<p>잘못된 호스트 이름이나 IP주소를 사용하여 소켓을 생성할 때 발생한다.
 호스트 이름을 사용하ㅏ여 소켓을 생성할 때 , 도메인 이름이 잘못되었거나 존재하지 않는 경우 발생한다.
 도메인 이름을 IP 주소로 변환하는 DNS 서버에 문제가 있거나, 네트워크 연결이 끊어지 경우 발생할 수 있다.
 소켓을 생성하기 전 호스트 이름으 유효한지 검증하는 방법을 통해 해당 예외를 예방할 수 있다.
 InetAddress클래스를 사용하여 도메인 이름이 IP 주소로 변환될 수 있는지 미리 확인할 수 있다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">{</span>
    <span class="nc">InetAddress</span> <span class="n">address</span> <span class="o">=</span> <span class="nc">InetAddress</span><span class="o">.</span><span class="na">gettByteName</span><span class="o">(</span><span class="s">"invalid.com"</span><span class="o">);</span>
    <span class="nc">Socket</span> <span class="n">socket</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Socket</span><span class="o">(</span><span class="n">address</span><span class="o">,</span> <span class="mi">8080</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">UnknownHostException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Invalid host name: "</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div>
<p>네트워크 연결이 정상적인지, DNS 서버가 올바르게 동작하는지 확인해야 한다.
 서버 측에서 문제가 발생하는 경우, 네트워크 설정을 점검하고, 필요시 DNS 서버를 변경하거나 네트워크 관리자에게 문의할 수 있다.</p>

<h4 id="bindexception">BindException</h4>
<p>서버 소켓이 이미 사용 중인 포트에 바인딩하려고 할 때 발생한다.
 일반적으로 서버 소켓이 열려고하는 포트가 이미 다른 프로세스에서 사용 중 일때 발생
 리눅스/ 유닉스 기반 시스템에서 권한이 없는 사용자가 1024 이하의 포트 번호에 바인딩하려고 할 때 발생할 수 있다.
 서버 소켓을 생성하기 전에 해당 포트가 이미 사용 중인지 확인하여, 다른 포트를 사용하거나, 사용 중인 포트를 해제한 후 포트를 사용할 수 있다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">{</span>
    <span class="nc">ServerSocket</span> <span class="n">serverSocket</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ServerSocket</span><span class="o">(</span><span class="mi">8080</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">BindException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Port 8080 is already in use. Please choose another port."</span><span class="o">);</span>
    <span class="c1">// 대처: 다른 포트를 선택하거나, 현재 사용 중인 포트를 해제 후 재시도</span>
<span class="o">}</span>
</code></pre></div></div>
<p>1024 이하의 포트를 사용하는 경우, 관리자 권한으로 프로그램을 실행하거나, 관리자 권한을 부여받을 수 있다.</p>

<h4 id="eofexception">EOFException</h4>
<p>클라이언트나 서버가 데이터를 더 이상 전송하지 않을 때 발생한다.
 스트림의 끝을 만나는 경우 발생</p>

<h4 id="classnotfoundexception">ClassNotFoundException</h4>
<p>객체를 역렬화할 때, 해당 클래스가 현재 클래스패스에 존재하지 않는 경우 발생
 주로 네트워크 통신에서 클라이언트와 서버 간의 클래스 버전이 일치하지 않거나 클래스가 누락된 경우 발생한다.
 역직렬화하려는 객체의 클래스가 클래스패스에 존재하는지 확인하고, 네트워크 통신을 하는 클라이언트와 서버가
동일한 클래스 버전을 사용하도록 해야 한다.
 서버와 클라이언트의 JAR 파일 또는 클래스파일이 일치하는지 확인하고, 누락된 클래스가 없는지 점검한다.
 동일한 클래스를 포함한 JAR 파일을 클라이언트와 서버에 모두 배포하여 버전 불일치 문제를 방지한다.
 만약 클라이언트와 서버의 환경이 다른 경우, 서버에서 클라이언트로 클래스 파일을 전송하거나, 
  클래스 로더를 사용해 동적으로 로드할 수 있는 방법을 고려해야 한다.</p>

<p>멀티 채팅
<img src="https://github.com/user-attachments/assets/cac5f24b-2938-4931-a823-4906bd41c9b4" alt="multi.png" /></p>

<p>서버 소켓이 루프를 돌면서 클라이언트가 연결될 때마다 새로운 스레드를 생성한다.
이렇게 생성된 스레드는 클라이언트에서 메세지가 들어올때마다 전체 클라이언트에 브로드캐스트한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

</code></pre></div></div>]]></content><author><name></name></author><category term="Java" /><summary type="html"><![CDATA[Socket 소켓은 TCP/IP 기반의 네트워크 통신에서 데이터 송수신의 마지막 접점을 말한다ㅣ. 네트워크를 통해 두 컴퓨터 간의 데이터 통신을 하고, 클라이언트와 서버 간의 연결을 관리한다.]]></summary></entry><entry><title type="html">ThreadLocal</title><link href="http://localhost:4000/java/2024/08/20/java-threadlocal.html" rel="alternate" type="text/html" title="ThreadLocal" /><published>2024-08-20T00:00:00+09:00</published><updated>2024-08-20T00:00:00+09:00</updated><id>http://localhost:4000/java/2024/08/20/java-threadlocal</id><content type="html" xml:base="http://localhost:4000/java/2024/08/20/java-threadlocal.html"><![CDATA[<h1 id="threadlocal">ThreadLocal</h1>
<p>각각의 스레드 별로 별도의 저장 공간을 제공하는 컨테이너</p>

<p>각 스레드는 자신만의 별도의 데이터를 가질 수 있고, 다른 스레드와 독립적으로 데이터를 설정하고 조회할 수 있다.</p>

<p>각 인스턴스는 특정 스레드에 연결되어 있는 데이터를 참조하며 다른 스레드에 영향을 주지 않는다.
이를 통해 멀티 스레드 환경에서도 스레드 간 데이터 공유와 동기화 문제를 해결할 수 있다.</p>

<p>각 요청마다 사용자 인증 정보를 threadLocal 에 저장하여 스레드 별로 관리할 수 있고, 이를 통해 여러 요청 간 사용자 정보를 명시적으로 전달하지 않고도 사용할 수 있다.</p>

<p>또한 데이터베이스 트랜잭션에서 Connection 객체를 ThreadLocal에 저장하여 각 스레드가 독립적으로 데이터베이스 연결을 관리하고, 트랜잭션 내에서 데이터베이스 연결을 공유하여 스레드 간의 충돌을 방지할 수 있.
한 번 계산된 결과를 스레드별로 캐시해서 다시 계산하지 않고 재사용할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadLocalExample</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">ThreadLocal</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">threadLocalValue</span> <span class="o">=</span> <span class="nc">ThreadLocal</span><span class="o">.</span><span class="na">withInitial</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="o">);</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Runnable</span> <span class="n">task</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">threadLocalValue</span><span class="o">.</span><span class="na">set</span><span class="o">((</span><span class="kt">int</span><span class="o">)</span> <span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">random</span><span class="o">()</span> <span class="o">*</span> <span class="mi">100</span><span class="o">));</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Thread local value: "</span> <span class="o">+</span> <span class="n">threadLocalValue</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
        <span class="o">};</span>

        <span class="nc">Thread</span> <span class="n">thread1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">task</span><span class="o">);</span>
        <span class="nc">Thread</span> <span class="n">thread2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">task</span><span class="o">);</span>
        <span class="nc">Thread</span> <span class="n">thread3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">task</span><span class="o">);</span>

        <span class="n">thread1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">thread2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">thread3</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">threadLocalValue</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p>하지만 메모리 누수를 유발할 수 있으며 ThreadLocal에 저장된 데이터는 스레드가 종료되어도 자동으로 해제되지 않는다. 따라서 사용이 끝난 후 remove() 메서드를 호출해서 데이터를 삭제해야 한다.</p>

<p><br /></p>

<h2 id="threadlocal-클래스의-initialvalue-메서드">ThreadLocal 클래스의 initialValue() 메서드</h2>
<p>ThreadLocal 변수가 처음 사용될 때 호출하며 각 스레드 별로 별도의 초기값을 반환한다.</p>

<p>각 스레드가 독립적으로 관리해야 하는 데이터의 초기값을 설정할 때 사용되며 로그인 사용자 정보, 트랜잭션 관리를 위한 초기 상태등을 초기화 한다.</p>

<p><br /></p>

<h2 id="스레드-재사용과-remove">스레드 재사용과 remove()</h2>
<p>데이터를 해제하는 메서드</p>

<p>스레드가 재사용되는 겨우 이전에 설정된 데이터가 존재하기 때문에 이전의 데이터와 공유될 수 있다.</p>

<p>ThreadLocal 변수의 데이터는 스레드마다 독립적으로 관리되지만, 스레드 풀에서 스레드가 재사용되는 동안
여러 스레드가 동시에 같은 변수에 접근하면 데이터의 일관성에 문제가 발생할 수 있다.</p>

<p>따라서 remove()를 이용하여 이전의 데이터를 해제해 주어야 한다.
사용하지 않는 경우 해당 스레드의 생명 주기 동안 메모리 리소스가 유지되기 때문에 메모리 누수가 발생할 수 있다.</p>

<p>또한, 스레드 풀의 사용을 제한할 수 있다. 스레드 풀을 사용하지 않으면 스레드가 작업을 완료한 후 종료되기 때문에 자동으로 ThreadLocal 변수가 제거된.
사용자 정의 스레드 팩토리를 사용하여 스레드가 종료될 때 ThreadLocal 변수를 명시적으로 제거할 수 있도록 구현하는 방법도 있습니다.다</p>

<p><br /></p>

<h3 id="remove">remove()</h3>
<p>ThreadLocal의 remove() 메서드를 호출하면, 현재 스레드와 연결된 ThreadLocal 값이 ThreadLocalMap에서 제거됩니다. 이때 변수의 삭제와 관련된 중요한 포인트는 다음과 같습니다:</p>

<ol>
  <li>remove() 메서드 호출 시점
실제 동작: remove() 메서드가 호출되면, 현재 스레드에 할당된 ThreadLocalMap에서 해당 ThreadLocal 객체에 대한 참조가 삭제됩니다. 이로 인해 해당 스레드와 연결된 ThreadLocal 값은 더 이상 접근할 수 없게 됩니다.</li>
</ol>

<p>메모리 정리: ThreadLocal에 저장된 값에 대한 참조가 사라지므로, 해당 값은 더 이상 사용되지 않으며, JVM의 Garbage Collector(GC)에 의해 수거될 수 있는 상태가 됩니다. 즉, 메모리에서 실제로 제거되는 시점은 GC가 이 객체를 수거할 때입니다.</p>

<ol>
  <li>실제 메모리에서의 삭제 시점
GC에 의해 수거: ThreadLocalMap에서 참조가 제거되면, ThreadLocal 객체와 그 값은 다른 곳에서 참조되지 않는 한 메모리에서 수거될 수 있는 상태가 됩니다. 하지만 실제로 메모리에서 언제 삭제될지는 GC의 작동 시점에 달려 있습니다.</li>
</ol>

<p>강제 수거: 메모리 누수를 방지하기 위해, ThreadLocal.remove()를 호출한 후에는 가능한 ThreadLocal 객체가 가비지 컬렉션 대상이 되도록 강제로 참조를 해제하는 것이 좋습니다.</p>

<ol>
  <li>가비지 컬렉션과의 관계
약한 참조(Weak Reference): ThreadLocalMap은 ThreadLocal 키를 약한 참조로 저장합니다. 이는 ThreadLocal 객체가 더 이상 강한 참조를 가지고 있지 않으면 GC에 의해 수거될 수 있음을 의미합니다. 하지만, ThreadLocal에 연결된 값은 여전히 강한 참조로 유지되기 때문에 remove()를 호출해 해당 참조를 해제하지 않으면 메모리 누수가 발생할 수 있습니다.</li>
</ol>

<p><br /></p>

<h2 id="스레드-팩토리">스레드 팩토리</h2>
<p>스레드 클래스의 run 메서드에섯 ThreadLocal.remove()를 호출하여 스레드 종료 전에 변수를 제거할 수 있다.
ThreadFactory 인터페이스를 구현해 새로운 스레드를 생성하고 생성된 스레드에서 remove() 메서드를 호출해 자원의 누수를 방지해야한다. 
스레드 풀은 스레드를 재사용하기 때문에 재사용 이전에 ThreadLocal 값이 남아있지 않도록, 사용후 값을 제거해주어야 한다.
remove()메서드를 이용하여 변수를 정리하여 메모리 누수를 방지해야 한다.</p>

<p><br /></p>

<h2 id="set-메서드">set() 메서드?</h2>
<p>변수를 제거한 후 해당 변수를 다시 사용하기 위해 set() 메서드를 사용해 새로운 값을 설정할 수 있다.</p>

<p><br /></p>

<h2 id="스레드가-종료">스레드가 종료</h2>
<p>ThreadLocal 변수를 제거하지 않고도 스레드가 종료될 때 자동으로 제거되는 방법은 스레드가 짧은 생명주기를 갖는 경우에 실행될 수 있습니다. ㅎ</p>

<p>스레드가 종료되면 스레드에 바인딩된 ThreadLocal 변수들도 함께 제거된다.</p>

<p>단위테스트나 통합 테이스에서도 일반적으로 테스트가 완료되면 종료되기 때문에 제거할 필요가 없다.</p>

<p><br /></p>

<h2 id="threadlocalwithinitial">ThreadLocal.withInitial()</h2>
<p>초기값을 설정하는 메서드로 변수의 초기화 로직을 간소화할 수 있다.</p>

<p>모든 스레드가 동일한 초기값을 갖기 때문에 일관성을 유지할 수 있으며 초기값 설정이 변수 선언과 동시에 일어나기 때문에 코드가 가독성이 좋다.</p>

<p><br /></p>

<h2 id="제거한-변수를-다시-사용하려면">제거한 변수를 다시 사용하려면?</h2>
<h3 id="1-get-또는-set-메서드를-호출하여-초기화">1. get() 또는 set() 메서드를 호출하여 초기화</h3>
<p><strong>get() 메서드 호출</strong></p>

<p>remove() 메서드가 호출된 후에 get() 메서드를 호출하면, ThreadLocal 변수는 초기화된다. 만약 ThreadLocal이 기본값 초기화 로직을 가지고 있다면, get() 메서드를 호출할 때 이 로직이 실행되어 새로운 값이 설정된다.
만약 초기화 로직이 없다면, get() 메서드는 null을 반환한다.</p>

<p><strong>set() 메서드 호출</strong></p>

<p>set(T value) 메서드를 사용하여 ThreadLocal 변수에 새로운 값을 명시적으로 설정할 수 있다. 이렇게 하면 해당 스레드에 대해 새로운 값이 할당된다.</p>

<p><br /></p>

<h2 id="사용자-정의-스레드-팩토리">사용자 정의 스레드 팩토리</h2>
<p>스레드 클래스의 run 메서드에섯 ThreadLocal.remove()를 호출하여 스레드 종료 전에 변수를 제거할 수 있다.</p>

<p>ThreadFactory 인터페이스를 구현해 새로운 스레드를 생성하고 생성된 스레드에서 remove() 메서드를 호출해 자원의 누수를 방지해야한다.
스레드 풀은 스레드를 재사용하기 때문에 재사용 이전에 ThreadLocal 값이 남아있지 않도록, 사용후 값을 제거해주어야 한다.
remove()메서드를 이용하여 변수를 정리하여 메모리 누수를 방지해야 한다.</p>

<p><br /></p>

<p>remove() 메서드를 호출하는 것이 중요한 이유는 스레드가 종료되도 변수값이 메모리에 남아있기 때문에 제거해주어야한다… 메모리 누수가 발생하지 않도록
다른 방법으로는 변수를 초기화하거나 제거하여  데이터가 남지않도록 하거나 beforeExecute(), afterExecute() 메서드에서 threadLocal 변수의 값을 초기화하는 방법이 있다.</p>

<p><br /></p>

<h3 id="beforeexecute-afterexecute">beforeExecute(), afterExecute()</h3>
<p>beforeExecute()와 afterExecute() 메서드를 이용 스레드가 작업을 시작하고 종료할 때 ThreadLocal 변수의 상태를 관리할 수 있다. 
주의할 점은 메서드 내부에서의 동기화 문제와, 스레드가 재사용될 때 데이터가 남지않도록 해야한다.
또한 스레드 종료 후 변수를 제거하여 메모리 누수를 방지해야 한다.</p>

<p><br /></p>

<h3 id="threadpoolexecutor의-execute-submit">ThreadPoolExecutor의 execute(), submit()</h3>
<p>execute는 Runnable 작업을 제출하고 결과를 반환하지 않는다
submit는 Runnable 또는 Callable 작업을 제출하고 Future를 통해 결과를 얻을 수 있다.</p>]]></content><author><name></name></author><category term="Java" /><summary type="html"><![CDATA[ThreadLocal 각각의 스레드 별로 별도의 저장 공간을 제공하는 컨테이너]]></summary></entry><entry><title type="html">프로세스의 상태</title><link href="http://localhost:4000/os/2024/08/20/os-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4.html" rel="alternate" type="text/html" title="프로세스의 상태" /><published>2024-08-20T00:00:00+09:00</published><updated>2024-08-20T00:00:00+09:00</updated><id>http://localhost:4000/os/2024/08/20/os-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4</id><content type="html" xml:base="http://localhost:4000/os/2024/08/20/os-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4.html"><![CDATA[<h1 id="process">Process</h1>
<p><strong>실행 중인 프로그램</strong></p>

<p>CPU에서 명령을 수행하기 위한 데이터와 상태 정보를 포함한다.
하나의 프로그램은 여러 개의 프로세스를 가질 수 있고, 각 프로세스는 독립적으로 실행된다.</p>

<p>스택, 힙, 데이터, 코드로 구성된다.</p>

<p>프로세스 문맥은 운영체제가 프로세스의 실행 상태를 추적하고 관리하기 위해 필요한 정보이디ㅏ.
프로세스가 CPU에서 실행되다가 중단될 때, 다시 실행될 때 이전과 동일한 상태에서 시작할 수 있도록 한다.</p>

<p>문맥전환은 CPU가 한 프로세스의 문맥을 저장하고 다른 프로세스의 문맥을 로드하여 실행을 전환하는 과정을 말한다.</p>

<p><br /><br /><br /></p>

<h1 id="process-conext">Process Conext</h1>
<p>크게 세 가지(<strong>하드웨어 문맥, 프로세스의 주소 공간, 커널 상의 문맥</strong>)로 구성된다.</p>

<p>하드웨어 문맥은 CPU 수행 상태를 나타내는 것으로 PC와 각종 레지스터에 저장하고 있는 값이다.</p>

<p>프로세스의 주소 공간은 코드, 데이터, 스택으로 구성된 프로세스만의 독자적인 주소 공간이다.</p>

<p>커널상의 문맥은 프로세스 관리를 위한 PCB와 Kernel stack이다.</p>

<p><br /></p>

<h4 id="pcb-process-control-block">PCB (Process Control Block)</h4>
<p><img src="https://github.com/user-attachments/assets/7b7f92ac-b40c-48a7-889c-b04847a057cc" alt="pcb.png" />
각 프로세스의 문맥을 저장하는 자료 구조로 운영체제가 각 프로세스를 관리하기 위해 사용한다.</p>

<ul>
  <li>
    <p><strong>Process ID</strong> : PID(Process Identification Number) 주로 PID 라고 줄여서 부릅니다. : 프로세스 고유 식별 번호</p>
  </li>
  <li>
    <p><strong>Process State(프로세스 상태)</strong> : 프로세스의 현재 상태(생성, 준비, 실행, 대기, 종료)를 기억 시킵니다.</p>
  </li>
  <li>
    <p><strong>Program Counter(계수기)</strong> : 다음에 실행되는 명령어의 주소를 기억시킵니다.</p>
  </li>
  <li>
    <p><strong>Process Priority(스케줄링 정보)</strong> : 프로세스 우선순위 등과 같은 스케줄링 관련 정보를 기억시킵니다.</p>
  </li>
  <li>
    <p><strong>CPU Registers</strong> : 프로세스의 레지스터 상태를 저장하는 공간 등, CPU 내 범용 레지스터, 데이터 레지스터, 세그먼트 레지스터 등이 갖고 있는 값을 기억시킵니다.</p>
  </li>
  <li>
    <p><strong>Owner(계정 정보)</strong> : CPU 사용시간의 정보(Quantum), 각종 스케줄러에 필요한 정보를 기억시킵니다.</p>
  </li>
  <li>
    <p><strong>기억장치 관리 정보</strong> : 프로그램이 적재될 기억 장치의 시작 지점(베이스 레지스터), 종료 지점(한계 레지스터), 페이지 테이블 등의 정보를 기억시킵니다.</p>
  </li>
  <li>
    <p><strong>입출력 정보</strong> : 프로세스 수행 시 필요한 주변 장치, 파일들의 정보를 기억시킵니다</p>
  </li>
</ul>

<p><br /></p>

<h4 id="cpu-레지스터">CPU 레지스터</h4>
<p>프로세스가 실행 중이었던 시점의 CPU 레지스터 값들이 저장된다. 프로그램 카운터와 스택 포인터 등의 레지스터를 포함한다.</p>

<p><br /></p>

<h4 id="메모리-관리-정보">메모리 관리 정보</h4>
<p>페이지 테이블, 세그먼트 테이블 등 프로세스가 사용하는 메모리 관련 정보가 포함된다.</p>

<p><br /></p>

<h4 id="스택">스택</h4>
<p>함수 호출 시 전달된 인자, 복귀 주소, 지역 변수 등 저장되는 영역</p>

<p><br /></p>

<h4 id="io-상태-정보">I/O 상태 정보</h4>
<p>함수 호출 시 전달되는 인자, 복귀 주소, 지역 변수 등이 저장되는 영역</p>

<p><br /><br /><br /></p>

<h1 id="context-switching">Context Switching</h1>
<p>한 프로세스의 실행을 중단하고 다른 프로세스를 실행할 때 발생</p>
<ol>
  <li>
    <p>현재 실행 중인 프로세스의 문맥 저장
현재 프로세스의 CPU 레지스터 값, 프로그램 카운터, 메모리 상태를 PCB에 저장</p>
  </li>
  <li>
    <p>다른 프로세스의 문맥 로드
다음에 실행할 프로세스의 PCB에서 문맥 정보를 불러와 CPU 레지스터에 로드한다.</p>
  </li>
  <li>
    <p>프로세스 실행 재개
로드된 문맥 정보에 따라 새로운 프로세스가 실행한다.</p>
  </li>
</ol>

<p>문맥 전환은 필수적이지만, 자주 발생하는 경우 오버헤드가 발생한다.</p>

<p><br /></p>

<h4 id="context-switching은-언제-발생하는지">Context Switching은 언제 발생하는지?</h4>
<ol>
  <li>멀티 태스킹 또는 시분할 시스템에서 할당된 시간이 종료된 경우</li>
  <li>입출력 또는 시스템 호출</li>
  <li>우선순위에 따른 프로세스 스케줄링</li>
  <li>프로세스가 종료되는 경우</li>
  <li>인터럽트 발생 시</li>
  <li>자발적인 CPU 양도</li>
</ol>

<p><br /></p>

<h4 id="프로세스와-스레드는-cont도ext-switching이-발생-차이">프로세스와 스레드는 Cont도ext Switching이 발생 차이</h4>
<p>프로세스는 code, data, heap, stack 영역을 독립적으로 가지고 있습니다. 따라서 Context Swtiching이 발생할 때, 독립적인 메모리를 포함하여, 캐시 메모리를 비워줘야 해서 스레드에 비해 상대적으로 많은 오버헤드가 발생합니다. 
이와 달리 스레드는 code, data, heap 영역을 공유하고 stack 영역만 독립적으로 가지고 있기 때문에, 캐시 메모리를 비우지 않아도 되고 프로세스에 비해 상대적으로 적은 오버헤드가 발생합니다.</p>

<p><br /></p>

<h4 id="context-switching-시-캐시-차이">Context Switching 시 캐시 차이</h4>
<p>프로세스는 독립적인 메모리 공간을 갖는다. 서로 다른 프로세스 간 문맥 전환이 일어날 때, 이전 프로세스가 사용하던 데이터가 CPU에 남아있을 수 잇따.<br />
그러나 새로운 프로세스의 메모리 주소 공간이 다르기 때문에 캐시 데이터는 새로운 프로세스에 대해 무효하다.</p>

<p>새로운 프로세스의 데이터를 다시 캐시에 로드해야 되기 때문에, 초기에는 캐시 미스가 발생한다.<br />
이로 인해서 CPU가 메모리에서 데이터를 다시 읽어와야 한다.</p>

<p>프로세스 간의 문맥 전환 시, TLB도 무효화되기 때문에 새로운 프로세스에 맞는 주소 변환을 다시 로드해야 한다.</p>

<p>스레드는 동일한 프로세스 내에서 실행되기 때문에 메모리 공간을 공유한다.<br />
같은 프로세스 내의 스레드 간 문맥 전환시 메모리 주소 공간이 동일하기 때문에, 캐시에 저장된 데이터가 유효하다.
따라서 캐시 미스가 덜 발생하며, 캐시의 내용을 다시 로드할 필요가 적다.</p>

<p>동일한 주소 공간을 공유하기 때문에 TLB도 그대로 유효하다. 그러나 여러 스레드가 캐시를 공유하면서
동시에 접근할 경우 캐시 경쟁이 발생할 수 있다.</p>

<blockquote>
  <p>Translation Lookaside Buffer</p>

</blockquote>

<h4 id="프로세스의-스레드에-대한-정보">프로세스의 스레드에 대한 정보</h4>
<p>PCB는 프로세스의 기본 정보를 관리하는데, 각 프로세스 내의 스레드에 대한 정보를 간접적으로 관리한다.
TCP는 스레드 제어 블록으로 스레드의 상태, 레짓스터, 스택 포인터 등을 저장하는 자료구조로, 
프로세스의 여러 스레드를 개별적으로 관리한다.<br />
프로세스는 공유 메모리를 통해 스레드들이 동일한 주소 공간에 접근하게 하며, 스케줄러는 TCB를 참조하여 스레드의 실행 순서를 정한다.</p>

<blockquote>
  <p>TCP (Thread Control Block)
Thread ID
Thread Status
CPU 정보 (PC, Register)
Thread Priority
스레드의 생성을 트리거한 프로세스를 가리키는 포인터
스레드에서 만든 스레드를 가리키는 포인터</p>
</blockquote>

<p><br /></p>

<h4 id="context-switching-에서-프로세스-수행-중에-입출력-상태로-전환되어서-대기-상태로-전환-되는데-cpu를-어떻게-하는-것이-효율적인가">Context Switching 에서 프로세스 수행 중에 입출력 상태로 전환되어서 대기 상태로 전환 되는데, CPU를 어떻게 하는 것이 효율적인가?</h4>
<p>Context Switching 에서 입출력 인터럽트가 발생하게 되면 실행 상태에 있던 프로세스는 대기 상태로 전환됩니다.
이때, CPU 스케줄러에 의해서 해당 프로세스의 자원은 반환됩니다. 
이후 CPU가 입출력 인터럽트의 완료를 기다리는 동안 준비 상태 큐에 있는 프로세스 중에서 스케줄링 알고리즘에 따라 실행 상태로 들어가고,
대기 상태에 있던 프로세스는 입출력 작업이 완료되게 되면 다시 준비상태 큐로 들어갑니다.</p>

<p><br /></p>

<h4 id="인터럽트의-처리-순서">인터럽트의 처리 순서</h4>
<p>CPU는 인터럽트를 우선순위에 따라서 처리한다.</p>

<p><br /></p>

<h4 id="pcb의-자료구조">PCB의 자료구조</h4>
<p>PCB는 Doubly Linked List 방식으로 관리된다.
PCB의 List Head에 PCB들이 생성될 때마다 붙으며, 
주소 값으로 연결이 이루어져 있는 연결리스트이기 때문에 삽입 삭제가 용이합니다.</p>

<p><br /></p>

<h4 id="context-switching-시에-주소공간에-대한-캐시-처리가-어떻게-이루어지는지-설명해주세요">Context Switching 시에 주소공간에 대한 캐시 처리가 어떻게 이루어지는지 설명해주세요.</h4>
<p>기존의 프로세스들을 메모리에 적재할 때, 순차적으로 적재를 하게 되면 단편화 문제가 발생하는데, 이를 방지하기 위해서 가상 메모리 기법이 생겼고, 가상 메모리 기법은 세그멘테이션과 페이징 기법으로 나눌 수 있다.
가상 메모리 기법으로 분할 된 메모리의 페이지들은 페이지 테이블에서 관리를 하게 되는데, 메모리에 실제 주소를 참조하기 위해서는</p>

<p>페이지 테이블에 한번 접근(fetch)
페이지 테이블을 기반으로 실제 메모리로 접근 (Memory Access)
와 같은 과정이 필요한데, 실행할 때마다 같은 table에 속한 메모리 주소를 찾고 다시 메인 메모리에 접근해야 하는 불필요한 일이 발생합니다.
이런 메모리의 접근을 줄이기 위해서 TLB가 등장했고, TLB는 page table의 임시저장 캐시 역할을 합니다. TLB는 L3 캐시에 위치해있습니다. 이때 TLB에는 최근에 읽었던 변환될 물리 주소를 매핑해서 저장을합니다. 따라서 TLB를 활용하면 한 프로세스 내의 다른 스레드를 Context Switching 하는 경우 invalid가 발생하지 않아, 주소 공간을 참조하는데 하드웨어 적으로 이점을 볼 수 있고, 프로세스가 Context Switching을 하게 되는 경우, kernel 주소 공간을 제외한 모든 영역을 invalid 하기 때문에, 스레드와 달리 손해를 보게 됩니다.</p>

<p><br /><br /><br /></p>

<h1 id="process-status">Process Status</h1>
<p><img src="https://github.com/user-attachments/assets/61b814de-ba75-4f83-bf4d-6b1203d57ac8" alt="process_status.png" /></p>

<h3 id="new">New</h3>
<p>프로세스가 생성된 상태</p>
<h3 id="ready">Ready</h3>
<p>프로세스가 CPU에 실행되기 위해 대기하는 상태로, CPU자원이 할당되지 않은 상태</p>
<h3 id="running">Running</h3>
<p>프로세스가 CPU를 할당받아 실제로 실행 중인 상태</p>
<h3 id="waiting">Waiting</h3>
<p>프로세스가 특정 자원이나 이벤트를 기다리는 상태</p>
<h3 id="terminated">Terminated</h3>
<p>프로세스가 실행이 완료되거나 종료된 상태</p>

<p><br /><br /></p>

<h2 id="상태-전이-동작">상태 전이 동작</h2>
<h3 id="dispatch">Dispatch</h3>
<p>우선순위가 높은 프로세스를 선정하여 명령어를 실행한다</p>
<h3 id="timeout">Timeout</h3>
<p>클럭이 인터럽트를 발생시켜 제어권을 빼앗는다.(Preemption:독점방지)</p>
<h3 id="block">Block</h3>
<p>프로세서가 입출력, 자원 등을 기다리기 위해 대기상태로 전환한다.</p>
<h3 id="wake-up">Wake up</h3>
<p>입출력이 완료되거나 자원이 할당되어 다시 실행한다.</p>

<p><br /><br /><br /></p>

<h1 id="scheduling">Scheduling</h1>
<p>운영체제는 여러 프로세스가 CPU를 공유할 수 있도록 프로세스를 스케줄링한다.<br />
스케줄러는 준비 상태의 프로세스 중 하나를 선택하여 CPU를 할당한다. 프로세스가 작업을 완료하거나 대기 상태로
전환되면 다음 프로세스에 CPU를 할당한다.</p>]]></content><author><name></name></author><category term="OS" /><summary type="html"><![CDATA[Process 실행 중인 프로그램]]></summary></entry></feed>